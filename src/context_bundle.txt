================================================================
PROJECT CONTEXT BUNDLE: D&D CAMPAIGN MANAGER
================================================================
INSTRUCTIONS FOR AI:
- This is the entire source code for a React/Vite app.
- Maintain architectural consistency at all costs.
- Reuse existing hooks, UI components, and Supabase patterns.
- Do not suggest new libraries or 'from-scratch' rewrites.
================================================================

### PROJECT MAP (FILE STRUCTURE)
./
  index.css
  main.jsx
  components/
    ErrorBoundary.jsx
    entity/
      EntityBadge.jsx
      EntityIcon.jsx
      EntityLink.jsx
      EntityStatusIcon.jsx
      index.js
    layout/
      CollapsibleSection.jsx
      index.js
      SplitView.jsx
      TabContainer.jsx
    markdown/
      index.js
      MarkdownRenderer.jsx
      MarkdownWithToC.jsx
    ui/
      Button.jsx
      Card.jsx
      DevAdminButton.jsx
      Drawer.jsx
      EmptyState.jsx
      LoadingSpinner.jsx
      SectionDivider.jsx
  config/
    entity/
      colors.js
      entityConfig.js
      icons.js
      index.js
      styles.js
      types.js
  features/
    admin-console/
      components/
        AdminForm.jsx
        EntitySearch.jsx
        EventTagger.jsx
        MarkdownEditor.jsx
        QuestObjectiveManager.jsx
        RelationshipManager.jsx
        SessionEventManager.jsx
        SmartImageInput.jsx
        ui/
          FormStyles.js
      config/
        strategies.js
      layouts/
        AdminLayout.jsx
      pages/
        EntityEditorPage.jsx
        EntityListPage.jsx
        SplitPaneManager.jsx
    app-core/
      App.jsx
      AppRoutes.jsx
      components/
        RouteLoading.jsx
    campaign-session/
      CampaignContext.jsx
      types.js
      useCampaignPersistence.js
      useCampaignSelection.js
      components/
        CampaignCard.jsx
        CampaignSelect.jsx
    entity-view/
      index.js
      useEntityViewModel.js
      WikiEntityView.jsx
      components/
        EntityBody.jsx
        EntityHeader.jsx
        EntityHistory.jsx
        EntitySidebar.jsx
        QuestObjectives.jsx
        SessionMentions.jsx
      hooks/
        useEntityContent.js
        useEntityHeader.js
        useEntitySidebar.js
      layouts/
        index.js
        SessionLayout.jsx
        StandardLayout.jsx
      pages/
        WikiEntryPage.jsx
      transforms/
        attributeTransform.js
        eventTransform.js
        relationshipTransform.js
        wikiEntryTransform.js
    global-search/
      GlobalSearch.jsx
      types.js
      useGlobalSearchViewModel.js
      components/
        SearchFooter.jsx
        SearchModal.jsx
        SearchResultItem.jsx
        SearchResults.jsx
        SearchTrigger.jsx
      transforms/
        searchTransform.js
    hooks/
      useTheme.js
    layout-main/
      MainLayout.jsx
      navConfig.js
      types.js
      useMainLayout.js
      components/
        Sidebar.jsx
        SidebarFooter.jsx
        SidebarHeader.jsx
        SidebarNav.jsx
    relationship-graph/
      RelationshipGraph.jsx
      types.js
      useGraphViewModel.js
      components/
        CytoscapeCanvas.jsx
        GraphLegend.jsx
      config/
        graphStyles.js
      transforms/
        graphTransform.js
    smart-text/
      SmartMarkdown.jsx
      types.js
      useEntityIndex.js
      useSmartText.js
      components/
        SmartEntityLink.jsx
    smart-tooltip/
      TooltipContainer.jsx
      TooltipContext.jsx
      types.js
      useSmartPosition.js
      useTooltipState.js
      components/
        TooltipCard.jsx
    table-of-contents/
      TableOfContents.jsx
      components/
        TocItem.jsx
        TocMobileDrawer.jsx
      hooks/
        useTocObserver.js
        useTocScroll.js
    timeline/
      TimelineView.jsx
      types.js
      useTimelineViewModel.js
      components/
        TimelineEvent.jsx
        TimelineSession.jsx
      utils/
        eventStyles.js
    wiki-layout/
      types.js
      useWikiNavigation.js
      WikiLayout.jsx
      components/
        SidebarEmptyState.jsx
        WikiSidebar.jsx
        WikiSidebarHeader.jsx
        WikiSidebarList.jsx
        sidebar/
          CollapsibleGroup.jsx
          EntityListItem.jsx
          PriorityIcon.jsx
          SidebarTreeItem.jsx
          StatusIcon.jsx
      config/
        groupingConfig.js
      hooks/
        useEntityFetching.js
        useEntityGrouping.js
      transforms/
        entityTransforms.js
    world-map/
      mapConfig.js
      MapView.jsx
      useMapData.js
      components/
        MapCanvas.jsx
        MapLayerControl.jsx
        useMapCanvasViewModel.js
        layers/
          MapAreas.jsx
          MapMarkers.jsx
          MapOverlays.jsx
          MapRecaps.jsx
      data/
      utils/
        mapNavigation.js
        markerUtils.js
  lib/
    supabase.js
  services/
    admin.js
    campaigns.js
    entities.js
    search.js
    timeline.js
  styles/
  utils/
    index.js
    entity/
      attributeParser.js
      entityHelpers.js
    image/
      imageResolver.js
    status/
      statusHelpers.js
    text/
      markdownHelpers.js
      textProcessing.js
    theme/
      colorHelpers.js
      cssVariables.js

================================================================
### SOURCE CODE
================================================================

--- FILE: index.css ---
@import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400;1,600&family=Inter:wght@300;400;500;600&family=Spectral:wght@400;500;600;700&display=swap');
@import 'tailwindcss';
@plugin "@tailwindcss/typography";

@theme {
	--font-sans: 'Inter', sans-serif;
	--font-serif: 'Inter', serif;
	--font-display: 'Crimson Text', serif;
	--color-border: var(--border);
	--color-background: var(--background);
	--color-foreground: var(--foreground);
	--color-muted: var(--muted);
	--color-muted-foreground: var(--muted-foreground);
	--color-accent: var(--accent);
	--color-accent-foreground: var(--accent-foreground);
}

:root {
	--background: #ffffff;
	--foreground: #0f172a;
	--muted: #f8fafc;
	--border: #e2e8f0;
	--accent: #d97706;
}

[data-theme='dark'] {
	--background: #020617;
	--foreground: #f1f5f9;
	--muted: #0f172a;
	--border: #1e293b;
	--accent: #f59e0b;
}

[data-theme='dnd'] {
	/* D&D BOOK PALETTE */
	--background: #fdfbf7;
	--foreground: #1b1b1b;
	--muted: #f2efe9;
	--muted-foreground: #5f5a52;
	--border: #c9c2b8;
	--accent: #8b1e1e;
	--accent-foreground: #ffffff;
	--font-sans: 'Inter', sans-serif;
	--font-serif: 'Inter', serif;
}

/* --- HEADER GRADIENT CLASS --- */
/* Gradient that blends into the page background based on theme */
.header-gradient {
	background: linear-gradient(to top, #ffffff 0%, transparent 100%);
}

[data-theme='dnd'] .header-gradient {
	background: linear-gradient(to top, #fdfbf7 0%, transparent 100%);
}

[data-theme='dark'] .header-gradient {
	background: linear-gradient(to top, #020617 0%, transparent 100%);
}

/* --- HEADER BACKGROUND --- */
/* Default dark background for header images */
.header-bg-fallback {
	background: linear-gradient(to bottom right, #1e293b, #0f172a);
}

[data-theme='dnd'] .header-bg-fallback {
	background: linear-gradient(to bottom right, #8b7355, #5c4a3a);
}

[data-theme='dark'] .header-bg-fallback {
	background: linear-gradient(to bottom right, #1e293b, #0f172a);
}

/* --- D&D TEXTURE OVERRIDE --- */
/* Applies the texture to any element using bg-background when in D&D mode */
[data-theme='dnd'] .bg-background {
	background-color: var(--background); /* Fallback color */
	background-image: var(--bg-texture); /* Injected via JS */
	background-repeat: repeat;
}

[data-theme='dnd'] .prose {
	font-family: var(--font-sans);
	color: var(--foreground);
	line-height: 1.6;
}

[data-theme='dnd'] .prose h1,
[data-theme='dnd'] .prose h2,
[data-theme='dnd'] .prose h3 {
	font-family: var(--font-serif);
	font-weight: 700;
	color: var(--accent);
	letter-spacing: 0.01em;
}

[data-theme='dnd'] .prose h1 {
	border-bottom: 2px solid var(--accent);
}

[data-theme='dnd'] .prose h2 {
	border-bottom: 1px solid var(--border);
}

[data-theme='dnd'] .prose h3 {
	color: #4a0f0f;
}
[data-theme='dnd'] .prose p {
	font-family: var(--font-sans);
}
[data-theme='dnd'] .dnd-sidebar-box {
	background: var(--muted);
	border: 1.5px solid var(--border);
	border-left: 6px solid var(--accent);
	font-family: var(--font-sans);
}

[data-theme='dnd'] .dnd-sidebar-box h4 {
	font-family: var(--font-serif);
	font-size: 0.95rem;
	font-weight: 700;
	text-transform: uppercase;
	letter-spacing: 0.06em;
	color: var(--accent);
}
[data-theme='dnd'] .dnd-stat-row {
	display: flex;
	justify-content: space-between;
	border-bottom: 1px solid rgba(0, 0, 0, 0.08);
	font-size: 0.9rem;
}

[data-theme='dnd'] .dnd-stat-row:last-child {
	border-bottom: none;
}
[data-theme='dnd'] .prose table {
	border-collapse: collapse;
	width: 100%;
	font-family: var(--font-sans);
	font-size: 0.9rem;
}

[data-theme='dnd'] .prose th {
	background: var(--accent);
	color: white;
	text-align: left;
	font-weight: 600;
}

[data-theme='dnd'] .prose td {
	border-bottom: 1px solid var(--border);
}

[data-theme='dnd'] .prose tbody tr:nth-child(even) {
	background: rgba(0, 0, 0, 0.03);
}
[data-theme='dnd'] .prose blockquote {
	border-left: 4px solid var(--accent);
	color: #4b1c1c;
	font-style: italic;
	background: none;
}
[data-theme='dnd'] .prose ul {
	list-style: disc;
}

[data-theme='dnd'] .prose ol li::marker {
	color: var(--accent);
	font-weight: 600;
}
[data-theme='dnd'] .prose code {
	font-family: var(--font-sans);
	font-size: 0.85em;
	background: rgba(0, 0, 0, 0.05);
	border-radius: 3px;
}
[data-theme='dnd'] .prose hr {
	border: none;
	border-top: 2px solid var(--border);
}
[data-theme='dnd'] .prose a:not(:has(svg)) {
	color: var(--accent);
}

[data-theme='dnd'] .prose a:hover {
	color: #5f1111;
}

/* Fix for ToC highlight overlap with sticky headers */
.scroll-mt-20 {
	scroll-margin-top: 5rem;
}

/* Ensure our smart headers in markdown also have margin */
h1[id],
h2[id],
h3[id] {
	scroll-margin-top: 8rem;
}

/* Custom scrollbar for ToC to keep it elegant */
.custom-scrollbar::-webkit-scrollbar {
	width: 4px;
}
.custom-scrollbar::-webkit-scrollbar-track {
	background: transparent;
}
.custom-scrollbar::-webkit-scrollbar-thumb {
	background: #e2e8f0;
	border-radius: 10px;
}

/* 1. Popup Container (The Card) */
.leaflet-popup-content-wrapper {
	background: var(--background) !important;
	color: var(--foreground) !important;
	border: 1px solid var(--border);
	border-radius: 0.5rem !important; /* rounded-lg */
	box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04) !important; /* shadow-xl */
	font-family: var(--font-sans);
	padding: 0 !important; /* Remove default padding to let us control it */
	overflow: hidden;
}

/* 2. Popup Content (The Text) */
.leaflet-popup-content {
	margin: 0 !important;
	line-height: 1.6;
}

/* 3. The Little Triangle Tip */
.leaflet-popup-tip {
	background: var(--background) !important;
	box-shadow: none !important;
	border: 1px solid var(--border); /* Optional: might look weird depending on rotation */
}

/* 4. Close Button */
.leaflet-container a.leaflet-popup-close-button {
	color: var(--muted-foreground) !important;
	font-size: 1.2rem !important;
	padding: 4px !important;
	top: 4px !important;
	right: 4px !important;
	background: transparent !important;
}

.leaflet-container a.leaflet-popup-close-button:hover {
	color: var(--accent) !important;
}

/* 5. Tooltips (Area Names) */
.leaflet-tooltip {
	background-color: transparent !important;
	border: none !important;
	box-shadow: none !important;
	color: rgba(255, 255, 255, 0.9); /* Default to light text for map overlay */
	font-family: var(--font-serif);
	font-weight: 700;
	font-size: 1.1rem;
	text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
}

/* D&D Theme Specifics for Tooltips (If map background is light, invert this) */
[data-theme='dnd'] .leaflet-tooltip {
	/* If your map tiles are dark, keep white text. If light, use var(--accent) */
	/* text-shadow: 0 0 3px var(--background); */
}

--- END OF index.css ---

--- FILE: main.jsx ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import { HashRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import App from './features/app-core/App'; // Importing the Core Feature
import './index.css';
import 'leaflet/dist/leaflet.css'; // Leaflet Styles

// 1. Environment Validation
const validateEnv = () => {
	const required = ['VITE_SUPABASE_URL', 'VITE_SUPABASE_ANON_KEY'];
	const missing = required.filter((key) => !import.meta.env[key]);

	if (missing.length > 0) {
		console.error('Missing required environment variables:', missing);
	}
};
validateEnv();

// 2. Query Client Configuration
const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			staleTime: 1000 * 60 * 5, // 5 minutes
			cacheTime: 1000 * 60 * 30, // 30 minutes
			refetchOnWindowFocus: false,
			retry: 1,
		},
	},
});

// 3. Mount
ReactDOM.createRoot(document.getElementById('root')).render(
	<React.StrictMode>
		<QueryClientProvider client={queryClient}>
			<HashRouter>
				<App />
			</HashRouter>
		</QueryClientProvider>
	</React.StrictMode>
);

--- END OF main.jsx ---

--- FILE: components\ErrorBoundary.jsx ---
import { Component } from 'react';
import { AlertTriangle, RefreshCw } from 'lucide-react';
import Button from './ui/Button';

class ErrorBoundary extends Component {
	constructor(props) {
		super(props);
		this.state = { hasError: false, error: null };
	}

	static getDerivedStateFromError(error) {
		return { hasError: true, error };
	}

	componentDidCatch(error, errorInfo) {
		console.error('Error caught by boundary:', error, errorInfo);
	}

	handleReset = () => {
		this.setState({ hasError: false, error: null });
		window.location.reload();
	};

	render() {
		if (this.state.hasError) {
			return (
				<div className='min-h-screen flex items-center justify-center bg-muted p-4'>
					<div className='max-w-md w-full text-center'>
						<div className='mb-6 inline-flex items-center justify-center w-16 h-16 rounded-full bg-red-100'>
							<AlertTriangle className='w-8 h-8 text-red-600' />
						</div>
						<h1 className='text-2xl font-serif font-bold text-foreground mb-3'>Something went wrong</h1>
						<p className='text-gray-600 mb-6'>Don't worry, your data is safe. Try refreshing the page to continue.</p>
						{process.env.NODE_ENV === 'development' && this.state.error && (
							<details className='mb-6 text-left bg-red-50 border border-red-200 rounded-lg p-4'>
								<summary className='cursor-pointer font-semibold text-red-900 mb-2'>Error Details</summary>
								<pre className='text-xs text-red-800 overflow-auto'>{this.state.error.toString()}</pre>
							</details>
						)}
						<Button onClick={this.handleReset} icon={RefreshCw}>
							Reload Application
						</Button>
					</div>
				</div>
			);
		}

		return this.props.children;
	}
}

export default ErrorBoundary;

--- END OF components\ErrorBoundary.jsx ---

--- FILE: components\entity\EntityBadge.jsx ---
import { clsx } from 'clsx';
import { getEntityLabel, getEntityStyles } from '../../config/entity';

/**
 * EntityBadge Component
 * Displays a colored type badge for an entity
 *
 * @param {string} type - Entity type
 * @param {string} label - Optional custom label (defaults to type label)
 * @param {string} size - Badge size: 'sm', 'md', 'lg' (default 'md')
 * @param {string} variant - Style variant: 'solid', 'outline', 'subtle' (default 'solid')
 * @param {string} className - Additional CSS classes
 */
export default function EntityBadge({ type, label = null, size = 'md', variant = 'solid', className = '', ...props }) {
	const styles = getEntityStyles(type);
	const displayLabel = label || getEntityLabel(type);

	const sizeClasses = {
		sm: 'text-[9px] px-1.5 py-0.5',
		md: 'text-[10px] px-2 py-0.5',
		lg: 'text-xs px-2.5 py-1',
	};

	const variantClasses = {
		solid: clsx(styles.bg, styles.text, styles.border, 'border'),
		outline: clsx('bg-transparent', styles.text, styles.border, 'border'),
		subtle: clsx(styles.bg, styles.text, 'border-transparent border'),
	};

	return (
		<span
			className={clsx(
				'inline-flex items-center font-bold uppercase tracking-wider rounded shrink-0',
				sizeClasses[size],
				variantClasses[variant],
				className
			)}
			{...props}>
			{displayLabel}
		</span>
	);
}

--- END OF components\entity\EntityBadge.jsx ---

--- FILE: components\entity\EntityIcon.jsx ---
import { clsx } from 'clsx';
import { getEntityIcon, getEntityStyles } from '../../config/entity';

/**
 * EntityIcon Component
 * Renders an entity icon with optional custom image override
 *
 * @param {string} type - Entity type
 * @param {string} customIconUrl - Optional custom icon URL
 * @param {number} size - Icon size in pixels (default 16)
 * @param {string} className - Additional CSS classes
 * @param {boolean} showBackground - Show colored background (default false)
 * @param {boolean} inline - Use span instead of div for inline contexts (default false)
 */
export default function EntityIcon({
	type,
	customIconUrl = null,
	size = 16,
	className = '',
	showBackground = false,
	inline = false,
	...props
}) {
	const Icon = getEntityIcon(type);
	const styles = getEntityStyles(type);

	// Choose container element (span for inline, div for block)
	const Container = inline ? 'span' : 'div';

	// If custom icon provided, render image
	if (customIconUrl) {
		return (
			<Container
				className={clsx(
					'inline-flex items-center justify-center overflow-hidden',
					showBackground && clsx('rounded-lg border', styles.bg, styles.border),
					className
				)}
				style={{ width: size, height: size }}
				{...props}>
				<img
					src={customIconUrl}
					alt=''
					className='w-full h-full object-cover'
					onError={(e) => {
						// Fallback to icon if image fails
						e.target.style.display = 'none';
						e.target.parentElement.classList.add('fallback-icon');
					}}
				/>
			</Container>
		);
	}

	// Default icon rendering
	if (showBackground) {
		return (
			<Container
				className={clsx(
					'inline-flex items-center justify-center rounded-lg border p-1.5',
					styles.bg,
					styles.border,
					styles.text,
					className
				)}
				{...props}>
				<Icon size={size} strokeWidth={2} />
			</Container>
		);
	}

	return <Icon size={size} className={clsx(styles.text, className)} strokeWidth={2} {...props} />;
}

--- END OF components\entity\EntityIcon.jsx ---

--- FILE: components\entity\EntityLink.jsx ---
import { useNavigate } from 'react-router-dom';
import { clsx } from 'clsx';
import { useTooltip } from '../../features/smart-tooltip/TooltipContext';
import { getEntityStyles } from '../../config/entity';
import EntityIcon from './EntityIcon';

/**
 * EntityLink Component
 * Smart navigation link with tooltip support and consistent styling
 *
 * @param {string} id - Entity ID
 * @param {string} type - Entity type
 * @param {string} children - Link text
 * @param {string} customIconUrl - Optional custom icon
 * @param {boolean} showIcon - Show icon before text (default true)
 * @param {string} className - Additional CSS classes
 * @param {boolean} inline - Inline mode (minimal styling, default false)
 */
export default function EntityLink({
	id,
	type,
	children,
	customIconUrl = null,
	showIcon = true,
	className = '',
	inline = false,
	...props
}) {
	const navigate = useNavigate();
	const { openTooltip, closeTooltip } = useTooltip();
	const styles = getEntityStyles(type);

	const handleMouseEnter = (e) => {
		openTooltip(e, id, type);
	};

	const handleClick = (e) => {
		e.preventDefault();

		// Mobile: Open tooltip instead of navigating
		const isMobile = window.matchMedia('(pointer: coarse)').matches || window.innerWidth < 1024;
		if (isMobile) {
			e.stopPropagation();
			openTooltip(e, id, type, true);
		} else {
			navigate(`/wiki/${type}/${id}`);
			closeTooltip();
		}
	};

	// Inline mode: minimal styling for use within text
	if (inline) {
		return (
			<a
				href={`/wiki/${type}/${id}`}
				onClick={handleClick}
				onMouseEnter={handleMouseEnter}
				onMouseLeave={closeTooltip}
				className={clsx(
					'inline-flex items-center gap-1.5 font-semibold no-underline transition-colors',
					'border-b border-dashed border-transparent hover:border-current cursor-pointer align-middle',
					styles.text,
					styles.hover,
					className
				)}
				{...props}>
				{showIcon && (
					<EntityIcon
						type={type}
						customIconUrl={customIconUrl}
						size={14}
						inline={true}
						className='self-center rounded-full'
					/>
				)}
				{children}
			</a>
		);
	}

	// Standard mode: card/button styling
	return (
		<a
			href={`/wiki/${type}/${id}`}
			onClick={handleClick}
			onMouseEnter={handleMouseEnter}
			onMouseLeave={closeTooltip}
			className={clsx(
				'flex items-center gap-2 px-3 py-2 rounded-lg transition-all cursor-pointer',
				'hover:shadow-sm',
				styles.bg,
				styles.hover,
				styles.border,
				'border',
				className
			)}
			{...props}>
			{showIcon && <EntityIcon type={type} customIconUrl={customIconUrl} size={18} inline={false} />}
			<span className={clsx('font-semibold text-sm', styles.text)}>{children}</span>
		</a>
	);
}

--- END OF components\entity\EntityLink.jsx ---

--- FILE: components\entity\EntityStatusIcon.jsx ---
import { clsx } from 'clsx';
import { getStatusIcon } from '../../utils/status/statusHelpers';

/**
 * EntityStatusIcon Component
 * Smart status indicator based on entity type and status/affinity
 *
 * @param {Object} entity - Entity object with type and status/affinity
 * @param {number} size - Icon size (default 12)
 * @param {string} className - Additional CSS classes
 */
export default function EntityStatusIcon({ entity, size = 12, className = '', ...props }) {
	if (!entity) return null;

	// Determine which status to show (affinity takes priority for NPCs/factions)
	const statusValue = entity.affinity || entity.status;
	if (!statusValue || statusValue === 'unknown') return null;

	const { Icon, className: statusClass } = getStatusIcon(statusValue, entity.type);

	return <Icon size={size} className={clsx(statusClass, className)} strokeWidth={2.5} {...props} />;
}

/**
 * EntityStatusBadge Component
 * Status indicator with text label
 *
 * @param {Object} entity - Entity object
 * @param {string} className - Additional CSS classes
 */
export function EntityStatusBadge({ entity, className = '', ...props }) {
	if (!entity) return null;

	const statusValue = entity.affinity || entity.status;
	if (!statusValue || statusValue === 'unknown') return null;

	const { Icon, className: statusClass } = getStatusIcon(statusValue, entity.type);

	return (
		<span
			className={clsx('inline-flex items-center gap-1.5 text-xs font-semibold px-2 py-1 rounded-md border', className)}
			{...props}>
			<Icon size={12} className={statusClass} strokeWidth={2.5} />
			<span className='capitalize'>{statusValue}</span>
		</span>
	);
}

--- END OF components\entity\EntityStatusIcon.jsx ---

--- FILE: components\entity\index.js ---
/**
 * Entity Component Library
 * Reusable components for entity display and interaction
 */

export { default as EntityIcon } from './EntityIcon';
export { default as EntityBadge } from './EntityBadge';
export { default as EntityStatusIcon, EntityStatusBadge } from './EntityStatusIcon';
export { default as EntityLink } from './EntityLink';

--- END OF components\entity\index.js ---

--- FILE: components\layout\CollapsibleSection.jsx ---
import { useState } from 'react';
import { ChevronDown, ChevronRight } from 'lucide-react';
import { clsx } from 'clsx';

/**
 * CollapsibleSection Component
 * Expandable/collapsible content section
 *
 * @param {string} title - Section title
 * @param {React.ReactNode} children - Section content
 * @param {boolean} defaultOpen - Initial state (default true)
 * @param {React.Component} icon - Optional icon component
 * @param {string} size - Title size: 'sm', 'md', 'lg' (default 'md')
 * @param {string} variant - Style variant: 'default', 'bordered', 'card' (default 'default')
 * @param {string} className - Additional classes
 */
export default function CollapsibleSection({
	title,
	children,
	defaultOpen = true,
	icon: Icon = null,
	size = 'md',
	variant = 'default',
	className = '',
	...props
}) {
	const [isOpen, setIsOpen] = useState(defaultOpen);

	const sizeClasses = {
		sm: 'text-xs',
		md: 'text-sm',
		lg: 'text-base',
	};

	const variantClasses = {
		default: '',
		bordered: 'border border-border rounded-lg p-3',
		card: 'bg-background border border-border rounded-lg shadow-sm',
	};

	const headerPadding = variant === 'card' ? 'p-3' : '';
	const contentPadding = variant === 'card' ? 'p-3 pt-0' : '';

	return (
		<div className={clsx(variantClasses[variant], className)} {...props}>
			{/* Header */}
			<button
				onClick={() => setIsOpen(!isOpen)}
				className={clsx(
					'w-full flex items-center gap-2 font-semibold uppercase tracking-wider text-gray-500',
					'hover:text-gray-700 transition-colors select-none',
					sizeClasses[size],
					headerPadding
				)}>
				{isOpen ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
				{Icon && <Icon size={14} className='opacity-70' />}
				<span className='flex-1 text-left truncate'>{title}</span>
			</button>

			{/* Content */}
			{isOpen && <div className={contentPadding}>{children}</div>}
		</div>
	);
}

/**
 * CollapsibleList Component
 * List of collapsible sections with consistent styling
 *
 * @param {Array<{title: string, content: ReactNode, icon?: Component}>} sections - Section definitions
 * @param {string} variant - Style variant (default 'default')
 * @param {string} className - Additional classes
 */
export function CollapsibleList({ sections, variant = 'default', className = '', ...props }) {
	return (
		<div className={clsx('space-y-2', className)} {...props}>
			{sections.map((section, index) => (
				<CollapsibleSection
					key={section.id || index}
					title={section.title}
					icon={section.icon}
					variant={variant}
					defaultOpen={section.defaultOpen !== false}>
					{section.content}
				</CollapsibleSection>
			))}
		</div>
	);
}

--- END OF components\layout\CollapsibleSection.jsx ---

--- FILE: components\layout\index.js ---
/**
 * Layout Component Library
 * Reusable layout patterns and containers
 */

export { default as SplitView, ThreeColumnLayout } from './SplitView';
export { default as TabContainer, TabPanel } from './TabContainer';
export { default as CollapsibleSection, CollapsibleList } from './CollapsibleSection';

--- END OF components\layout\index.js ---

--- FILE: components\layout\SplitView.jsx ---
import { clsx } from 'clsx';

/**
 * SplitView Component
 * Responsive 2-column layout pattern
 *
 * @param {React.ReactNode} sidebar - Sidebar content
 * @param {React.ReactNode} main - Main content
 * @param {string} sidebarPosition - 'left' or 'right' (default 'left')
 * @param {string} sidebarWidth - Sidebar width class (default 'lg:w-64')
 * @param {boolean} stickyHeader - Make sidebar sticky (default false)
 * @param {string} className - Additional container classes
 */
export default function SplitView({
	sidebar,
	main,
	sidebarPosition = 'left',
	sidebarWidth = 'lg:w-64',
	stickyHeader = false,
	className = '',
	...props
}) {
	const sidebarClasses = clsx(
		'min-w-0',
		sidebarWidth,
		stickyHeader && 'lg:sticky lg:top-0 lg:self-start lg:max-h-screen lg:overflow-y-auto'
	);

	const mainClasses = 'flex-1 min-w-0';

	return (
		<div className={clsx('flex flex-col lg:flex-row gap-4 lg:gap-6', className)} {...props}>
			{sidebarPosition === 'left' && <aside className={sidebarClasses}>{sidebar}</aside>}

			<main className={mainClasses}>{main}</main>

			{sidebarPosition === 'right' && <aside className={clsx(sidebarClasses, 'lg:order-2')}>{sidebar}</aside>}
		</div>
	);
}

/**
 * ThreeColumnLayout Component
 * For pages with sidebar, main content, and ToC/meta panel
 *
 * @param {React.ReactNode} left - Left sidebar
 * @param {React.ReactNode} center - Main content
 * @param {React.ReactNode} right - Right panel (ToC, etc.)
 * @param {string} className - Additional container classes
 */
export function ThreeColumnLayout({ left, center, right, className = '', ...props }) {
	return (
		<div
			className={clsx('grid grid-cols-1 xl:grid-cols-[1fr_48rem_1fr] gap-6 max-w-[1920px] mx-auto', className)}
			{...props}>
			{/* Left Gutter (Hidden on smaller screens) */}
			<div className='hidden xl:block' aria-hidden='true'>
				{left}
			</div>

			{/* Center Content */}
			<div className='min-w-0'>{center}</div>

			{/* Right Panel */}
			<div className='hidden xl:block'>{right}</div>
		</div>
	);
}

--- END OF components\layout\SplitView.jsx ---

--- FILE: components\layout\TabContainer.jsx ---
import { useState } from 'react';
import { clsx } from 'clsx';

/**
 * TabButton Component
 * Individual tab button
 */
function TabButton({ active, label, onClick, icon: Icon }) {
	return (
		<button
			onClick={onClick}
			className={clsx(
				'px-4 py-2 text-sm font-medium transition-all border-b-2 cursor-pointer',
				active
					? 'border-amber-600 text-amber-600 bg-amber-50/30'
					: 'border-transparent text-gray-500 hover:text-gray-700 hover:bg-gray-50'
			)}>
			<span className='flex items-center gap-2'>
				{Icon && <Icon size={14} />}
				{label}
			</span>
		</button>
	);
}

/**
 * TabContainer Component
 * Reusable tab navigation system
 *
 * @param {Array<{id: string, label: string, icon?: Component, content: ReactNode}>} tabs - Tab definitions
 * @param {string} defaultTab - Default active tab ID
 * @param {string} className - Additional container classes
 * @param {boolean} sticky - Make tab bar sticky (default true)
 * @param {Function} onChange - Callback when tab changes
 */
export default function TabContainer({
	tabs,
	defaultTab = null,
	className = '',
	sticky = true,
	onChange = null,
	...props
}) {
	const [activeTab, setActiveTab] = useState(defaultTab || tabs[0]?.id);

	const handleTabChange = (tabId) => {
		setActiveTab(tabId);
		if (onChange) onChange(tabId);
	};

	const activeTabContent = tabs.find((t) => t.id === activeTab)?.content;

	return (
		<div className={clsx('flex flex-col', className)} {...props}>
			{/* Tab Bar */}
			<div
				className={clsx(
					'bg-background/95 backdrop-blur shadow-sm border-b border-border z-20',
					sticky && 'sticky top-0'
				)}>
				<div className='max-w-screen-2xl mx-auto px-6 flex justify-center'>
					{tabs.map((tab) => (
						<TabButton
							key={tab.id}
							active={activeTab === tab.id}
							label={tab.label}
							icon={tab.icon}
							onClick={() => handleTabChange(tab.id)}
						/>
					))}
				</div>
			</div>

			{/* Tab Content */}
			<div className='flex-1 min-h-0'>{activeTabContent}</div>
		</div>
	);
}

/**
 * TabPanel Component
 * Wrapper for individual tab content
 *
 * @param {React.ReactNode} children - Panel content
 * @param {string} className - Additional classes
 */
export function TabPanel({ children, className = '', ...props }) {
	return (
		<div className={clsx('p-6', className)} {...props}>
			{children}
		</div>
	);
}

--- END OF components\layout\TabContainer.jsx ---

--- FILE: components\markdown\index.js ---
/**
 * Markdown Component Library
 * Pre-configured markdown renderers
 */

export { default as MarkdownRenderer, InlineMarkdown } from './MarkdownRenderer';
export { default as MarkdownWithToC } from './MarkdownWithToC';

--- END OF components\markdown\index.js ---

--- FILE: components\markdown\MarkdownRenderer.jsx ---
import ReactMarkdown from 'react-markdown';
import { generateId, extractText } from '../../utils/text/textProcessing';

/**
 * HeadingRenderer Component
 * Automatically adds IDs to headings for anchor links
 */
function HeadingRenderer({ level, children }) {
	const text = extractText(children);
	const id = generateId(text);
	const Tag = `h${level}`;
	return <Tag id={id}>{children}</Tag>;
}

/**
 * MarkdownRenderer Component
 * Pre-configured ReactMarkdown with sensible defaults
 *
 * @param {string} children - Markdown text
 * @param {Object} components - Custom component overrides
 * @param {boolean} addHeadingIds - Auto-generate heading IDs (default true)
 * @param {string} className - Additional CSS classes
 */
export default function MarkdownRenderer({
	children,
	components = {},
	addHeadingIds = true,
	className = '',
	...props
}) {
	// Safety check
	let safeText = children;
	if (Array.isArray(children)) {
		safeText = children.join('');
	} else if (typeof children !== 'string' && children !== null && children !== undefined) {
		safeText = String(children);
	}

	// Build component overrides
	const defaultComponents = {
		// Auto-add IDs to headings
		...(addHeadingIds && {
			h1: (props) => <HeadingRenderer level={1} {...props} />,
			h2: (props) => <HeadingRenderer level={2} {...props} />,
			h3: (props) => <HeadingRenderer level={3} {...props} />,
		}),
		// External links open in new tab
		a: ({ href, children }) => {
			if (href && !href.startsWith('#') && !href.startsWith('/')) {
				return (
					<a href={href} target='_blank' rel='noopener noreferrer'>
						{children}
					</a>
				);
			}
			return <a href={href}>{children}</a>;
		},
	};

	return (
		<ReactMarkdown className={className} components={{ ...defaultComponents, ...components }} {...props}>
			{safeText}
		</ReactMarkdown>
	);
}

/**
 * InlineMarkdown Component
 * For rendering markdown inside inline contexts (no block elements)
 *
 * @param {string} children - Markdown text
 */
export function InlineMarkdown({ children, ...props }) {
	return (
		<MarkdownRenderer
			components={{
				p: 'span',
				h1: 'strong',
				h2: 'strong',
				h3: 'strong',
				ul: 'span',
				ol: 'span',
				li: 'span',
			}}
			addHeadingIds={false}
			{...props}>
			{children}
		</MarkdownRenderer>
	);
}

--- END OF components\markdown\MarkdownRenderer.jsx ---

--- FILE: components\markdown\MarkdownWithToC.jsx ---
import { useMemo } from 'react';
import { extractHeaders } from '../../utils/text/markdownHelpers';
import { TableOfContents } from '../../features/table-of-contents/TableOfContents';
import MarkdownRenderer from './MarkdownRenderer';

/**
 * MarkdownWithToC Component
 * Renders markdown with automatic Table of Contents generation
 *
 * @param {string} children - Markdown text
 * @param {boolean} showToC - Show table of contents (default true)
 * @param {number} tocMaxDepth - Maximum heading depth for ToC (default 3)
 * @param {string} layout - Layout mode: 'split' or 'top' (default 'split')
 * @param {string} className - Additional classes for markdown container
 */
export default function MarkdownWithToC({
	children,
	showToC = true,
	tocMaxDepth = 3,
	layout = 'split',
	className = '',
	components = {},
	...props
}) {
	// Extract headers for ToC
	const tocItems = useMemo(() => {
		if (!showToC || !children) return [];
		const headers = extractHeaders(children);
		return headers.filter((h) => h.depth <= tocMaxDepth);
	}, [children, showToC, tocMaxDepth]);

	// No ToC needed
	if (!showToC || tocItems.length === 0) {
		return (
			<MarkdownRenderer className={className} components={components} {...props}>
				{children}
			</MarkdownRenderer>
		);
	}

	// Top layout: ToC above content
	if (layout === 'top') {
		return (
			<div>
				<div className='mb-6'>
					<TableOfContents items={tocItems} />
				</div>
				<MarkdownRenderer className={className} components={components} {...props}>
					{children}
				</MarkdownRenderer>
			</div>
		);
	}

	// Split layout: ToC on side
	return (
		<div className='grid grid-cols-1 xl:grid-cols-[1fr_240px] gap-8'>
			{/* Content */}
			<div className='min-w-0'>
				<MarkdownRenderer className={className} components={components} {...props}>
					{children}
				</MarkdownRenderer>
			</div>

			{/* ToC Sidebar */}
			<div className='hidden xl:block'>
				<TableOfContents items={tocItems} />
			</div>

			{/* Mobile ToC */}
			<div className='xl:hidden'>
				<TableOfContents items={tocItems} />
			</div>
		</div>
	);
}

--- END OF components\markdown\MarkdownWithToC.jsx ---

--- FILE: components\ui\Button.jsx ---
import { clsx } from 'clsx';

export default function Button({
	children,
	variant = 'primary',
	size = 'md',
	icon: Icon,
	fullWidth = false,
	disabled = false,
	className,
	...props
}) {
	const baseStyles =
		'inline-flex items-center justify-center gap-2 font-medium rounded-lg transition-all focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed';

	const variants = {
		primary: 'bg-amber-600 text-white hover:bg-amber-700 focus:ring-amber-500',
		secondary: 'bg-gray-100 text-foreground hover:bg-gray-200 focus:ring-gray-500',
		ghost: 'bg-transparent text-gray-700 hover:bg-gray-100 focus:ring-gray-500',
		danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500',
	};

	const sizes = {
		sm: 'px-3 py-1.5 text-sm',
		md: 'px-4 py-2 text-sm',
		lg: 'px-6 py-3 text-base',
	};

	return (
		<button
			className={clsx(baseStyles, variants[variant], sizes[size], fullWidth && 'w-full', className)}
			disabled={disabled}
			{...props}>
			{Icon && <Icon size={16} />}
			{children}
		</button>
	);
}

--- END OF components\ui\Button.jsx ---

--- FILE: components\ui\Card.jsx ---
import { clsx } from 'clsx';

export function Card({ children, className, padding = true, hover = false, ...props }) {
	return (
		<div
			className={clsx(
				'bg-[var(--card-bg)] border border-border rounded-lg shadow-sm',
				padding && 'p-4',
				hover && 'transition-shadow hover:shadow-md',
				className
			)}
			{...props}>
			{children}
		</div>
	);
}

export function CardHeader({ children, className }) {
	return <div className={clsx('border-b border-border pb-3 mb-3', className)}>{children}</div>;
}

export function CardTitle({ children, className }) {
	return <h3 className={clsx('text-lg font-serif font-semibold text-foreground', className)}>{children}</h3>;
}

export function CardContent({ children, className }) {
	return <div className={className}>{children}</div>;
}

--- END OF components\ui\Card.jsx ---

--- FILE: components\ui\DevAdminButton.jsx ---
import React from 'react';
import { Link } from 'react-router-dom';
import { Database, Wrench } from 'lucide-react';

export default function DevAdminButton() {
	// CRITICAL: This ensures it never renders in Production (GitHub Pages)
	if (!import.meta.env.DEV) return null;

	return (
		<Link
			to='/dm'
			className='fixed bottom-6 right-6 z-50 flex items-center gap-2 px-4 py-1 bg-muted  rounded-full shadow-xl hover:bg-background hover:scale-105 transition-all border border-stone-300'
			title='Open DM Console (Dev Mode Only)'>
			<Wrench size={14} />
			<span className='hidden md:inline'>Dev</span>
		</Link>
	);
}

--- END OF components\ui\DevAdminButton.jsx ---

--- FILE: components\ui\Drawer.jsx ---
import { createPortal } from 'react-dom';
import { X } from 'lucide-react';
import { clsx } from 'clsx';
import { useEffect, useState } from 'react';

/**
 * Reusable Mobile Drawer
 */
export const Drawer = ({ isOpen, onClose, title, children, position = 'right', className }) => {
	const [isVisible, setIsVisible] = useState(false);

	useEffect(() => {
		if (isOpen) setIsVisible(true);
		else setTimeout(() => setIsVisible(false), 300);
	}, [isOpen]);

	if (!isVisible && !isOpen) return null;

	const positionClasses = {
		right: 'right-0 top-0 bottom-0 border-l slide-in-from-right',
		left: 'left-0 top-0 bottom-0 border-r slide-in-from-left',
	};

	return createPortal(
		<div className='fixed inset-0 z-[9999] isolate'>
			{/* Backdrop */}
			<div
				className={clsx(
					'absolute inset-0 bg-black/20 backdrop-blur-[2px] transition-opacity duration-300',
					isOpen ? 'opacity-100' : 'opacity-0'
				)}
				onClick={onClose}
			/>

			{/* Panel */}
			<div
				className={clsx(
					'absolute w-80 bg-background shadow-2xl border-border flex flex-col transition-transform duration-300',
					positionClasses[position],
					isOpen ? 'translate-x-0' : position === 'right' ? 'translate-x-full' : '-translate-x-full',
					className
				)}>
				{/* Header */}
				<div className='p-4 border-b border-border flex items-center justify-between bg-muted shrink-0'>
					<span className='text-sm font-serif font-bold text-foreground'>{title}</span>
					<button onClick={onClose} className='p-2 hover:bg-background/50 rounded-full transition-colors'>
						<X size={18} />
					</button>
				</div>

				{/* Content - No background, let children control */}
				<div className='flex-1 overflow-y-auto custom-scrollbar'>{children}</div>
			</div>
		</div>,
		document.body
	);
};

--- END OF components\ui\Drawer.jsx ---

--- FILE: components\ui\EmptyState.jsx ---
import { clsx } from 'clsx';

export default function EmptyState({ icon: Icon, title, description, action, className }) {
	return (
		<div className={clsx('flex flex-col items-center justify-center p-8 text-center', className)}>
			{Icon && (
				<div className='mb-4 rounded-full bg-gray-100 p-4'>
					<Icon className='w-8 h-8 text-gray-400' strokeWidth={1.5} />
				</div>
			)}
			{title && <h3 className='text-lg font-serif font-semibold text-foreground mb-2'>{title}</h3>}
			{description && <p className='text-sm text-gray-500 max-w-sm mb-6'>{description}</p>}
			{action && <div>{action}</div>}
		</div>
	);
}

--- END OF components\ui\EmptyState.jsx ---

--- FILE: components\ui\LoadingSpinner.jsx ---
import { Loader2 } from 'lucide-react';
import { clsx } from 'clsx';

export default function LoadingSpinner({ size = 'md', text = 'Loading...', className }) {
	const sizes = {
		sm: 'w-4 h-4',
		md: 'w-8 h-8',
		lg: 'w-12 h-12',
	};

	return (
		<div className={clsx('flex flex-col items-center justify-center gap-3', className)}>
			<Loader2 className={clsx(sizes[size], 'animate-spin text-amber-600')} />
			{text && <p className='text-sm text-gray-500 font-medium'>{text}</p>}
		</div>
	);
}

--- END OF components\ui\LoadingSpinner.jsx ---

--- FILE: components\ui\SectionDivider.jsx ---
import { Diamond } from 'lucide-react';

export const SectionDivider = () => (
	<div className='flex items-center gap-4 my-6 opacity-80 select-none'>
		<div className='h-px bg-border flex-1' />
		<div className='flex-shrink-0 text-accent/50'>
			<Diamond size={10} fill='currentColor' />
		</div>
		<div className='h-px bg-border flex-1' />
	</div>
);

--- END OF components\ui\SectionDivider.jsx ---

--- FILE: config\entity\colors.js ---
/**
 * Entity Color Palettes
 * Hex colors for each entity type
 */

import { ENTITY_TYPES } from './types';

/**
 * Primary color for each entity type (hex)
 */
export const ENTITY_COLORS = {
	[ENTITY_TYPES.SESSION]: '#64748b', // slate-500
	[ENTITY_TYPES.CHARACTER]: '#ef4444', // red-500
	[ENTITY_TYPES.NPC]: '#d97706', // amber-600
	[ENTITY_TYPES.LOCATION]: '#10b981', // emerald-500
	[ENTITY_TYPES.QUEST]: '#3b82f6', // blue-500
	[ENTITY_TYPES.FACTION]: '#a855f7', // purple-500
	[ENTITY_TYPES.ENCOUNTER]: '#f97316', // orange-500
	[ENTITY_TYPES.DEFAULT]: '#6b7280', // gray-500
};

/**
 * Get primary color for entity type
 * @param {string} type - Entity type
 * @returns {string} Hex color
 */
export const getEntityColor = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	return ENTITY_COLORS[normalized] || ENTITY_COLORS[ENTITY_TYPES.DEFAULT];
};

/**
 * Extended color palette for each type (for future use)
 * Includes lighter/darker shades
 */
export const ENTITY_COLOR_PALETTES = {
	[ENTITY_TYPES.SESSION]: {
		50: '#f8fafc',
		100: '#f1f5f9',
		500: '#64748b',
		700: '#334155',
		900: '#0f172a',
	},
	[ENTITY_TYPES.CHARACTER]: {
		50: '#fef2f2',
		100: '#fee2e2',
		500: '#ef4444',
		700: '#b91c1c',
		900: '#7f1d1d',
	},
	[ENTITY_TYPES.NPC]: {
		50: '#fffbeb',
		100: '#fef3c7',
		500: '#d97706',
		700: '#a16207',
		900: '#78350f',
	},
	[ENTITY_TYPES.LOCATION]: {
		50: '#ecfdf5',
		100: '#d1fae5',
		500: '#10b981',
		700: '#047857',
		900: '#064e3b',
	},
	[ENTITY_TYPES.QUEST]: {
		50: '#eff6ff',
		100: '#dbeafe',
		500: '#3b82f6',
		700: '#1d4ed8',
		900: '#1e3a8a',
	},
	[ENTITY_TYPES.FACTION]: {
		50: '#faf5ff',
		100: '#f3e8ff',
		500: '#a855f7',
		700: '#7e22ce',
		900: '#581c87',
	},
	[ENTITY_TYPES.ENCOUNTER]: {
		50: '#fff7ed',
		100: '#ffedd5',
		500: '#f97316',
		700: '#c2410c',
		900: '#7c2d12',
	},
	[ENTITY_TYPES.DEFAULT]: {
		50: '#f9fafb',
		100: '#f3f4f6',
		500: '#6b7280',
		700: '#374151',
		900: '#111827',
	},
};

/**
 * Get color palette for entity type
 * @param {string} type - Entity type
 * @returns {Object} Color palette
 */
export const getEntityPalette = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	return ENTITY_COLOR_PALETTES[normalized] || ENTITY_COLOR_PALETTES[ENTITY_TYPES.DEFAULT];
};

--- END OF config\entity\colors.js ---

--- FILE: config\entity\entityConfig.js ---
/**
 * Entity Configuration Orchestrator
 * Combines all entity config modules into a unified API
 * This replaces the old monolithic entityConfig.jsx
 */

import { ENTITY_TYPES, getEntityLabel } from './types';
import { getEntityIcon } from './icons';
import { getEntityColor, getEntityPalette } from './colors';
import { getEntityStyles, getEntityPreset, buildEntityClassName } from './styles';

/**
 * Get complete configuration for an entity type
 * @param {string} type - Entity type
 * @returns {Object} Complete entity config
 */
export const getEntityConfig = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;

	return {
		type: normalized,
		label: getEntityLabel(normalized),
		labelPlural: getEntityLabel(normalized, true),
		icon: getEntityIcon(normalized),
		color: getEntityColor(normalized),
		palette: getEntityPalette(normalized),
		tailwind: getEntityStyles(normalized),
	};
};

/**
 * LEGACY EXPORT: Full config map for backwards compatibility
 * TODO: Gradually migrate consumers to use getEntityConfig() instead
 */
export const ENTITY_CONFIG = Object.values(ENTITY_TYPES).reduce((acc, type) => {
	acc[type] = getEntityConfig(type);
	return acc;
}, {});

// Re-export everything for convenience
export { ENTITY_TYPES, getEntityLabel } from './types';
export { getEntityIcon } from './icons';
export { getEntityColor, getEntityPalette } from './colors';
export { getEntityStyles, getEntityPreset, buildEntityClassName } from './styles';

--- END OF config\entity\entityConfig.js ---

--- FILE: config\entity\icons.js ---
import {
	User,
	MapPin,
	Scroll,
	Sword,
	Flag,
	Crown,
	BookOpen,
	Calendar,
	Trees,
	Castle,
	Ship,
	Landmark,
	Globe,
	Home,
	Mountain,
} from 'lucide-react';
import { ENTITY_TYPES } from './types';
import { getAttributeValue } from '../../utils/entity/attributeParser';

export const ENTITY_ICONS = {
	[ENTITY_TYPES.SESSION]: Calendar,
	[ENTITY_TYPES.CHARACTER]: User,
	[ENTITY_TYPES.NPC]: Crown,
	[ENTITY_TYPES.LOCATION]: MapPin,
	[ENTITY_TYPES.QUEST]: Scroll,
	[ENTITY_TYPES.FACTION]: Flag,
	[ENTITY_TYPES.ENCOUNTER]: Sword,
	[ENTITY_TYPES.DEFAULT]: BookOpen,
};

// Location specific mappings
const LOCATION_TYPE_ICONS = {
	building: Home,
	ship: Ship,
	landmark: Landmark,
	dungeon: Mountain,
	cave: Mountain,
	region: MapPin,
	city: Castle,
	forest: Trees,
	realm: Globe,
};

export const getEntityIcon = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	return ENTITY_ICONS[normalized] || ENTITY_ICONS[ENTITY_TYPES.DEFAULT];
};

/**
 * Advanced resolution that looks at attributes for finer detail
 */
export const resolveEntityIcon = (entity) => {
	const type = entity.type?.toLowerCase();

	if (type === 'location') {
		const locType = getAttributeValue(entity.attributes, 'type')?.toLowerCase();
		return LOCATION_TYPE_ICONS[locType] || ENTITY_ICONS.location;
	}

	return getEntityIcon(type);
};

--- END OF config\entity\icons.js ---

--- FILE: config\entity\index.js ---
/**
 * Entity Configuration Module
 * Centralized export for all entity-related config
 */

// Main API
export { getEntityConfig, ENTITY_CONFIG } from './entityConfig';

// Types
export { ENTITY_TYPES, ENTITY_LABELS, ENTITY_LABELS_PLURAL, getEntityLabel } from './types';

// Icons
export { ENTITY_ICONS, getEntityIcon } from './icons';

// Colors
export { ENTITY_COLORS, ENTITY_COLOR_PALETTES, getEntityColor, getEntityPalette } from './colors';

// Styles
export { getEntityStyles, getEntityPreset, buildEntityClassName, ENTITY_CLASS_PRESETS } from './styles';

--- END OF config\entity\index.js ---

--- FILE: config\entity\styles.js ---
/**
 * Entity Tailwind Style Builders
 * Generate Tailwind class strings for each entity type
 */

import { ENTITY_TYPES } from './types';

/**
 * Tailwind class maps for each entity type
 */
const ENTITY_TAILWIND_CLASSES = {
	[ENTITY_TYPES.SESSION]: {
		text: 'text-slate-700',
		bg: 'bg-slate-50',
		border: 'border-slate-500',
		hover: 'hover:bg-slate-100',
	},
	[ENTITY_TYPES.CHARACTER]: {
		text: 'text-red-700',
		bg: 'bg-red-50',
		border: 'border-red-300',
		hover: 'hover:bg-red-50',
	},
	[ENTITY_TYPES.NPC]: {
		text: 'text-amber-700',
		bg: 'bg-amber-50',
		border: 'border-amber-300',
		hover: 'hover:bg-amber-50',
	},
	[ENTITY_TYPES.LOCATION]: {
		text: 'text-emerald-700',
		bg: 'bg-emerald-50',
		border: 'border-emerald-300',
		hover: 'hover:bg-emerald-50',
	},
	[ENTITY_TYPES.QUEST]: {
		text: 'text-blue-700',
		bg: 'bg-blue-50',
		border: 'border-blue-300',
		hover: 'hover:bg-blue-50',
	},
	[ENTITY_TYPES.FACTION]: {
		text: 'text-purple-700',
		bg: 'bg-purple-50',
		border: 'border-purple-300',
		hover: 'hover:bg-purple-50',
	},
	[ENTITY_TYPES.ENCOUNTER]: {
		text: 'text-orange-700',
		bg: 'bg-orange-50',
		border: 'border-orange-300',
		hover: 'hover:bg-orange-50',
	},
	[ENTITY_TYPES.DEFAULT]: {
		text: 'text-gray-700',
		bg: 'bg-muted',
		border: 'border-gray-400',
		hover: 'hover:bg-gray-100',
	},
};

/**
 * Get Tailwind classes for entity type
 * @param {string} type - Entity type
 * @returns {Object} Tailwind class object
 */
export const getEntityStyles = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	return ENTITY_TAILWIND_CLASSES[normalized] || ENTITY_TAILWIND_CLASSES[ENTITY_TYPES.DEFAULT];
};

/**
 * Build a complete className string for an entity
 * @param {string} type - Entity type
 * @param {string|string[]} variants - Style variants to include (e.g., 'text', 'bg', 'border')
 * @param {string} additional - Additional classes to append
 * @returns {string} Complete className string
 */
export const buildEntityClassName = (type, variants = [], additional = '') => {
	const styles = getEntityStyles(type);

	// Normalize variants to array
	const variantList = Array.isArray(variants) ? variants : [variants];

	// Build class string
	const classes = variantList
		.map((variant) => styles[variant])
		.filter(Boolean)
		.join(' ');

	return additional ? `${classes} ${additional}` : classes;
};

/**
 * Pre-built utility class sets for common patterns
 */
export const ENTITY_CLASS_PRESETS = {
	/**
	 * Icon badge (small colored circle with icon)
	 */
	iconBadge: (type) => {
		const styles = getEntityStyles(type);
		return `${styles.bg} ${styles.border} ${styles.text} rounded-lg p-2 border`;
	},

	/**
	 * Type badge (uppercase label)
	 */
	typeBadge: (type) => {
		const styles = getEntityStyles(type);
		return `${styles.bg} ${styles.text} ${styles.border} text-xs font-bold uppercase tracking-wider px-2 py-0.5 rounded border`;
	},

	/**
	 * Card container
	 */
	card: (type) => {
		const styles = getEntityStyles(type);
		return `${styles.bg} ${styles.border} border rounded-lg p-4 ${styles.hover} transition-colors`;
	},

	/**
	 * Link styling
	 */
	link: (type) => {
		const styles = getEntityStyles(type);
		return `${styles.text} ${styles.hover} transition-colors font-semibold`;
	},
};

/**
 * Get preset class string
 * @param {string} preset - Preset name
 * @param {string} type - Entity type
 * @returns {string} Complete className string
 */
export const getEntityPreset = (preset, type) => {
	const presetFn = ENTITY_CLASS_PRESETS[preset];
	return presetFn ? presetFn(type) : '';
};

export const getPriorityStyles = (priority) => {
	const p = priority?.toLowerCase() || '';
	if (p.includes('high') || p.includes('urgent') || p.includes('critical')) {
		return 'border-orange-200 text-orange-800 bg-orange-50';
	}
	if (p.includes('medium') || p.includes('normal')) {
		return 'border-blue-200 text-blue-800 bg-blue-50';
	}
	if (p.includes('low')) {
		return 'border-slate-200 text-slate-700 bg-slate-50';
	}
	return 'border-stone-200 text-stone-700 bg-stone-50';
};

--- END OF config\entity\styles.js ---

--- FILE: config\entity\types.js ---
/**
 * Entity Type Definitions
 * Central source of truth for entity types
 */

/**
 * All valid entity types in the system
 */
export const ENTITY_TYPES = {
	SESSION: 'session',
	CHARACTER: 'character',
	NPC: 'npc',
	LOCATION: 'location',
	QUEST: 'quest',
	FACTION: 'faction',
	ENCOUNTER: 'encounter',
	DEFAULT: 'default',
};

/**
 * Entity type labels (for display)
 */
export const ENTITY_LABELS = {
	[ENTITY_TYPES.SESSION]: 'Session',
	[ENTITY_TYPES.CHARACTER]: 'Character',
	[ENTITY_TYPES.NPC]: 'NPC',
	[ENTITY_TYPES.LOCATION]: 'Location',
	[ENTITY_TYPES.QUEST]: 'Quest',
	[ENTITY_TYPES.FACTION]: 'Faction',
	[ENTITY_TYPES.ENCOUNTER]: 'Encounter',
	[ENTITY_TYPES.DEFAULT]: 'Entity',
};

/**
 * Pluralized entity labels (for navigation, headers)
 */
export const ENTITY_LABELS_PLURAL = {
	[ENTITY_TYPES.SESSION]: 'Sessions',
	[ENTITY_TYPES.CHARACTER]: 'Characters',
	[ENTITY_TYPES.NPC]: 'NPCs',
	[ENTITY_TYPES.LOCATION]: 'Locations',
	[ENTITY_TYPES.QUEST]: 'Quests',
	[ENTITY_TYPES.FACTION]: 'Factions',
	[ENTITY_TYPES.ENCOUNTER]: 'Encounters',
	[ENTITY_TYPES.DEFAULT]: 'Entities',
};

/**
 * Get label for entity type
 * @param {string} type - Entity type
 * @param {boolean} plural - Return plural form
 * @returns {string}
 */
export const getEntityLabel = (type, plural = false) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	const labels = plural ? ENTITY_LABELS_PLURAL : ENTITY_LABELS;
	return labels[normalized] || labels[ENTITY_TYPES.DEFAULT];
};

--- END OF config\entity\types.js ---

--- FILE: features\admin-console\components\AdminForm.jsx ---
import React, { useEffect, useState } from 'react';
import { useForm, useFieldArray } from 'react-hook-form'; // Added useFieldArray
import { getStrategy } from '../config/strategies';
import { useCampaign } from '../../campaign-session/CampaignContext';
import { createEntity, fetchRawEntity, updateEntity } from '../../../services/admin';
import Button from '../../../components/ui/Button';
import { Save, RotateCcw, ExternalLink, Plus, Trash2 } from 'lucide-react';
import { Link } from 'react-router-dom';
import { INPUT_CLASS, LABEL_CLASS, SECTION_CLASS, HEADER_CLASS } from './ui/FormStyles';

// Inputs
import MarkdownEditor from './MarkdownEditor';
import SmartImageInput from './SmartImageInput';

// Sub-managers
import SessionEventManager from './SessionEventManager';
import QuestObjectiveManager from './QuestObjectiveManager';
import RelationshipManager from './RelationshipManager';

export default function AdminForm({ type, id }) {
	const strategy = getStrategy(type);
	const { campaignId } = useCampaign();
	const [isLoading, setIsLoading] = useState(false);
	const [isSaving, setIsSaving] = useState(false);

	// Setup Form with Field Array for custom attributes
	const {
		register,
		control,
		handleSubmit,
		reset,
		watch,
		setValue,
		formState: { errors },
	} = useForm({
		defaultValues: {
			attributes: {},
			customAttributes: [], // Array container for dynamic fields
		},
	});

	// Handle the dynamic list of custom attributes
	const { fields, append, remove } = useFieldArray({
		control,
		name: 'customAttributes',
	});

	// 1. LOAD DATA
	useEffect(() => {
		const loadEntity = async () => {
			if (!id) {
				reset({ attributes: {}, customAttributes: [] });
				return;
			}

			setIsLoading(true);
			try {
				const rawData = await fetchRawEntity(type, id);

				const definedKeys = strategy.defaultAttributes.map((a) => a.key);
				const standardAttrs = {};
				const customAttrs = [];

				// Iterate over the LIST, not an object
				(rawData.attributesList || []).forEach((attr) => {
					const key = attr.name;
					const value = attr.value;

					if (definedKeys.includes(key)) {
						// Standard attributes assume single value.
						// If DB has multiple "race" rows, first one wins for the UI input.
						if (!standardAttrs[key]) {
							standardAttrs[key] = value;
						} else {
							// Edge case: If duplicate standard keys exist, push extras to custom
							customAttrs.push({ key, value });
						}
					} else {
						// All non-standard attributes go here, preserving duplicates
						customAttrs.push({ key, value });
					}
				});

				reset({
					...rawData,
					attributes: standardAttrs,
					customAttributes: customAttrs,
				});
			} catch (err) {
				console.error(err);
				alert('Error loading entity.');
			} finally {
				setIsLoading(false);
			}
		};
		loadEntity();
	}, [type, id, reset, strategy]);

	// 2. SAVE HANDLER
	const onSubmit = async (data) => {
		if (!campaignId && type !== 'campaign') {
			alert('No Campaign Selected! Select one from the home screen first.');
			return;
		}

		// Flatten everything into a single list for the Service
		const attributesList = [];

		// 1. Add Standard Attributes
		Object.entries(data.attributes).forEach(([key, value]) => {
			if (value && String(value).trim() !== '') {
				attributesList.push({ name: key, value });
			}
		});

		// 2. Add Custom Attributes (Allowing duplicates)
		data.customAttributes.forEach((item) => {
			if (item.key && item.key.trim() !== '') {
				attributesList.push({ name: item.key, value: item.value });
			}
		});

		const payload = {
			...data,
			attributesList, // Send the array, not the object
		};

		// Cleanup internal form state
		delete payload.attributes;
		delete payload.customAttributes;

		setIsSaving(true);
		try {
			if (id) {
				await updateEntity(type, id, payload);
			} else {
				await createEntity(type, { ...payload, campaign_id: campaignId });
				if (!id) reset();
			}
		} catch (error) {
			alert(`Error: ${error.message}`);
		} finally {
			setIsSaving(false);
		}
	};

	if (isLoading) return <div className='p-8 text-center text-muted-foreground text-sm'>Loading editor...</div>;

	return (
		<form onSubmit={handleSubmit(onSubmit)} className='space-y-5 animate-in slide-in-from-bottom-2 duration-300 pb-20'>
			{/* --- TOP BAR --- */}
			<div className='flex items-center justify-between bg-background border border-border p-3 rounded-lg shadow-sm sticky top-0 z-20 backdrop-blur-md bg-background/80'>
				<div className='flex items-center gap-2'>
					<span className={`w-2 h-2 rounded-full ${id ? 'bg-amber-500' : 'bg-emerald-500'}`} />
					<span className='text-xs font-bold uppercase tracking-wider text-muted-foreground'>
						{id ? 'Edit Mode' : 'Create Mode'}
					</span>
				</div>
				<div className='flex gap-2'>
					{id && (
						<Link
							to={`/wiki/${type}/${id}`}
							target='_blank'
							className='flex items-center gap-1 px-3 py-1.5 text-xs font-medium text-amber-700 bg-amber-50 hover:bg-amber-100 border border-amber-200 rounded-md transition-colors'>
							<ExternalLink size={14} /> View Live
						</Link>
					)}
					<Button type='button' variant='secondary' size='sm' icon={RotateCcw} onClick={() => reset()}>
						Reset
					</Button>
					<Button type='submit' variant='primary' size='sm' icon={Save} disabled={isSaving}>
						{isSaving ? 'Saving...' : 'Save Changes'}
					</Button>
				</div>
			</div>

			{/* --- CORE DETAILS --- */}
			<div className={SECTION_CLASS}>
				<h2 className={HEADER_CLASS}>Core Details</h2>
				<div className='grid grid-cols-1 gap-4'>
					<div>
						<label className={LABEL_CLASS}>Name / Title</label>
						<input
							type='text'
							{...register('name', { required: true })}
							className={INPUT_CLASS}
							placeholder='Entity Name...'
						/>
						{errors.name && <span className='text-xs text-red-500 mt-1'>Required</span>}
					</div>

					{strategy.hasNarrative && (
						<div>
							<MarkdownEditor
								label='Description / Narrative'
								rows={8}
								value={watch('description') || ''}
								onChange={(e) => setValue('description', e.target.value)}
								placeholder='Write description using Markdown...'
							/>
						</div>
					)}
				</div>
			</div>

			{/* --- STANDARD ATTRIBUTES --- */}
			<div className={SECTION_CLASS}>
				<h2 className={HEADER_CLASS}>{strategy.label} Attributes</h2>

				<div className='grid grid-cols-1 md:grid-cols-2 gap-4'>
					{strategy.defaultAttributes.map((attr) => (
						<div key={attr.key}>
							<label className={LABEL_CLASS}>{attr.label}</label>

							{/* RENDER LOGIC: Check type explicitly to avoid duplication */}
							{attr.type === 'image' ? (
								<SmartImageInput
									value={watch(`attributes.${attr.key}`)}
									onChange={(e) => setValue(`attributes.${attr.key}`, e.target.value)}
									placeholder='images/...'
								/>
							) : attr.type === 'select' ? (
								<select {...register(`attributes.${attr.key}`)} className={INPUT_CLASS}>
									<option value=''>Select...</option>
									{attr.options.map((opt) => (
										<option key={opt} value={opt}>
											{opt}
										</option>
									))}
								</select>
							) : (
								<input
									type={attr.type === 'number' ? 'number' : 'text'}
									{...register(`attributes.${attr.key}`)}
									className={INPUT_CLASS}
								/>
							)}
						</div>
					))}
				</div>
			</div>

			{/* --- CUSTOM ATTRIBUTES (Dynamic) --- */}
			<div className={SECTION_CLASS}>
				<div className={HEADER_CLASS}>
					<span>Custom Attributes</span>
					<Button
						type='button'
						onClick={() => append({ key: '', value: '' })}
						size='sm'
						variant='secondary'
						icon={Plus}>
						Add New
					</Button>
				</div>

				<div className='space-y-2'>
					{fields.map((field, index) => (
						<div key={field.id} className='flex gap-3 items-start animate-in fade-in'>
							<div className='w-1/3'>
								<input
									type='text'
									{...register(`customAttributes.${index}.key`)}
									placeholder='Key (e.g. SecretIdentity)'
									className={`${INPUT_CLASS} font-bold text-muted-foreground`}
								/>
							</div>
							<div className='flex-1'>
								<input
									type='text'
									{...register(`customAttributes.${index}.value`)}
									placeholder='Value'
									className={INPUT_CLASS}
								/>
							</div>
							<button
								type='button'
								onClick={() => remove(index)}
								className='p-2 text-gray-400 hover:text-red-500 hover:bg-red-50 rounded transition-colors'>
								<Trash2 size={16} />
							</button>
						</div>
					))}
					{fields.length === 0 && (
						<div className='text-sm text-muted-foreground italic py-2'>No custom attributes defined.</div>
					)}
				</div>
			</div>

			{/* --- CHILD MANAGERS --- */}
			{id && type === 'session' && <SessionEventManager sessionId={id} />}
			{id && type === 'quest' && <QuestObjectiveManager questId={id} />}
			{id && <RelationshipManager entityId={id} />}
		</form>
	);
}

--- END OF features\admin-console\components\AdminForm.jsx ---

--- FILE: features\admin-console\components\EntitySearch.jsx ---
import React, { useState, useEffect, useRef } from 'react';
import { searchEntitiesByName } from '../../../services/admin'; // <--- NEW IMPORT
import { useCampaign } from '../../campaign-session/CampaignContext';
import { Search, X, Loader2 } from 'lucide-react';

export default function EntitySearch({ onSelect }) {
	const { campaignId } = useCampaign();
	const [query, setQuery] = useState('');
	const [results, setResults] = useState([]);
	const [isOpen, setIsOpen] = useState(false);
	const [isLoading, setIsLoading] = useState(false);
	const wrapperRef = useRef(null);

	// Close on click outside
	useEffect(() => {
		function handleClickOutside(event) {
			if (wrapperRef.current && !wrapperRef.current.contains(event.target)) {
				setIsOpen(false);
			}
		}
		document.addEventListener('mousedown', handleClickOutside);
		return () => document.removeEventListener('mousedown', handleClickOutside);
	}, [wrapperRef]);

	useEffect(() => {
		const doSearch = async () => {
			if (query.length < 2) {
				setResults([]);
				return;
			}
			setIsLoading(true);
			try {
				// <--- USE NEW SERVICE HERE
				const flat = await searchEntitiesByName(campaignId, query);

				// Client-side Sorting: Exact Match > Starts With > Includes
				flat.sort((a, b) => {
					const nameA = (a.name || '').toLowerCase();
					const nameB = (b.name || '').toLowerCase();
					const q = query.toLowerCase();

					// 1. Exact Match Priority
					if (nameA === q && nameB !== q) return -1;
					if (nameB === q && nameA !== q) return 1;

					// 2. Starts With Priority
					if (nameA.startsWith(q) && !nameB.startsWith(q)) return -1;
					if (nameB.startsWith(q) && !nameA.startsWith(q)) return 1;

					// 3. Shortest Name Priority (Less noise)
					return nameA.length - nameB.length;
				});

				setResults(flat);
				setIsOpen(true);
			} catch (error) {
				console.error('Search failed', error);
			} finally {
				setIsLoading(false);
			}
		};

		const timeout = setTimeout(doSearch, 300);
		return () => clearTimeout(timeout);
	}, [query, campaignId]);

	const handleSelect = (item) => {
		onSelect(item);
		setQuery('');
		setIsOpen(false);
	};

	return (
		<div className='relative w-full' ref={wrapperRef}>
			{/* Label removed inside component for cleaner Bulk UI */}

			<div className='relative'>
				<input
					type='text'
					value={query}
					onChange={(e) => {
						setQuery(e.target.value);
						if (!isOpen) setIsOpen(true);
					}}
					placeholder='Search by name...'
					className='w-full pl-9 pr-8 py-2 bg-background border border-border rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-amber-500 shadow-sm transition-shadow'
				/>
				<Search className='absolute left-3 top-2.5 text-muted-foreground/60' size={14} />

				{query && (
					<button
						onClick={() => {
							setQuery('');
							setIsOpen(false);
						}}
						className='absolute right-2 top-2 text-muted-foreground hover:text-foreground p-0.5 rounded'>
						<X size={14} />
					</button>
				)}
			</div>

			{/* Dropdown Results */}
			{isOpen && (results.length > 0 || isLoading) && (
				<div className='absolute z-50 w-full mt-1 bg-white border border-border rounded-lg shadow-xl max-h-60 overflow-y-auto overflow-x-hidden animate-in fade-in zoom-in-95 duration-100'>
					{isLoading ? (
						<div className='p-3 text-center text-xs text-muted-foreground flex items-center justify-center gap-2'>
							<Loader2 size={14} className='animate-spin' /> Searching...
						</div>
					) : (
						results.map((item) => (
							<button
								key={item.id}
								type='button'
								onClick={() => handleSelect(item)}
								className='w-full text-left px-3 py-2 hover:bg-amber-50 border-b border-border/50 last:border-0 transition-colors group'>
								<div className='font-bold text-sm text-foreground group-hover:text-amber-800 truncate'>{item.name}</div>
								<div className='flex items-center gap-2'>
									<span className='text-[10px] font-bold uppercase tracking-wider text-muted-foreground bg-muted px-1.5 rounded group-hover:bg-amber-100/50'>
										{item.type}
									</span>
									{/* Description Snippet */}
									<span className='text-[10px] text-muted-foreground/60 truncate max-w-[200px]'>
										{item.description ? item.description.substring(0, 50) : ''}
									</span>
								</div>
							</button>
						))
					)}
				</div>
			)}

			{isOpen && !isLoading && results.length === 0 && query.length >= 2 && (
				<div className='absolute z-50 w-full mt-1 bg-white border border-border rounded-lg shadow-xl p-3 text-center text-xs text-muted-foreground'>
					No results for "{query}"
				</div>
			)}
		</div>
	);
}

--- END OF features\admin-console\components\EntitySearch.jsx ---

--- FILE: features\admin-console\components\EventTagger.jsx ---
import React, { useState, useEffect } from 'react';
import { X, Plus, Loader2 } from 'lucide-react';
import EntitySearch from './EntitySearch';
import { fetchRelationships, addRelationship, deleteRelationship } from '../../../services/admin';

export default function EventTagger({ eventId }) {
	const [tags, setTags] = useState([]);
	const [loading, setLoading] = useState(false);
	const [isAdding, setIsAdding] = useState(false);

	// If it's a temporary event (unsaved), we can't tag yet
	const isTemp = String(eventId).startsWith('new-');

	useEffect(() => {
		if (!isTemp) loadTags();
	}, [eventId]);

	const loadTags = async () => {
		setLoading(true);
		try {
			const data = await fetchRelationships(eventId);
			setTags(data);
		} catch (e) {
			console.error(e);
		} finally {
			setLoading(false);
		}
	};

	const handleAdd = async (target) => {
		if (tags.find((t) => t.target?.id === target.id)) return;

		setIsAdding(true);
		try {
			await addRelationship({
				from_entity_id: eventId,
				to_entity_id: target.id,
				relationship_type: 'mention', // Standard type for events
				is_bidirectional: false,
			});
			loadTags();
		} catch (e) {
			alert(e.message);
		} finally {
			setIsAdding(false);
		}
	};

	const handleRemove = async (relId) => {
		try {
			await deleteRelationship(relId);
			setTags(tags.filter((t) => t.id !== relId));
		} catch (e) {
			alert(e.message);
		}
	};

	if (isTemp) {
		return <div className='text-xs text-amber-600 bg-amber-50 p-2 rounded'>Save this event to enable tagging.</div>;
	}

	return (
		<div className='space-y-2 mt-2 pt-2 border-t border-border/50'>
			<label className='text-[10px] font-bold uppercase text-muted-foreground'>Mentions / Related Entities</label>

			{/* Tag List */}
			<div className='flex flex-wrap gap-2 mb-2'>
				{tags.map((rel) => (
					<div
						key={rel.id}
						className='flex items-center gap-1 bg-white border border-border px-2 py-1 rounded-md text-xs shadow-sm'>
						<span className='font-medium text-foreground'>{rel.target?.name}</span>
						<span className='text-[9px] text-muted-foreground uppercase'>{rel.target?.type}</span>
						<button onClick={() => handleRemove(rel.id)} className='ml-1 text-gray-400 hover:text-red-500'>
							<X size={12} />
						</button>
					</div>
				))}
				{loading && <Loader2 size={14} className='animate-spin text-muted-foreground' />}
			</div>

			{/* Search Input */}
			<div className='max-w-xs'>
				<EntitySearch onSelect={handleAdd} />
			</div>
		</div>
	);
}

--- END OF features\admin-console\components\EventTagger.jsx ---

--- FILE: features\admin-console\components\MarkdownEditor.jsx ---
import React, { useState } from 'react';
import { Eye, Edit3 } from 'lucide-react';
import SmartMarkdown from '../../smart-text/SmartMarkdown';
import { INPUT_CLASS, LABEL_CLASS } from './ui/FormStyles';

export default function MarkdownEditor({ label, value, onChange, placeholder, rows = 6 }) {
	const [mode, setMode] = useState('write'); // 'write' | 'preview'

	return (
		<div>
			<div className='flex items-end justify-between mb-1'>
				<label className={LABEL_CLASS}>{label}</label>
				<div className='flex bg-muted rounded-md p-0.5 border border-border'>
					<button
						type='button'
						onClick={() => setMode('write')}
						className={`px-2 py-0.5 text-xs font-medium rounded flex items-center gap-1 transition-colors ${
							mode === 'write'
								? 'bg-background text-foreground shadow-sm'
								: 'text-muted-foreground hover:text-foreground'
						}`}>
						<Edit3 size={12} /> Write
					</button>
					<button
						type='button'
						onClick={() => setMode('preview')}
						className={`px-2 py-0.5 text-xs font-medium rounded flex items-center gap-1 transition-colors ${
							mode === 'preview'
								? 'bg-background text-foreground shadow-sm'
								: 'text-muted-foreground hover:text-foreground'
						}`}>
						<Eye size={12} /> Preview
					</button>
				</div>
			</div>

			{mode === 'write' ? (
				<textarea
					rows={rows}
					className={`${INPUT_CLASS} font-mono text-xs leading-relaxed`}
					value={value}
					onChange={onChange}
					placeholder={placeholder}
				/>
			) : (
				<div className='w-full px-3 py-3 bg-muted/10 border border-border rounded-md min-h-[150px] prose prose-sm max-w-none prose-p:my-1 prose-headings:my-2'>
					{value ? (
						<SmartMarkdown>{value}</SmartMarkdown>
					) : (
						<span className='text-muted-foreground italic'>Nothing to preview.</span>
					)}
				</div>
			)}
		</div>
	);
}

--- END OF features\admin-console\components\MarkdownEditor.jsx ---

--- FILE: features\admin-console\components\QuestObjectiveManager.jsx ---
import React, { useEffect, useState } from 'react';
import { Plus, Trash2, Edit2, Save, X, Target, CheckCircle2, Circle, Calendar } from 'lucide-react';
import { fetchChildRows, upsertQuestObjective, deleteRow, getSessionList } from '../../../services/admin'; // Import getSessionList
import { SECTION_CLASS, HEADER_CLASS, INPUT_CLASS, LABEL_CLASS } from './ui/FormStyles';
import { useCampaign } from '../../campaign-session/CampaignContext';
import Button from '../../../components/ui/Button';

export default function QuestObjectiveManager({ questId }) {
	const { campaignId } = useCampaign();
	const [objectives, setObjectives] = useState([]);
	const [sessions, setSessions] = useState([]); // Store session options
	const [loading, setLoading] = useState(false);
	const [editingId, setEditingId] = useState(null);
	const [formData, setFormData] = useState({});

	useEffect(() => {
		if (questId) {
			loadObjectives();
			loadSessions();
		}
	}, [questId]);

	const loadObjectives = async () => {
		setLoading(true);
		try {
			const data = await fetchChildRows('quest_objectives', 'quest_id', questId, 'order_index');
			setObjectives(data);
		} catch (e) {
			console.error(e);
		} finally {
			setLoading(false);
		}
	};

	const loadSessions = async () => {
		if (!campaignId) return;
		try {
			const data = await getSessionList(campaignId);
			setSessions(data);
		} catch (e) {
			console.error('Failed to load sessions', e);
		}
	};

	const handleAddNew = () => {
		const nextOrder = objectives.length > 0 ? Math.max(...objectives.map((o) => o.order_index || 0)) + 1 : 1;
		const newObj = {
			id: `new-${Date.now()}`,
			quest_id: questId,
			objective_name: '', // Title
			description: '',
			objective_update: '', // Resolution text
			status: 'pending',
			order_index: nextOrder,
			completed_session_id: null,
		};
		setObjectives([...objectives, newObj]);
		handleEdit(newObj);
	};

	const handleEdit = (obj) => {
		setEditingId(obj.id);
		setFormData({ ...obj });
	};

	const handleSave = async () => {
		try {
			await upsertQuestObjective(formData);
			setEditingId(null);
			loadObjectives();
		} catch (e) {
			alert(e.message);
		}
	};

	const handleDelete = async (id) => {
		if (!confirm('Delete?')) return;
		if (String(id).startsWith('new')) {
			setObjectives(objectives.filter((o) => o.id !== id));
			return;
		}
		try {
			await deleteRow('quest_objectives', id);
			loadObjectives();
		} catch (e) {
			alert(e.message);
		}
	};

	return (
		<div className={SECTION_CLASS}>
			<div className={`${HEADER_CLASS} flex justify-between`}>
				<span className='flex items-center gap-2'>
					<Target size={18} className='text-blue-600' /> Objectives
				</span>
				<Button onClick={handleAddNew} size='sm' variant='secondary' icon={Plus}>
					Add Objective
				</Button>
			</div>

			<div className='space-y-3'>
				{objectives.map((obj) => (
					<div key={obj.id} className='group'>
						{editingId === obj.id ? (
							/* --- EDIT MODE --- */
							<div className='bg-muted/30 border border-blue-300 rounded-lg p-4 space-y-4 animate-in fade-in'>
								{/* Row 1: Order, Title, Status */}
								<div className='flex gap-3'>
									<div className='w-16'>
										<label className={LABEL_CLASS}>#</label>
										<input
											type='number'
											className={INPUT_CLASS}
											value={formData.order_index}
											onChange={(e) => setFormData({ ...formData, order_index: parseInt(e.target.value) })}
										/>
									</div>
									<div className='flex-1'>
										<label className={LABEL_CLASS}>Title (Name)</label>
										<input
											type='text'
											className={`${INPUT_CLASS} font-bold`}
											autoFocus
											value={formData.objective_name || ''}
											onChange={(e) => setFormData({ ...formData, objective_name: e.target.value })}
											placeholder='Short summary...'
										/>
									</div>
									<div className='w-32'>
										<label className={LABEL_CLASS}>Status</label>
										<select
											className={INPUT_CLASS}
											value={formData.status}
											onChange={(e) => setFormData({ ...formData, status: e.target.value })}>
											<option value='pending'>Pending</option>
											<option value='completed'>Completed</option>
											<option value='failed'>Failed</option>
										</select>
									</div>
								</div>

								{/* Row 2: Description */}
								<div>
									<label className={LABEL_CLASS}>Description</label>
									<textarea
										rows={2}
										className={INPUT_CLASS}
										value={formData.description || ''}
										onChange={(e) => setFormData({ ...formData, description: e.target.value })}
										placeholder='What needs to be done?'
									/>
								</div>

								{/* Row 3: Updates & Session */}
								<div className='grid grid-cols-1 md:grid-cols-2 gap-4 border-t border-border/50 pt-3'>
									<div>
										<label className={LABEL_CLASS}>Resolution / Update Text</label>
										<textarea
											rows={2}
											className={INPUT_CLASS}
											value={formData.objective_update || ''}
											onChange={(e) => setFormData({ ...formData, objective_update: e.target.value })}
											placeholder='How was it resolved?'
										/>
									</div>
									<div>
										<label className={LABEL_CLASS}>Completed In Session</label>
										<select
											className={INPUT_CLASS}
											value={formData.completed_session_id || ''}
											onChange={(e) => setFormData({ ...formData, completed_session_id: e.target.value || null })}>
											<option value=''>-- None --</option>
											{sessions.map((s) => (
												<option key={s.id} value={s.id}>
													{s.title}
												</option>
											))}
										</select>
									</div>
								</div>

								<div className='flex justify-end gap-2 pt-2'>
									<Button
										onClick={() => {
											setEditingId(null);
											loadObjectives();
										}}
										variant='ghost'
										size='sm'
										icon={X}>
										Cancel
									</Button>
									<Button onClick={handleSave} variant='primary' size='sm' icon={Save}>
										Save Objective
									</Button>
								</div>
							</div>
						) : (
							/* --- VIEW MODE --- */
							<div
								className={`flex items-start gap-3 p-3 border rounded-lg transition-colors ${
									obj.status === 'completed'
										? 'bg-emerald-50/50 border-emerald-200'
										: 'bg-background border-border hover:border-blue-300'
								}`}>
								<span className='font-mono text-xs font-bold opacity-40 w-5 mt-1'>#{obj.order_index}</span>

								<div className='shrink-0 mt-0.5'>
									{obj.status === 'completed' ? (
										<CheckCircle2 size={18} className='text-emerald-600' />
									) : (
										<Circle size={18} className='text-muted-foreground' />
									)}
								</div>

								<div className='flex-1 min-w-0'>
									{obj.objective_name && (
										<div className='font-bold text-sm text-foreground mb-0.5'>{obj.objective_name}</div>
									)}
									<div
										className={`text-sm ${obj.status === 'completed' ? 'text-muted-foreground' : 'text-foreground'}`}>
										{obj.description}
									</div>

									{/* Resolution & Session Badges */}
									{(obj.objective_update || obj.completed_session_id) && (
										<div className='mt-2 flex flex-col gap-1'>
											{obj.objective_update && (
												<div className='text-xs text-emerald-700 bg-emerald-100/50 px-2 py-1 rounded border border-emerald-100 italic'>
													"{obj.objective_update}"
												</div>
											)}
											{obj.completed_session_id && (
												<div className='flex items-center gap-1 text-[10px] uppercase font-bold text-muted-foreground'>
													<Calendar size={10} />
													Session: {sessions.find((s) => s.id === obj.completed_session_id)?.title || 'Unknown'}
												</div>
											)}
										</div>
									)}
								</div>

								<div className='flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity'>
									<button
										onClick={() => handleEdit(obj)}
										className='p-2 text-muted-foreground hover:text-blue-600 hover:bg-blue-50 rounded-md transition-colors'
										title='Edit Event'>
										<Edit2 size={18} />
									</button>
									<button
										onClick={() => handleDelete(obj.id)}
										className='p-2 text-muted-foreground hover:text-red-600 hover:bg-red-50 rounded-md transition-colors'
										title='Delete Event'>
										<Trash2 size={18} />
									</button>
								</div>
							</div>
						)}
					</div>
				))}

				{objectives.length === 0 && !loading && (
					<div className='text-center py-6 text-muted-foreground text-sm italic'>No objectives defined yet.</div>
				)}
			</div>
		</div>
	);
}

--- END OF features\admin-console\components\QuestObjectiveManager.jsx ---

--- FILE: features\admin-console\components\RelationshipManager.jsx ---
import React, { useEffect, useState, useMemo } from 'react';
import {
	Trash2,
	Link as LinkIcon,
	ArrowRightLeft,
	ArrowRight,
	Save,
	X,
	Edit2,
	Layers,
	EyeOff,
	Shield,
	Sword,
	MapPin,
	Flag,
	User,
	Users,
	Briefcase,
	BookOpen,
	Gem,
	Calendar,
} from 'lucide-react';
import EntitySearch from './EntitySearch';
import { fetchRelationships, addRelationship, deleteRelationship, updateRelationship } from '../../../services/admin';
import { SECTION_CLASS, HEADER_CLASS, INPUT_CLASS } from './ui/FormStyles';
import Button from '../../../components/ui/Button';

// --- CONFIGURATION ---

// 1. Group Headers (By Entity Type)
const ENTITY_GROUPS = {
	character: { label: 'Characters', icon: Users, color: 'text-rose-600', bg: 'bg-rose-50' },
	npc: { label: 'NPCs', icon: User, color: 'text-amber-600', bg: 'bg-amber-50' },
	location: { label: 'Locations', icon: MapPin, color: 'text-emerald-600', bg: 'bg-emerald-50' },
	faction: { label: 'Factions', icon: Shield, color: 'text-purple-600', bg: 'bg-purple-50' },
	quest: { label: 'Quests', icon: Flag, color: 'text-blue-600', bg: 'bg-blue-50' },
	session: { label: 'Sessions', icon: BookOpen, color: 'text-slate-600', bg: 'bg-slate-50' },
	item: { label: 'Items', icon: Gem, color: 'text-indigo-600', bg: 'bg-indigo-50' },
	event: { label: 'Events', icon: Calendar, color: 'text-orange-600', bg: 'bg-orange-50' },
	default: { label: 'Other Entities', icon: LinkIcon, color: 'text-gray-600', bg: 'bg-gray-50' },
};

const GROUP_ORDER = ['character', 'npc', 'faction', 'location', 'quest', 'item', 'session', 'event'];

// 2. Item Styles (By Relationship Type) - Keeps the "Ally/Enemy" visual context
const REL_STYLES = {
	Ally: { color: 'text-emerald-700', bg: 'bg-emerald-100/50', border: 'border-emerald-400' },
	Friend: { color: 'text-emerald-700', bg: 'bg-emerald-100/50', border: 'border-emerald-400' },
	Enemy: { color: 'text-red-700', bg: 'bg-red-100/50', border: 'border-red-400' },
	Rival: { color: 'text-red-700', bg: 'bg-red-100/50', border: 'border-red-400' },
	Located_In: { color: 'text-amber-700', bg: 'bg-amber-100/50', border: 'border-amber-400' },
	Parent_Location: { color: 'text-amber-700', bg: 'bg-amber-100/50', border: 'border-amber-400' },
	Quest_Giver: { color: 'text-blue-700', bg: 'bg-blue-100/50', border: 'border-blue-400' },
	Participant: { color: 'text-blue-700', bg: 'bg-blue-100/50', border: 'border-blue-400' },
	Generic: { color: 'text-slate-600', bg: 'bg-slate-100', border: 'border-slate-300' },
};

export default function RelationshipManager({ entityId }) {
	const [relationships, setRelationships] = useState([]);
	const [loading, setLoading] = useState(false);

	// BULK ADD STATE
	const [pendingTargets, setPendingTargets] = useState([]);
	const [type, setType] = useState('Generic');
	const [isBidirectional, setIsBidirectional] = useState(false);
	const [isHidden, setIsHidden] = useState(false);
	const [isAdding, setIsAdding] = useState(false);

	// EDIT STATE
	const [editingId, setEditingId] = useState(null);
	const [editForm, setEditForm] = useState({});

	useEffect(() => {
		if (entityId) loadRelationships();
	}, [entityId]);

	const loadRelationships = async () => {
		setLoading(true);
		try {
			const data = await fetchRelationships(entityId);
			setRelationships(data);
		} catch (e) {
			console.error(e);
		} finally {
			setLoading(false);
		}
	};

	// --- GROUPING LOGIC (By Entity Type) ---
	const grouped = useMemo(() => {
		const groups = {};
		relationships.forEach((rel) => {
			// Group by Target Entity Type (e.g. 'npc', 'location')
			const entityType = rel.target?.type?.toLowerCase() || 'default';
			// Map to config key or fallback
			const groupKey = ENTITY_GROUPS[entityType] ? entityType : 'default';

			if (!groups[groupKey]) groups[groupKey] = [];
			groups[groupKey].push(rel);
		});
		return groups;
	}, [relationships]);

	// --- HANDLERS ---
	const handleSelectTarget = (item) => {
		if (pendingTargets.find((t) => t.id === item.id) || item.id === entityId) return;
		setPendingTargets([...pendingTargets, item]);
	};
	const removePending = (id) => setPendingTargets(pendingTargets.filter((t) => t.id !== id));

	const handleBulkAdd = async () => {
		if (pendingTargets.length === 0) return;
		setIsAdding(true);
		try {
			await Promise.all(
				pendingTargets.map((target) =>
					addRelationship({
						from_entity_id: entityId,
						to_entity_id: target.id,
						relationship_type: type,
						is_bidirectional: isBidirectional,
						is_hidden: isHidden,
					})
				)
			);
			setPendingTargets([]);
			setType('Generic');
			loadRelationships();
		} catch (e) {
			alert('Error: ' + e.message);
		} finally {
			setIsAdding(false);
		}
	};

	const handleUpdate = async () => {
		try {
			await updateRelationship(editingId, {
				relationship_type: editForm.relationship_type,
				is_bidirectional: editForm.is_bidirectional,
				is_hidden: editForm.is_hidden,
			});
			setEditingId(null);
			loadRelationships();
		} catch (e) {
			alert(e.message);
		}
	};

	const handleDelete = async (id) => {
		if (!confirm('Remove link?')) return;
		try {
			await deleteRelationship(id);
			loadRelationships();
		} catch (e) {
			alert(e.message);
		}
	};

	if (!entityId) return null;

	// Dropdown options
	const relationshipTypes = [
		'member_of',
		'leadership_relation',
		'part_of',
		'affiliated_with',
		'family_relation',
		'romantic_relation',
		'professional_relation',
		'located_in',
		'parent_location',
		'residence_relation',
		'workplace_relation',
		'ownership_relation',
		'quest_giver',
		'quest_objective',
		'quest_update',
		'quest_participant',
		'quest_location',
		'hostile_to',
		'knowledge_of',
		'encountered',
	];

	// Helper to get sort order including "Other" groups not in explicit list
	const sortedGroupKeys = [...GROUP_ORDER, ...Object.keys(grouped).filter((k) => !GROUP_ORDER.includes(k))];

	return (
		<div className={SECTION_CLASS}>
			<h2 className={`${HEADER_CLASS} flex items-center gap-2`}>
				<LinkIcon size={18} className='text-amber-600' /> Relationships
			</h2>

			{/* --- ADD NEW SECTION --- */}
			<div className='bg-muted/30 p-4 rounded-lg mb-6 border border-border shadow-sm'>
				<div className='flex items-center justify-between mb-3'>
					<h3 className='text-[10px] font-bold text-muted-foreground uppercase tracking-wider flex items-center gap-2'>
						<Layers size={12} /> Bulk Connect
					</h3>
					{pendingTargets.length > 0 && (
						<span className='text-xs text-amber-600 font-bold bg-amber-50 px-2 py-0.5 rounded-full border border-amber-100'>
							{pendingTargets.length} Ready
						</span>
					)}
				</div>

				<div className='space-y-4'>
					<div className='w-full'>
						<EntitySearch onSelect={handleSelectTarget} />
					</div>

					{pendingTargets.length > 0 && (
						<div className='flex flex-wrap gap-2 p-3 bg-background border border-border rounded-md'>
							{pendingTargets.map((t) => (
								<div
									key={t.id}
									className='flex items-center gap-2 bg-amber-50 text-amber-900 px-2 py-1 rounded border border-amber-200 text-xs font-medium'>
									<span className='uppercase text-[9px] text-amber-700/60 font-bold'>{t.type}</span>
									<span>{t.name}</span>
									<button onClick={() => removePending(t.id)} className='text-amber-500 hover:text-amber-800'>
										
									</button>
								</div>
							))}
						</div>
					)}

					<div className='flex flex-col md:flex-row gap-3 items-end pt-2 border-t border-border/50'>
						<div className='flex-1 w-full grid grid-cols-2 gap-4'>
							<div>
								<label className='block text-[10px] uppercase font-bold text-muted-foreground mb-1'>Type</label>
								<select value={type} onChange={(e) => setType(e.target.value)} className={INPUT_CLASS}>
									{relationshipTypes.map((t) => (
										<option key={t} value={t}>
											{t.replace('_', ' ')}
										</option>
									))}
								</select>
							</div>
							<div className='flex flex-col gap-2 pb-1'>
								<label className='flex items-center gap-2 cursor-pointer select-none'>
									<input
										type='checkbox'
										checked={isBidirectional}
										onChange={(e) => setIsBidirectional(e.target.checked)}
										className='w-4 h-4 text-amber-600 rounded focus:ring-amber-500'
									/>
									<span className='text-xs text-muted-foreground font-medium'>2-Way</span>
								</label>
								<label className='flex items-center gap-2 cursor-pointer select-none'>
									<input
										type='checkbox'
										checked={isHidden}
										onChange={(e) => setIsHidden(e.target.checked)}
										className='w-4 h-4 text-amber-600 rounded focus:ring-amber-500'
									/>
									<span className='text-xs text-muted-foreground font-medium flex items-center gap-1'>
										Hidden <EyeOff size={10} />
									</span>
								</label>
							</div>
						</div>
						<Button
							onClick={handleBulkAdd}
							disabled={pendingTargets.length === 0 || isAdding}
							size='sm'
							variant='primary'
							className='w-full md:w-auto min-w-[100px]'>
							{isAdding ? 'Saving...' : `Add ${pendingTargets.length > 0 ? `(${pendingTargets.length})` : ''}`}
						</Button>
					</div>
				</div>
			</div>

			{/* --- LIST SECTION (GROUPED BY ENTITY TYPE) --- */}
			<div className='space-y-6'>
				{relationships.length === 0 && (
					<div className='p-4 text-center text-xs text-muted-foreground italic border border-dashed border-border rounded-lg'>
						No relationships connected.
					</div>
				)}

				{sortedGroupKeys.map((groupKey) => {
					const items = grouped[groupKey];
					if (!items || items.length === 0) return null;

					const groupConfig = ENTITY_GROUPS[groupKey] || ENTITY_GROUPS.default;
					const GroupIcon = groupConfig.icon;

					return (
						<div key={groupKey} className='animate-in fade-in slide-in-from-bottom-2 duration-500'>
							{/* Group Header */}
							<h3
								className={`text-[11px] font-bold uppercase tracking-widest mb-3 border-b border-border/60 pb-1 flex items-center gap-2 ${groupConfig.color} opacity-90`}>
								<GroupIcon size={14} /> {groupConfig.label}
								<span className='ml-auto text-[9px] bg-muted/50 px-1.5 py-0.5 rounded-full text-muted-foreground'>
									{items.length}
								</span>
							</h3>

							<div className='grid grid-cols-1 gap-2'>
								{items.map((rel) => {
									// Item Style based on Relationship Type (Ally/Enemy)
									const style = REL_STYLES[rel.relationship_type] || REL_STYLES.Generic;

									return (
										<div
											key={rel.id}
											className={`group border rounded-lg transition-all bg-background hover:shadow-sm ${
												editingId === rel.id ? 'border-amber-400 ring-1 ring-amber-400' : 'border-border'
											}`}>
											{editingId === rel.id ? (
												/* EDIT MODE */
												<div className='grid grid-cols-[1fr_auto_auto_auto] gap-3 items-center p-2 bg-muted/20'>
													<div className='font-bold text-sm text-foreground truncate min-w-0'>{rel.target?.name}</div>

													<div className='w-36'>
														<select
															className={`${INPUT_CLASS} py-1 h-8 text-xs`}
															value={editForm.relationship_type}
															onChange={(e) => setEditForm({ ...editForm, relationship_type: e.target.value })}>
															{relationshipTypes.map((t) => (
																<option key={t} value={t}>
																	{t.replace('_', ' ')}
																</option>
															))}
														</select>
													</div>

													<div className='flex flex-col gap-1 px-2'>
														<label className='flex items-center gap-1 cursor-pointer'>
															<input
																type='checkbox'
																checked={editForm.is_bidirectional}
																onChange={(e) => setEditForm({ ...editForm, is_bidirectional: e.target.checked })}
															/>
															<span className='text-[10px] uppercase text-muted-foreground'>2-Way</span>
														</label>
														<label className='flex items-center gap-1 cursor-pointer'>
															<input
																type='checkbox'
																checked={editForm.is_hidden}
																onChange={(e) => setEditForm({ ...editForm, is_hidden: e.target.checked })}
															/>
															<span className='text-[10px] uppercase text-muted-foreground'>Hidden</span>
														</label>
													</div>

													<div className='flex gap-1'>
														<Button onClick={handleUpdate} size='sm' variant='primary' icon={Save} className='h-9 px-3'>
															Save
														</Button>
														<Button
															onClick={() => setEditingId(null)}
															size='sm'
															variant='ghost'
															icon={X}
															className='h-9 px-3'>
															Cancel
														</Button>
													</div>
												</div>
											) : (
												/* VIEW MODE */
												<div className={`flex items-center justify-between p-1 pl-0`}>
													<div className='flex items-center gap-3 min-w-0 pl-3'>
														<div className='flex items-center gap-2'>
															<span className='text-sm font-bold text-foreground truncate'>{rel.target?.name}</span>
															{rel.is_hidden && <EyeOff size={14} className='text-gray-400' title='Hidden' />}
															{rel.is_bidirectional && (
																<ArrowRightLeft size={12} className='text-muted-foreground/50' title='Bidirectional' />
															)}
														</div>
														<div className='flex items-center gap-1.5 mt-0.5'>
															{/* Relationship Type Badge */}
															<span
																className={`text-[10px] font-bold uppercase px-1.5 py-0 rounded-sm ${style.bg} ${style.color} border border-transparent`}>
																{rel.relationship_type.replace('_', ' ')}
															</span>
														</div>
													</div>
													<div className='flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity pr-2'>
														<button
															onClick={() => {
																setEditingId(rel.id);
																setEditForm({
																	relationship_type: rel.relationship_type,
																	is_bidirectional: rel.is_bidirectional,
																	is_hidden: rel.is_hidden,
																});
															}}
															className='p-2 text-muted-foreground hover:text-blue-600 hover:bg-blue-50 rounded-md transition-colors'>
															<Edit2 size={18} />
														</button>
														<button
															onClick={() => handleDelete(rel.id)}
															className='p-2 text-muted-foreground hover:text-red-600 hover:bg-red-50 rounded-md transition-colors'>
															<Trash2 size={18} />
														</button>
													</div>
												</div>
											)}
										</div>
									);
								})}
							</div>
						</div>
					);
				})}
			</div>
		</div>
	);
}

--- END OF features\admin-console\components\RelationshipManager.jsx ---

--- FILE: features\admin-console\components\SessionEventManager.jsx ---
import React, { useEffect, useState } from 'react';
import { Plus, Trash2, Edit2, Save, X, Calendar } from 'lucide-react';
import {
	fetchChildRows,
	upsertSessionEvent,
	deleteRow,
	fetchSessionEventsWithRelationships,
} from '../../../services/admin';
import { SECTION_CLASS, HEADER_CLASS, INPUT_CLASS, LABEL_CLASS } from './ui/FormStyles';
import Button from '../../../components/ui/Button';
import EventTagger from './EventTagger';

const EVENT_TYPES = [
	'combat',
	'social',
	'quest_started',
	'quest_progressed',
	'travel',
	'location_discovered',
	'location_visited',
	'npc_encountered',
	'faction_discovered',
	'investigation',
	'backstory',
	'discovery',
	'vision',
	'shopping',
	'special_event',
];

export default function SessionEventManager({ sessionId }) {
	const [events, setEvents] = useState([]);
	const [loading, setLoading] = useState(false);
	const [editingId, setEditingId] = useState(null);
	const [formData, setFormData] = useState({});

	useEffect(() => {
		if (sessionId) loadEvents();
	}, [sessionId]);

	const loadEvents = async () => {
		setLoading(true);
		try {
			const data = await fetchSessionEventsWithRelationships(sessionId);
			setEvents(data);
		} catch (e) {
			console.error(e);
		} finally {
			setLoading(false);
		}
	};

	const handleAddNew = () => {
		const nextOrder = events.length > 0 ? Math.max(...events.map((e) => e.event_order || 0)) + 1 : 1;
		const newEvent = {
			id: `new-${Date.now()}`,
			session_id: sessionId,
			title: '',
			description: '',
			event_type: 'travel',
			event_order: nextOrder,
		};
		setEvents([...events, newEvent]);
		handleEdit(newEvent);
	};

	const handleEdit = (event) => {
		setEditingId(event.id);
		setFormData({ ...event });
	};

	const handleSave = async () => {
		try {
			const { relationships, ...payload } = formData;
			await upsertSessionEvent(payload);
			setEditingId(null);
			loadEvents();
		} catch (e) {
			alert('Error saving event: ' + e.message);
		}
	};

	const handleDelete = async (id) => {
		if (!confirm('Delete this event?')) return;
		if (String(id).startsWith('new')) {
			setEvents(events.filter((e) => e.id !== id));
			return;
		}
		try {
			await deleteRow('session_events', id);
			loadEvents();
		} catch (e) {
			alert(e.message);
		}
	};

	return (
		<div className={SECTION_CLASS}>
			<div className={`${HEADER_CLASS} flex items-center justify-between`}>
				<span className='flex items-center gap-2'>
					<Calendar size={18} className='text-amber-600' /> Session Timeline
				</span>
				<Button onClick={handleAddNew} size='sm' variant='secondary' icon={Plus}>
					Add Event
				</Button>
			</div>

			<div className='space-y-3'>
				{events.map((evt) => (
					<div key={evt.id} className='group'>
						{editingId === evt.id ? (
							/* --- EDIT MODE --- */
							<div className='bg-muted/30 border border-amber-300 rounded-lg p-4 space-y-4 animate-in fade-in'>
								<div className='flex gap-3'>
									<div className='w-16'>
										<label className={LABEL_CLASS}>Order</label>
										<input
											type='number'
											className={INPUT_CLASS}
											value={formData.event_order}
											onChange={(e) => setFormData({ ...formData, event_order: parseInt(e.target.value) })}
										/>
									</div>
									<div className='flex-1'>
										<label className={LABEL_CLASS}>Title</label>
										<input
											type='text'
											className={`${INPUT_CLASS} font-bold`}
											autoFocus
											value={formData.title}
											onChange={(e) => setFormData({ ...formData, title: e.target.value })}
										/>
									</div>
									<div className='w-1/3'>
										<label className={LABEL_CLASS}>Type</label>
										<select
											className={INPUT_CLASS}
											value={formData.event_type}
											onChange={(e) => setFormData({ ...formData, event_type: e.target.value })}>
											{EVENT_TYPES.map((t) => (
												<option key={t} value={t}>
													{t.replace(/_/g, ' ')}
												</option>
											))}
										</select>
									</div>
								</div>

								<div>
									<label className={LABEL_CLASS}>Description</label>
									<textarea
										rows={3}
										className={INPUT_CLASS}
										value={formData.description || ''}
										onChange={(e) => setFormData({ ...formData, description: e.target.value })}
									/>
								</div>

								<EventTagger eventId={evt.id} />

								<div className='flex justify-end gap-3 border-t border-border/50 pt-3'>
									<Button
										onClick={() => {
											setEditingId(null);
											loadEvents();
										}}
										variant='ghost'
										icon={X}>
										Cancel
									</Button>
									<Button onClick={handleSave} variant='primary' icon={Save}>
										Save Changes
									</Button>
								</div>
							</div>
						) : (
							/* --- VIEW MODE --- */
							<div className='flex items-start gap-3 p-3 bg-background border border-border rounded-lg hover:border-amber-300 transition-colors'>
								<div className='shrink-0 w-6 h-6 rounded-full bg-muted flex items-center justify-center text-xs font-bold text-muted-foreground border border-border'>
									{evt.event_order}
								</div>
								<div className='flex-1 min-w-0'>
									<div className='flex items-center gap-2 mb-1'>
										<span className='text-[10px] font-bold uppercase tracking-wider px-1.5 py-0.5 bg-muted text-muted-foreground rounded border border-border'>
											{evt.event_type ? evt.event_type.replace(/_/g, ' ') : 'Event'}
										</span>
										<h4 className='font-bold text-sm text-foreground'>{evt.title}</h4>
									</div>
									<p className='text-xs text-muted-foreground line-clamp-2'>{evt.description}</p>
									{evt.relationships && evt.relationships.length > 0 && (
										<div className='flex flex-wrap gap-1.5 mt-1'>
											{evt.relationships.map((rel) => (
												<div
													key={rel.id}
													className='inline-flex items-center gap-1.5 px-1.5 py-0.5 rounded bg-white border border-border text-[10px] text-muted-foreground shadow-sm select-none'>
													<span className='font-medium text-foreground'>{rel.target?.name}</span>
													<span className='text-[9px] opacity-60 uppercase'>{rel.target?.type}</span>
												</div>
											))}
										</div>
									)}
								</div>

								<div className='flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity'>
									<button
										onClick={() => handleEdit(evt)}
										className='p-2 text-muted-foreground hover:text-blue-600 hover:bg-blue-50 rounded-md transition-colors'>
										<Edit2 size={18} />
									</button>
									<button
										onClick={() => handleDelete(evt.id)}
										className='p-2 text-muted-foreground hover:text-red-600 hover:bg-red-50 rounded-md transition-colors'>
										<Trash2 size={18} />
									</button>
								</div>
							</div>
						)}
					</div>
				))}
			</div>
		</div>
	);
}

--- END OF features\admin-console\components\SessionEventManager.jsx ---

--- FILE: features\admin-console\components\SmartImageInput.jsx ---
import React from 'react';
import { Image as ImageIcon } from 'lucide-react';
import { INPUT_CLASS } from './ui/FormStyles';

// Helper to make DB paths browser-friendly
const resolvePreviewUrl = (url) => {
	if (!url) return null;
	// Remove all ../ sequences
	const cleanPath = url.replace(/(\.\.\/)+/g, '').replace(/^\//, '');
	// Prepend the base URL (usually / or /dnd-campaign-manager/ depending on vite config)
	return `${import.meta.env.BASE_URL}${cleanPath}`;
};

export default function SmartImageInput({ value, onChange, placeholder, ...props }) {
	const previewUrl = resolvePreviewUrl(value);

	return (
		<div className='flex gap-3 items-start'>
			<div className='flex-1'>
				<input
					type='text'
					className={INPUT_CLASS}
					placeholder={placeholder || 'images/icons/...'}
					value={value || ''}
					onChange={onChange}
					{...props}
				/>
				<p className='text-[10px] text-muted-foreground mt-1'>Value stored in DB: {value}</p>
			</div>

			{/* Live Preview Box */}
			<div className='shrink-0 w-10 h-10 rounded border border-border bg-muted flex items-center justify-center overflow-hidden shadow-sm bg-white'>
				{previewUrl ? (
					<img
						src={previewUrl}
						alt='Preview'
						className='w-full h-full object-contain'
						onError={(e) => {
							e.target.style.display = 'none';
						}}
					/>
				) : (
					<ImageIcon size={16} className='text-muted-foreground/50' />
				)}
			</div>
		</div>
	);
}

--- END OF features\admin-console\components\SmartImageInput.jsx ---

--- FILE: features\admin-console\components\ui\FormStyles.js ---
// src/features/admin-console/components/ui/FormStyles.js

export const INPUT_CLASS =
	'w-full px-3 py-1.5 bg-background border border-border rounded-md text-sm text-foreground focus:outline-none focus:ring-1 focus:ring-amber-500 placeholder:text-muted-foreground/50 transition-shadow';

export const LABEL_CLASS = 'block text-xs font-bold text-muted-foreground uppercase tracking-wider mb-1.5';

export const SECTION_CLASS = 'bg-background border border-border rounded-lg p-4 shadow-sm';

export const HEADER_CLASS =
	'text-lg font-serif font-bold text-foreground border-b border-border pb-2 mb-4 flex items-center justify-between';

--- END OF features\admin-console\components\ui\FormStyles.js ---

--- FILE: features\admin-console\config\strategies.js ---
export const ADMIN_STRATEGIES = {
	// 0. CAMPAIGN (Meta Entity)
	campaign: {
		label: 'Campaign',
		type: 'campaign',
		primaryTable: 'campaigns',
		colMapping: { name: 'name', description: 'description' },
		hasNarrative: true, // Use Markdown for description
		defaultAttributes: [
			{ key: 'campaign_id', label: 'Campaign ID (Integer)', type: 'number' }, // Required by your schema
			{ key: 'map_data', label: 'Map Data (JSON)', type: 'text' }, // Advanced: map config
		],
	},

	// 1. NPC
	npc: {
		label: 'NPC',
		type: 'npc',
		primaryTable: 'npcs',
		colMapping: { name: 'name', description: 'description' },
		hasNarrative: true,
		defaultAttributes: [
			{ key: 'race', label: 'Race/Ancestry', type: 'text' },
			{ key: 'class', label: 'Class/Occupation', type: 'text' },
			{ key: 'affinity', label: 'Affinity', type: 'select', options: ['Ally', 'Neutral', 'Enemy', 'Unknown'] },
			{ key: 'status', label: 'Status', type: 'text' },
			{ key: 'icon', label: 'Icon URL', type: 'image' },
		],
	},

	// 2. LOCATION
	location: {
		label: 'Location',
		type: 'location',
		primaryTable: 'locations',
		colMapping: { name: 'name', description: 'description' },
		hasNarrative: true,
		defaultAttributes: [
			{ key: 'type', label: 'Type', type: 'text' },
			{ key: 'background_image', label: 'Background Image', type: 'image' },
		],
	},

	// 3. SESSION
	session: {
		label: 'Session',
		type: 'session',
		primaryTable: 'sessions',
		colMapping: { name: 'title', description: 'narrative' },
		hasNarrative: true,
		defaultAttributes: [
			{ key: 'session_number', label: 'Session Number', type: 'number' },
			{ key: 'session_date', label: 'In-Game Date', type: 'text' },
		],
	},

	// 4. QUEST
	quest: {
		label: 'Quest',
		type: 'quest',
		primaryTable: 'quests',
		colMapping: { name: 'title', description: 'description' },
		hasNarrative: true,
		defaultAttributes: [
			{ key: 'status', label: 'Status', type: 'select', options: ['Active', 'Completed', 'Failed', 'Pending'] },
			{ key: 'quest type', label: 'Quest Type', type: 'select', options: ['Main Quest', 'Side Quest', 'Personal'] },
			{ key: 'priority', label: 'Priority', type: 'select', options: ['Normal', 'High', 'Critical', 'Low'] },
		],
	},

	// 5. FACTION
	faction: {
		label: 'Faction',
		type: 'faction',
		primaryTable: 'factions',
		colMapping: { name: 'name', description: 'description' },
		hasNarrative: true,
		defaultAttributes: [
			{ key: 'leader', label: 'Leader', type: 'text' },
			{ key: 'affinity', label: 'Affinity', type: 'select', options: ['Ally', 'Neutral', 'Enemy'] },
			{ key: 'icon', label: 'Icon URL', type: 'image' },
		],
	},

	// 6. ITEM
	item: {
		label: 'Item',
		type: 'item',
		primaryTable: 'items',
		colMapping: { name: 'name', description: 'description' },
		defaultAttributes: [
			{
				key: 'type',
				label: 'Type',
				type: 'select',
				options: ['Weapon', 'Armor', 'Potion', 'Scroll', 'Wondrous Item', 'Key Item', 'Treasure'],
			},
			{
				key: 'rarity',
				label: 'Rarity',
				type: 'select',
				options: ['Common', 'Uncommon', 'Rare', 'Very Rare', 'Legendary', 'Artifact'],
			},
			{ key: 'value', label: 'Gold Value', type: 'text' },
			{ key: 'attunement', label: 'Attunement?', type: 'select', options: ['Yes', 'No'] },
			{ key: 'icon', label: 'Icon URL', type: 'image' },
		],
	},

	// 7. CHARACTER (The Party)
	character: {
		label: 'Character',
		type: 'character',
		primaryTable: 'characters',
		// 'background' is usually the column name for description in D&D schemas
		// If your table uses 'description', change 'background' to 'description'
		colMapping: { name: 'name', description: 'description' },
		hasNarrative: true,
		defaultAttributes: [
			{ key: 'race', label: 'Race', type: 'text' },
			{ key: 'class', label: 'Class', type: 'text' },
			{ key: 'level', label: 'Level', type: 'number' },
			{ key: 'speed', label: 'Speed', type: 'text' },
			{ key: 'hit points', label: 'Hit Points', type: 'text' },
			{ key: 'armor class', label: 'Armor Class', type: 'text' },
			{ key: 'icon', label: 'Icon URL', type: 'image' },
		],
	},

	default: {
		label: 'Entity',
		primaryTable: 'entities',
		colMapping: { name: 'name', description: 'description' },
		defaultAttributes: [],
	},
};

export const getStrategy = (type) => {
	return ADMIN_STRATEGIES[type] || ADMIN_STRATEGIES.default;
};

--- END OF features\admin-console\config\strategies.js ---

--- FILE: features\admin-console\layouts\AdminLayout.jsx ---
import React from 'react';
import { Outlet, Link, useLocation, useNavigate } from 'react-router-dom';
import { clsx } from 'clsx';
import { Database, Users, MapPin, BookOpen, Scroll, ArrowLeft, Shield, Gem, LogOut, Play } from 'lucide-react';
import { useCampaign } from '../../campaign-session/CampaignContext'; // 1. Import Context

const NavItem = ({ to, icon: Icon, label }) => {
	const location = useLocation();
	const isActive = location.pathname.includes(to);

	return (
		<Link
			to={to}
			className={clsx(
				'flex items-center gap-2 px-3 py-1.5 text-sm font-medium rounded-md transition-all duration-200',
				isActive
					? 'bg-amber-100 text-amber-900 shadow-sm ring-1 ring-amber-200'
					: 'text-muted-foreground hover:bg-muted/80 hover:text-foreground'
			)}>
			<Icon size={15} className={isActive ? 'text-amber-700' : 'opacity-70'} />
			{label}
		</Link>
	);
};

export default function AdminLayout() {
	const { campaignId, setCampaignId } = useCampaign(); // 2. Get Campaign State
	const navigate = useNavigate();

	const handleSwitch = () => {
		if (confirm('Go to Campaign Selection screen?')) {
			setCampaignId(null); // 3. Clear the ID
			navigate('/select-campaign'); // 4. Navigate to root (which now renders CampaignSelect)
		}
	};

	return (
		<div className='flex h-screen bg-muted/30 text-foreground overflow-hidden font-sans'>
			{/* Sidebar */}
			<aside className='w-56 bg-background border-r border-border flex flex-col shrink-0'>
				<div className='p-4 border-b border-border bg-muted/20'>
					<div className='flex items-center gap-2 text-amber-700'>
						<div className='p-1.5 bg-amber-100 rounded-md'>
							<Database size={18} />
						</div>
						<h2 className='font-serif font-bold text-lg leading-none'>DM Console</h2>
					</div>
				</div>

				<nav className='flex-1 p-3 space-y-0.5 overflow-y-auto'>
					<div className='px-3 py-2 text-[10px] font-bold uppercase tracking-widest text-muted-foreground/60'>
						System
					</div>
					<NavItem to='/dm/manage/campaign' icon={Database} label='Campaigns' />

					<div className='mt-4 px-3 py-2 text-[10px] font-bold uppercase tracking-widest text-muted-foreground/60'>
						Entities
					</div>
					<NavItem to='/dm/manage/character' icon={Users} label='Characters' />
					<NavItem to='/dm/manage/npc' icon={Users} label='NPCs' />
					<NavItem to='/dm/manage/location' icon={MapPin} label='Locations' />
					<NavItem to='/dm/manage/faction' icon={Shield} label='Factions' />
					<NavItem to='/dm/manage/item' icon={Gem} label='Items' />

					<div className='mt-4 px-3 py-2 text-[10px] font-bold uppercase tracking-widest text-muted-foreground/60'>
						Campaign
					</div>
					<NavItem to='/dm/manage/session' icon={BookOpen} label='Sessions' />
					<NavItem to='/dm/manage/quest' icon={Scroll} label='Quests' />
				</nav>

				<div className='p-3 border-t border-border space-y-1'>
					{/* OPTION A: Return to Active Campaign */}
					{campaignId && (
						<Link
							to='/'
							className='flex items-center gap-2 w-full px-3 py-2 text-xs font-bold uppercase tracking-wide text-emerald-700 hover:bg-emerald-50 rounded-md transition-colors'
							title={`Return to Campaign ID: ${campaignId}`}>
							<Play size={14} /> Enter Campaign
						</Link>
					)}

					{/* OPTION B: Switch / Log Out */}
					<button
						onClick={handleSwitch}
						className='flex items-center gap-2 w-full px-3 py-2 text-xs font-bold uppercase tracking-wide text-muted-foreground hover:text-red-600 hover:bg-red-50 rounded-md transition-colors text-left'>
						<LogOut size={14} /> Campaign Select
					</button>
				</div>
			</aside>

			{/* Main Content */}
			<main className='flex-1 h-full overflow-y-auto bg-muted/10 custom-scrollbar'>
				<div className='mx-auto'>
					<Outlet />
				</div>
			</main>
		</div>
	);
}

--- END OF features\admin-console\layouts\AdminLayout.jsx ---

--- FILE: features\admin-console\pages\EntityEditorPage.jsx ---
import React from 'react';
import { useParams } from 'react-router-dom';
import AdminForm from '../components/AdminForm'; // Import the form

export default function EntityEditorPage() {
	const { type, id } = useParams();

	return (
		<div className='max-w-5xl mx-auto'>
			{/* Page Header */}
			<div className='mb-6'>
				<h1 className='text-2xl font-serif font-bold text-foreground capitalize'>
					{id ? `Edit ${type}` : `Create New ${type}`}
				</h1>
				<p className='text-sm text-muted-foreground'>
					{id ? `ID: ${id}` : 'Fill in the details below to create a new entry.'}
				</p>
			</div>

			{/* The Dynamic Form */}
			<AdminForm
				type={type}
				id={id}
				key={`${type}-${id || 'new'}`} // <--- This forces a complete rebuild when type changes
			/>
		</div>
	);
}

--- END OF features\admin-console\pages\EntityEditorPage.jsx ---

--- FILE: features\admin-console\pages\EntityListPage.jsx ---
import React, { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Link, useParams, useNavigate } from 'react-router-dom';
import { Edit, Plus, Search, Loader2, Copy, Trash2 } from 'lucide-react';
import { getEntities } from '../../../services/entities';
import { createEntity, fetchRawEntity, deleteEntity } from '../../../services/admin';
import { useCampaign } from '../../campaign-session/CampaignContext';
import Button from '../../../components/ui/Button';
import EntityBadge from '../../../components/entity/EntityBadge';

export default function EntityListPage() {
	const { type } = useParams(); // e.g., 'npc', 'location'
	const navigate = useNavigate();
	const { campaignId } = useCampaign();
	const [search, setSearch] = useState('');
	const [isCloning, setIsCloning] = useState(null); // Stores ID of item being cloned
	const [isDeleting, setIsDeleting] = useState(null);

	const normalizedType = type === 'sessions' ? 'session' : type;

	// 1. Fetch List Data
	const { data, isLoading, refetch } = useQuery({
		queryKey: ['admin-list', campaignId, normalizedType],
		queryFn: () => getEntities(campaignId, normalizedType),
		enabled: !!campaignId,
	});

	const filtered = (data || []).filter((item) =>
		(item.name || item.title || '').toLowerCase().includes(search.toLowerCase())
	);

	// 2. Handle Duplication
	const handleDuplicate = async (originalId) => {
		if (!confirm('Create a copy of this entity?')) return;

		setIsCloning(originalId);
		try {
			// A. Fetch original raw data (exactly as DB sees it)
			const raw = await fetchRawEntity(normalizedType, originalId);

			// B. Prepare Copy Data
			// We strip the ID so Supabase creates a new one
			// We modify the name so you know it's a copy
			const copyData = {
				...raw,
				name: raw.name ? `${raw.name} (Copy)` : undefined,
				title: raw.title ? `${raw.title} (Copy)` : undefined,
				campaign_id: campaignId,
			};

			// C. Create the new entity
			const result = await createEntity(normalizedType, copyData);

			// D. Navigate to the new Editor
			navigate(`/dm/editor/${normalizedType}/${result.id}`);
		} catch (e) {
			console.error('Duplication failed:', e);
			alert('Failed to duplicate: ' + e.message);
			setIsCloning(false); // Only reset if failed (otherwise we navigate away)
		}
	};

	const handleDelete = async (id) => {
		if (!confirm(`Are you sure you want to delete this ${normalizedType}? This cannot be undone.`)) return;

		setIsDeleting(id);
		try {
			await deleteEntity(normalizedType, id);
			// Refresh list
			refetch();
		} catch (e) {
			alert('Delete failed: ' + e.message);
		} finally {
			setIsDeleting(null);
		}
	};

	return (
		<div className='space-y-4 animate-in fade-in duration-300'>
			{/* --- Header Toolbar --- */}
			<div className='flex flex-col sm:flex-row sm:items-center justify-between gap-4'>
				<h1 className='text-2xl font-serif font-bold text-foreground capitalize flex items-center gap-2'>
					{type}s
					<span className='text-sm font-sans font-normal text-muted-foreground bg-muted px-2 py-0.5 rounded-full border border-border'>
						{data?.length || 0}
					</span>
				</h1>
				<Link to={`/dm/editor/${normalizedType}`}>
					<Button variant='primary' icon={Plus} size='sm'>
						Create New
					</Button>
				</Link>
			</div>

			{/* --- Search Bar --- */}
			<div className='relative'>
				<Search className='absolute left-3 top-2.5 text-muted-foreground/60' size={16} />
				<input
					type='text'
					placeholder={`Filter ${type}s...`}
					value={search}
					onChange={(e) => setSearch(e.target.value)}
					className='w-full pl-9 pr-4 py-2 bg-background border border-border rounded-lg text-sm text-foreground focus:outline-none focus:ring-1 focus:ring-amber-500 shadow-sm placeholder:text-muted-foreground/50'
				/>
			</div>

			{/* --- Entity List --- */}
			<div className='bg-background border border-border rounded-lg shadow-sm overflow-hidden'>
				<div className='divide-y divide-border'>
					{isLoading ? (
						<div className='p-12 flex justify-center text-muted-foreground'>
							<Loader2 className='animate-spin text-amber-600' />
						</div>
					) : filtered.length === 0 ? (
						<div className='p-12 text-center text-muted-foreground text-sm italic bg-muted/10'>
							{search ? `No matches for "${search}"` : `No ${type}s found. Create one to get started.`}
						</div>
					) : (
						filtered.map((item) => (
							<div
								key={item.id}
								className='group flex items-center justify-between p-3 hover:bg-muted/40 transition-colors'>
								{/* Left: Info */}
								<div className='flex items-center gap-3 min-w-0 flex-1'>
									<div className='min-w-0'>
										<div className='flex items-center gap-2'>
											<span className='font-medium text-sm text-foreground truncate'>{item.name || item.title}</span>
											{/* Show badge if type differs from current view (e.g. searching generic entities) */}
											{item.type !== normalizedType && <EntityBadge type={item.type} size='sm' variant='subtle' />}
										</div>
										<div className='text-[11px] text-muted-foreground truncate max-w-xl'>
											{item.summary || item.narrative || item.description || 'No description'}
										</div>
									</div>
								</div>

								{/* Right: Actions */}
								<div className='flex items-center gap-2 shrink-0 ml-4 opacity-100 sm:opacity-0 sm:group-hover:opacity-100 transition-opacity'>
									<EntityBadge
										type={item.type}
										size='sm'
										variant='outline'
										className='opacity-50 hidden sm:inline-flex'
									/>

									{/* Duplicate Button */}
									<button
										onClick={() => handleDuplicate(item.id)}
										disabled={isCloning === item.id}
										className='p-1.5 text-muted-foreground hover:text-amber-600 hover:bg-amber-50 rounded-md transition-colors focus:outline-none focus:ring-1 focus:ring-amber-500'
										title='Duplicate'>
										{isCloning === item.id ? (
											<Loader2 size={16} className='animate-spin text-amber-600' />
										) : (
											<Copy size={16} />
										)}
									</button>

									{/* Edit Button */}
									<Link to={`/dm/editor/${normalizedType}/${item.id}`}>
										<Button
											variant='ghost'
											size='sm'
											icon={Edit}
											className='h-8 px-2 text-muted-foreground hover:text-foreground'>
											Edit
										</Button>
									</Link>

									{/* Delete */}
									<button
										onClick={() => handleDelete(item.id)}
										disabled={isDeleting === item.id}
										className='p-1.5 text-muted-foreground hover:text-red-600 hover:bg-red-50 rounded-md transition-colors'
										title='Delete'>
										{isDeleting === item.id ? <Loader2 size={16} className='animate-spin' /> : <Trash2 size={16} />}
									</button>
								</div>
							</div>
						))
					)}
				</div>
			</div>
		</div>
	);
}

--- END OF features\admin-console\pages\EntityListPage.jsx ---

--- FILE: features\admin-console\pages\SplitPaneManager.jsx ---
import React, { useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { Plus, Search, Loader2, Copy, Trash2 } from 'lucide-react';
import { getEntities } from '../../../services/entities';
import { createEntity, fetchRawEntity, deleteEntity } from '../../../services/admin';
import { useCampaign } from '../../campaign-session/CampaignContext';
import AdminForm from '../components/AdminForm';
import Button from '../../../components/ui/Button';

export default function SplitPaneManager() {
	const { type, id } = useParams();
	const navigate = useNavigate();
	const { campaignId } = useCampaign();
	const [search, setSearch] = useState('');

	// Action States
	const [isCloning, setIsCloning] = useState(null);
	const [isDeleting, setIsDeleting] = useState(null);

	const normalizedType = type === 'sessions' ? 'session' : type;

	// 1. Fetch List Data
	const {
		data: entities,
		isLoading,
		refetch,
	} = useQuery({
		queryKey: ['admin-list', campaignId, normalizedType],
		queryFn: () => getEntities(campaignId, normalizedType),
		enabled: normalizedType === 'campaign' || !!campaignId,
	});

	const filtered = (entities || []).filter((item) =>
		(item.name || item.title || '').toLowerCase().includes(search.toLowerCase())
	);

	// --- ACTIONS ---

	const handleDuplicate = async (originalId, e) => {
		e.stopPropagation(); // Prevent navigation
		if (!confirm('Create a copy?')) return;

		setIsCloning(originalId);
		try {
			const raw = await fetchRawEntity(normalizedType, originalId);
			// Fix: Check for attributesList vs attributes object structure from fetchRawEntity
			// fetchRawEntity returns { ..., attributes: {...} } OR { ..., attributesList: [...] } depending on version
			// The service handles formatting for createEntity, we just need to modify the name.

			const copyData = {
				...raw,
				name: raw.name ? `${raw.name} (Copy)` : undefined,
				title: raw.title ? `${raw.title} (Copy)` : undefined,
				campaign_id: campaignId,
			};

			// If ID exists in raw data, remove it so DB creates new one
			delete copyData.id;

			const result = await createEntity(normalizedType, copyData);
			refetch(); // Refresh list
			navigate(`/dm/manage/${normalizedType}/${result.id}`);
		} catch (e) {
			alert('Failed to duplicate: ' + e.message);
		} finally {
			setIsCloning(false);
		}
	};

	const handleDelete = async (itemId, e) => {
		e.stopPropagation(); // Prevent navigation
		if (!confirm('Delete this entry?')) return;

		setIsDeleting(itemId);
		try {
			await deleteEntity(normalizedType, itemId);
			refetch();
			// If we deleted the currently selected item, go back to "Create New"
			if (id === itemId) {
				navigate(`/dm/manage/${normalizedType}`);
			}
		} catch (e) {
			alert('Delete failed: ' + e.message);
		} finally {
			setIsDeleting(null);
		}
	};

	return (
		<div className='flex h-[100vh] overflow-hidden bg-muted/10'>
			{/* --- LEFT PANE: LIST --- */}
			<div className='w-80 flex flex-col border-r border-border bg-background shrink-0 shadow-sm z-10'>
				{/* Header & Search */}
				<div className='p-3 border-b border-border space-y-3 bg-muted/10'>
					<div className='flex items-center justify-between'>
						<h2 className='text-lg font-serif font-bold capitalize text-foreground flex items-center gap-2'>
							{type}s
							<span className='text-xs font-sans font-normal text-muted-foreground bg-muted px-2 py-0.5 rounded-full border border-border'>
								{entities?.length || 0}
							</span>
						</h2>
						<Button
							onClick={() => navigate(`/dm/manage/${normalizedType}`)}
							size='sm'
							variant='primary'
							icon={Plus}
							className='h-7 px-2 text-xs'>
							New
						</Button>
					</div>
					<div className='relative'>
						<Search className='absolute left-2.5 top-2 text-muted-foreground/60' size={14} />
						<input
							type='text'
							placeholder='Filter list...'
							value={search}
							onChange={(e) => setSearch(e.target.value)}
							className='w-full pl-8 pr-3 py-1.5 bg-background border border-border rounded-md text-xs focus:outline-none focus:ring-1 focus:ring-amber-500 shadow-sm'
						/>
					</div>
				</div>

				{/* Scrollable List */}
				<div className='flex-1 overflow-y-auto custom-scrollbar'>
					{isLoading ? (
						<div className='p-8 flex justify-center'>
							<Loader2 className='animate-spin text-amber-600' />
						</div>
					) : filtered.length === 0 ? (
						<div className='p-6 text-center text-xs text-muted-foreground italic'>No matches.</div>
					) : (
						<div className='divide-y divide-border/40'>
							{filtered.map((item) => {
								const isActive = id === item.id;
								return (
									<div
										key={item.id}
										onClick={() => navigate(`/dm/manage/${normalizedType}/${item.id}`)}
										className={`group relative flex items-center w-full text-left transition-all cursor-pointer ${
											isActive ? 'bg-amber-50/80' : 'bg-background hover:bg-muted/50'
										}`}>
										{/* Active Marker Strip */}
										<div
											className={`absolute left-0 top-0 bottom-0 w-1 ${isActive ? 'bg-amber-500' : 'bg-transparent'}`}
										/>

										{/* Main Content Area */}
										<div className='flex-1 py-3 pl-4 pr-2 min-w-0'>
											<div
												className={`font-bold text-sm truncate mb-0.5 ${
													isActive ? 'text-amber-900' : 'text-foreground'
												}`}>
												{item.name || item.title}
											</div>
											<div className='flex items-center justify-between'>
												<div className='text-[10px] text-muted-foreground truncate w-full'>
													{item.summary || item.narrative || item.description || 'No description'}
												</div>
												{/* Status Dot */}
												{item.status && (
													<div
														title={item.status}
														className={`w-1.5 h-1.5 rounded-full shrink-0 ${
															item.status.toLowerCase().includes('active')
																? 'bg-emerald-500'
																: item.status.toLowerCase().includes('dead')
																? 'bg-red-500'
																: 'bg-slate-300'
														}`}
													/>
												)}
											</div>
										</div>

										{/* Action Buttons (Visible on Hover) */}
										<div
											className={`flex flex-col gap-1 pr-1 pl-1 ${
												isActive ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'
											} transition-opacity`}>
											<button
												onClick={(e) => handleDuplicate(item.id, e)}
												className='p-1 text-muted-foreground hover:text-blue-600 hover:bg-blue-100 rounded'
												title='Duplicate'>
												{isCloning === item.id ? <Loader2 size={12} className='animate-spin' /> : <Copy size={12} />}
											</button>
											<button
												onClick={(e) => handleDelete(item.id, e)}
												className='p-1 text-muted-foreground hover:text-red-600 hover:bg-red-100 rounded'
												title='Delete'>
												{isDeleting === item.id ? <Loader2 size={12} className='animate-spin' /> : <Trash2 size={12} />}
											</button>
										</div>
									</div>
								);
							})}
						</div>
					)}
				</div>
			</div>

			{/* --- RIGHT PANE: EDITOR --- */}
			<div className='flex-1 overflow-y-auto bg-muted/10 p-4 md:p-8 custom-scrollbar'>
				<div className='max-w-4xl mx-auto'>
					<AdminForm key={`${normalizedType}-${id || 'new'}`} type={normalizedType} id={id} />
				</div>
			</div>
		</div>
	);
}

--- END OF features\admin-console\pages\SplitPaneManager.jsx ---

--- FILE: features\app-core\App.jsx ---
// features/app-core/App.jsx
import { useEffect } from 'react';
import { useQueryClient } from '@tanstack/react-query'; // Add this
import { TooltipProvider } from '../../features/smart-tooltip/TooltipContext';
import { CampaignProvider, useCampaign } from '../../features/campaign-session/CampaignContext';
import ErrorBoundary from '../../components/ErrorBoundary';
import { AppRoutes } from './AppRoutes';

function AppContent() {
	const { campaignId } = useCampaign();
	const queryClient = useQueryClient();

	// 1. Set global texture
	useEffect(() => {
		const texturePath = `${import.meta.env.BASE_URL}images/background_texture.png`;
		document.documentElement.style.setProperty('--bg-texture', `url('${texturePath}')`);
	}, []);

	// 2. CRITICAL FIX: Clear cache when campaign changes
	useEffect(() => {
		if (campaignId) {
			// Invalidate stale data instead of removing (preserves in-flight requests)
			queryClient.invalidateQueries({
				predicate: (query) => {
					const key = query.queryKey[0];
					// Only invalidate campaign-specific data
					return ['entities', 'entry', 'timeline', 'graph', 'entityIndex', 'globalSearch'].includes(key);
				},
			});
		}
	}, [campaignId, queryClient]);

	return (
		<TooltipProvider>
			<AppRoutes />
		</TooltipProvider>
	);
}

export default function App() {
	return (
		<ErrorBoundary>
			<CampaignProvider>
				{/* We move logic to a sub-component so we can use useCampaign() */}
				<AppContent />
			</CampaignProvider>
		</ErrorBoundary>
	);
}

--- END OF features\app-core\App.jsx ---

--- FILE: features\app-core\AppRoutes.jsx ---
import { Routes, Route, Navigate } from 'react-router-dom';
import { Suspense, lazy } from 'react';
import { useCampaign } from '../../features/campaign-session/CampaignContext';
import { RouteLoading } from './components/RouteLoading';

const CampaignSelect = lazy(() => import('../../features/campaign-session/components/CampaignSelect'));
const MainLayout = lazy(() => import('../../features/layout-main/MainLayout'));
const MapView = lazy(() => import('../../features/world-map/MapView'));
const TimelineView = lazy(() => import('../../features/timeline/TimelineView'));
const RelationshipGraph = lazy(() => import('../../features/relationship-graph/RelationshipGraph'));
const WikiLayout = lazy(() => import('../../features/wiki-layout/WikiLayout'));
const WikiEntryPage = lazy(() => import('../../features/entity-view/pages/WikiEntryPage'));

// Admin Features
const AdminLayout = lazy(() => import('../../features/admin-console/layouts/AdminLayout'));
const SplitPaneManager = lazy(() => import('../../features/admin-console/pages/SplitPaneManager'));

export const AppRoutes = () => {
	const { campaignId } = useCampaign();

	// SECURITY CHECK: Only true during 'npm run dev'
	const isDev = import.meta.env.DEV;

	return (
		<Suspense fallback={<RouteLoading text='Loading Application...' />}>
			<Routes>
				{/* --- 1. ADMIN CONSOLE (Strictly Dev Only) --- */}
				{isDev && (
					<Route path='/dm' element={<AdminLayout />}>
						<Route index element={<Navigate to='/dm/manage/campaign' replace />} />
						<Route path='manage/:type/:id?' element={<SplitPaneManager />} />
					</Route>
				)}

				{/* --- 2. CAMPAIGN SELECTION --- */}
				<Route path='/select-campaign' element={<CampaignSelect />} />

				{/* --- 3. MAIN APP --- */}
				{campaignId ? (
					<Route path='/' element={<MainLayout />}>
						<Route index element={<Navigate to='/wiki/session' replace />} />

						<Route path='atlas/:mapId' element={<MapView />} />
						<Route path='atlas' element={<Navigate to='/atlas/world_map' replace />} />
						<Route path='timeline' element={<TimelineView />} />
						<Route path='relationships' element={<RelationshipGraph />} />

						<Route path='wiki/:type' element={<WikiLayout />}>
							<Route
								index
								element={<div className='h-full flex items-center justify-center text-gray-400'>Select an entry</div>}
							/>
							<Route path=':entityId' element={<WikiEntryPage />} />
						</Route>

						{/* If user tries to access /dm manually in prod while logged in, 
                            it won't match above. Add a catch-all to redirect back to home. */}
						<Route path='*' element={<Navigate to='/' replace />} />
					</Route>
				) : (
					// Fallback if not logged in
					<Route path='*' element={<Navigate to='/select-campaign' replace />} />
				)}
			</Routes>
		</Suspense>
	);
};

--- END OF features\app-core\AppRoutes.jsx ---

--- FILE: features\app-core\components\RouteLoading.jsx ---
import LoadingSpinner from '../../../components/ui/LoadingSpinner';

export const RouteLoading = ({ text }) => (
	<div className='flex items-center justify-center h-full min-h-screen bg-muted'>
		<LoadingSpinner size='lg' text={text} />
	</div>
);

--- END OF features\app-core\components\RouteLoading.jsx ---

--- FILE: features\campaign-session\CampaignContext.jsx ---
import { createContext, useContext } from 'react';
import { useCampaignPersistence } from './useCampaignPersistence';

const CampaignContext = createContext(null);

export const CampaignProvider = ({ children }) => {
	const persistence = useCampaignPersistence();

	return <CampaignContext.Provider value={persistence}>{children}</CampaignContext.Provider>;
};

export const useCampaign = () => {
	const context = useContext(CampaignContext);
	if (!context) {
		throw new Error('useCampaign must be used within CampaignProvider');
	}
	return context;
};

--- END OF features\campaign-session\CampaignContext.jsx ---

--- FILE: features\campaign-session\types.js ---
/**
 * @typedef {Object} Campaign
 * @property {string} id
 * @property {string} name
 * @property {string} description
 */

/**
 * @typedef {Object} CampaignSelectionViewModel
 * @property {boolean} isLoading
 * @property {Campaign[]} campaigns
 * @property {function(string): void} selectCampaign
 */

export {};

--- END OF features\campaign-session\types.js ---

--- FILE: features\campaign-session\useCampaignPersistence.js ---
import { useState, useCallback } from 'react';

const STORAGE_KEY = 'campaignId';

// Safe wrapper for environments where localStorage might fail
const storage = {
	getItem: (key) => {
		try {
			return localStorage.getItem(key) || sessionStorage.getItem(key);
		} catch {
			return null;
		}
	},
	setItem: (key, value) => {
		try {
			localStorage.setItem(key, value);
		} catch {
			sessionStorage.setItem(key, value);
		}
	},
	removeItem: (key) => {
		try {
			localStorage.removeItem(key);
			sessionStorage.removeItem(key);
		} catch {
			// ignore
		}
	},
};

export function useCampaignPersistence() {
	const [campaignId, setCampaignIdState] = useState(() => {
		return storage.getItem(STORAGE_KEY) || null;
	});

	const setCampaignId = useCallback((id) => {
		setCampaignIdState(id);
		if (id) {
			storage.setItem(STORAGE_KEY, id);
		} else {
			storage.removeItem(STORAGE_KEY);
		}
	}, []);

	return { campaignId, setCampaignId };
}

--- END OF features\campaign-session\useCampaignPersistence.js ---

--- FILE: features\campaign-session\useCampaignSelection.js ---
import { useQuery } from '@tanstack/react-query';
import { useNavigate } from 'react-router-dom'; // 1. Import useNavigate
import { getCampaigns } from '../../services/campaigns';
import { useCampaign } from './CampaignContext';
import './types';

export function useCampaignSelection() {
	const { setCampaignId } = useCampaign();
	const navigate = useNavigate(); // 2. Initialize hook

	const { data: campaigns, isLoading } = useQuery({
		queryKey: ['campaigns'],
		queryFn: getCampaigns,
	});

	// Sort by ID
	const sortedCampaigns = (campaigns || []).sort((a, b) => String(a.campaign_id).localeCompare(String(b.campaign_id)));

	const selectCampaign = (id) => {
		setCampaignId(id);
		navigate('/'); // 3. Force navigation to the main app route
	};

	return {
		isLoading,
		campaigns: sortedCampaigns,
		selectCampaign,
	};
}

--- END OF features\campaign-session\useCampaignSelection.js ---

--- FILE: features\campaign-session\components\CampaignCard.jsx ---
import { BookOpen, ArrowRight, Users } from 'lucide-react';
import Button from '../../../components/ui/Button';

export const CampaignCard = ({ campaign, onSelect }) => {
	const initial = (campaign.name?.[0] || 'C').toUpperCase();

	return (
		<div className='bg-background/80 backdrop-blur-sm rounded-xl border border-border shadow-lg hover:shadow-xl transition-all p-6 flex flex-col h-full border-t-4 border-t-amber-600'>
			{/* ID Badge */}
			<div className='mb-4 flex justify-between items-start'>
				<div className='w-12 h-12 rounded-lg bg-amber-100 flex items-center justify-center text-amber-700 font-serif font-bold text-xl border border-amber-200'>
					{initial}
				</div>
				<span className='text-[10px] font-mono text-gray-400 bg-muted px-2 py-1 rounded'>
					ID: {campaign.id.slice(0, 8)}...
				</span>
			</div>

			<div className='flex-1 mb-6'>
				<h3 className='text-xl font-bold text-foreground font-serif mb-2'>{campaign.name}</h3>
				<p className='text-sm text-gray-500 line-clamp-2 mb-4 leading-relaxed italic'>
					{campaign.description || 'A journey into the unknown.'}
				</p>

				{/* Characters Section */}
				{campaign.characterNames?.length > 0 && (
					<div className='pt-4 border-t border-border/50'>
						<div className='flex items-center gap-2 text-xs font-bold text-amber-800 uppercase tracking-wider mb-2'>
							<Users size={12} />
							Party Members
						</div>
						<div className='flex flex-wrap gap-1'>
							{campaign.characterNames
								.filter((name) => name !== 'Party')
								.map((name, i) => (
									<span
										key={i}
										className='text-[11px] px-2 py-0.5 bg-amber-50 text-amber-700 rounded-full border border-amber-100'>
										{name}
									</span>
								))}
						</div>
					</div>
				)}
			</div>

			<div className='mt-auto'>
				<Button onClick={() => onSelect(campaign.id)} fullWidth variant='primary' icon={ArrowRight}>
					Enter Campaign
				</Button>
			</div>
		</div>
	);
};

--- END OF features\campaign-session\components\CampaignCard.jsx ---

--- FILE: features\campaign-session\components\CampaignSelect.jsx ---
import { useCampaignSelection } from '../useCampaignSelection';
import { CampaignCard } from './CampaignCard';
import LoadingSpinner from '../../../components/ui/LoadingSpinner';

export default function CampaignSelect() {
	const { campaigns, isLoading, selectCampaign } = useCampaignSelection();
	const logoPath = `${import.meta.env.BASE_URL}logo_detailed.png`;

	if (isLoading) {
		return (
			<div className='min-h-screen bg-muted flex flex-col items-center justify-center'>
				<LoadingSpinner size='lg' text='Consulting the Archives...' />
			</div>
		);
	}

	return (
		<div
			className='min-h-screen p-6 md:p-12 font-sans flex items-center justify-center'
			style={{
				backgroundImage: 'var(--bg-texture)',
				backgroundRepeat: 'repeat',
			}}>
			<div className='max-w-5xl w-full mx-auto'>
				{/* Header Section */}
				<div className='text-center mb-12 animate-in fade-in slide-in-from-top-4 duration-700'>
					<img src={logoPath} alt='Logo' className='h-32 md:h-40 mx-auto mb-8 drop-shadow-2xl' />
					<h1 className='text-4xl md:text-5xl font-serif font-bold text-foreground mb-4'>Select Campaign</h1>
					<p className='text-gray-600 text-lg max-w-xl mx-auto'>
						Choose a world to enter. Your adventures, characters, and chronicles await.
					</p>
				</div>

				{/* Grid Section - Centered */}
				<div className='flex flex-wrap justify-center gap-8'>
					{campaigns.map((campaign) => (
						<div key={campaign.id} className='w-full md:w-[calc(50%-1rem)] lg:w-[calc(33.33%-1.5rem)] max-w-sm'>
							<CampaignCard campaign={campaign} onSelect={selectCampaign} />
						</div>
					))}

					{campaigns.length === 0 && (
						<div className='w-full py-20 text-center border-2 border-dashed border-border rounded-xl bg-background/50 backdrop-blur-sm'>
							<p className='text-gray-400 font-serif text-xl'>No campaigns found in the library.</p>
						</div>
					)}
				</div>
			</div>
		</div>
	);
}

--- END OF features\campaign-session\components\CampaignSelect.jsx ---

--- FILE: features\entity-view\index.js ---
/**
 * Entity View Module Exports
 * Centralized exports for entity view feature
 */

// Main view model hook
export { useEntityViewModel } from './useEntityViewModel';

// Sub-hooks (if needed directly)
export { useEntityHeader } from './hooks/useEntityHeader';
export { useEntityContent } from './hooks/useEntityContent';
export { useEntitySidebar } from './hooks/useEntitySidebar';

// Transform functions (if needed directly)
export { transformAttributes, extractHeaderTags } from './transforms/attributeTransform';
export { transformRelationships } from './transforms/relationshipTransform';
export { transformEvents } from './transforms/eventTransform';

// Layouts
export { StandardLayout, SessionLayout } from './layouts';

// Components
export { default as WikiEntityView } from './WikiEntityView';
export { EntityHeader } from './components/EntityHeader';
export { EntityBody, EntityHistory } from './components/EntityBody';
export { EntitySidebar } from './components/EntitySidebar';

--- END OF features\entity-view\index.js ---

--- FILE: features\entity-view\useEntityViewModel.js ---
import { useMemo } from 'react';
import { parseAttributes } from '../../utils/image/imageResolver'; // Use the safe parser
import { transformAttributes } from './transforms/attributeTransform';
import { useEntityHeader } from './hooks/useEntityHeader';
import { useEntityContent } from './hooks/useEntityContent';
import { useEntitySidebar } from './hooks/useEntitySidebar';

export function useEntityViewModel(entity) {
	// 1. Prepare Attributes
	// Optimization: parseAttributes now just returns the object if it's already an object.
	// This allows this hook to work with both Raw Service data and Transformed View data.
	const attributes = useMemo(() => {
		return parseAttributes(entity?.attributes);
	}, [entity]);

	// 2. Transform attributes into traits and sections
	const { traits, sections } = useMemo(() => {
		if (!entity) return { traits: [], sections: [] };
		// Pass description to avoid duplicating it in attributes list
		return transformAttributes(attributes, entity.description);
	}, [entity, attributes]);

	// 3. Build sub-models
	// We pass the full entity because it might contain pre-calculated props (like 'objectives' or 'events')
	// from the transform layer that the sub-hooks need.
	const header = useEntityHeader(entity, attributes);
	const sidebar = useEntitySidebar(entity, traits);
	const content = useEntityContent(entity, attributes, sections);

	// 4. Determine layout mode
	const layoutMode = useMemo(() => {
		// Safe check for session type
		return entity?.type === 'session' ? 'tabs' : 'standard';
	}, [entity]);

	return useMemo(() => {
		if (!entity) return null;

		return {
			layoutMode,
			header,
			sidebar,
			content,
		};
	}, [entity, layoutMode, header, sidebar, content]);
}

--- END OF features\entity-view\useEntityViewModel.js ---

--- FILE: features\entity-view\WikiEntityView.jsx ---
// features/entity-view/WikiEntityView.jsx
import { useEntityViewModel } from './useEntityViewModel';
import { EntityHeader } from './components/EntityHeader';
import StandardLayout from './layouts/StandardLayout';
import SessionLayout from './layouts/SessionLayout';

export default function WikiEntityView({ entity }) {
	const viewModel = useEntityViewModel(entity);

	if (!viewModel) return null;

	// Determine layout based on entity type
	let LayoutComponent;
	if (entity?.type === 'session') {
		LayoutComponent = SessionLayout;
	} else {
		LayoutComponent = StandardLayout;
	}

	return (
		<div className='pb-16 animate-in fade-in duration-300 min-h-full'>
			{/* Universal Header */}
			<EntityHeader data={viewModel.header} />

			{/* Dynamic Layout */}
			<LayoutComponent viewModel={viewModel} />
		</div>
	);
}

--- END OF features\entity-view\WikiEntityView.jsx ---

--- FILE: features\entity-view\components\EntityBody.jsx ---
import { History, Diamond } from 'lucide-react';
import SmartMarkdown from '../../smart-text/SmartMarkdown';
import { EntityHistory } from './EntityHistory';
import { QuestObjectives } from './QuestObjectives'; // Import
import { SectionDivider } from '../../../components/ui/SectionDivider'; // Import

// Re-exporting History for use in tabs if needed by parent
export { EntityHistory } from './EntityHistory';

// ... (LevelUpBanner component remains here or moves to own file) ...
// For brevity, assuming LevelUpBanner is kept or moved similarly.

export const EntityBody = ({ summary, sections, history, objectives, levelUp }) => {
	return (
		<div className='prose prose-slate max-w-none prose-headings:font-serif prose-headings:font-bold prose-headings:text-foreground prose-p:text-slate-700 prose-p:text-[11pt] prose-p:leading-relaxed prose-p:my-2 prose-strong:text-foreground prose-strong:font-bold prose-li:marker:text-amber-600 prose-li:text-sm prose-li:my-0.5 prose-p:text-justify'>
			{summary && (
				<div className='mb-4'>
					<SmartMarkdown>{summary}</SmartMarkdown>
				</div>
			)}

			{/* Quest Objectives Component */}
			{objectives && objectives.length > 0 && (
				<>
					<SectionDivider />
					<QuestObjectives objectives={objectives} />
				</>
			)}

			{/* Narrative Sections */}
			{sections.map((prop) => {
				if (prop.displayType === 'list' && Array.isArray(prop.value)) {
					return (
						<div key={prop.key}>
							<SectionDivider />
							<h3 className='capitalize text-lg mt-0 font-serif text-accent mb-2 font-bold'>{prop.key}</h3>
							<ul className='grid grid-cols-1 gap-1.5 pl-1 list-none my-0'>
								{prop.value.map((item, idx) => (
									<li key={idx} className='flex items-start gap-3 m-0 p-0 text-foreground group'>
										<div className='mt-[0.45rem] shrink-0 text-accent/60 group-hover:text-accent transition-colors'>
											<Diamond size={8} fill='currentColor' />
										</div>
										<span className='text-[11pt] leading-snug'>
											<SmartMarkdown components={{ p: 'span' }}>{item}</SmartMarkdown>
										</span>
									</li>
								))}
							</ul>
						</div>
					);
				}
				return (
					<div key={prop.key}>
						<SectionDivider />
						<h3 className='capitalize text-lg font-serif text-accent mb-1 mt-0 inline-block pb-0.5'>{prop.key}</h3>
						<div className='mt-0.5'>
							<SmartMarkdown>{prop.value}</SmartMarkdown>
						</div>
					</div>
				);
			})}

			{history && history.length > 0 && (
				<div className='mt-2'>
					<SectionDivider />
					<h3 className='font-serif text-lg mt-0 font-bold text-foreground mb-3 flex items-center gap-2'>
						<History size={16} className='text-accent' /> Events
					</h3>
					<EntityHistory events={history} />
				</div>
			)}

			{/* LevelUpBanner logic... */}
		</div>
	);
};

--- END OF features\entity-view\components\EntityBody.jsx ---

--- FILE: features\entity-view\components\EntityHeader.jsx ---
import { clsx } from 'clsx';
import EntityIcon from '../../../components/entity/EntityIcon';
import EntityBadge from '../../../components/entity/EntityBadge';
import { getPriorityStyles } from '../../../config/entity/styles'; // Import

export const EntityHeader = ({ data }) => {
	const { title, typeLabel, imageUrl, avatarUrl, status, priority, theme, extraTags } = data;

	return (
		<div className='h-40 md:h-48 relative group overflow-hidden header-bg-fallback'>
			{/* 1. BACKGROUND LAYER (Banner) */}
			{imageUrl && (
				<img src={imageUrl} alt={title} className='absolute inset-0 w-full h-full object-cover object-top opacity-60' />
			)}

			{/* Gradient Overlay */}
			<div className='absolute inset-0 bg-gradient-to-t from-white via-transparent to-transparent opacity-10' />
			<div className='absolute inset-0 header-gradient translate-y-1' />

			{/* Content Layer */}
			<div className='absolute bottom-0 left-0 w-full p-4 md:p-6'>
				<div className='max-w-6xl mx-auto flex items-end gap-4'>
					{/* 2. AVATAR - Using EntityIcon component */}
					<div className='hidden md:flex md:items-end'>
						<EntityIcon
							type={typeLabel.toLowerCase()}
							customIconUrl={avatarUrl}
							size={32}
							showBackground
							className='w-16 h-16 shadow-md'
						/>
					</div>

					{/* Title & Status */}
					<div className='flex-1'>
						<div className='flex items-center flex-wrap gap-2 mb-1.5'>
							{/* Type Badge */}
							<EntityBadge type={typeLabel.toLowerCase()} size='sm' variant='solid' />

							{/* Status Badge */}
							{status.hasStatus && (
								<span
									className={clsx(
										'px-1.5 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider border shadow-sm',
										status.isDead
											? 'border-red-600 text-red-700 bg-red-50'
											: 'border-emerald-600 text-emerald-700 bg-emerald-50'
									)}>
									{status.label}
								</span>
							)}

							{/* Priority Badge (For Quests) */}
							{priority && (
								<span
									className={clsx(
										'px-1.5 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider border shadow-sm',
										getPriorityStyles(priority) // Use centralized logic
									)}>
									{priority} Priority
								</span>
							)}

							{/* Extra Tags */}
							{extraTags &&
								extraTags.map((tag, i) => (
									<span
										key={i}
										className='px-1.5 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider border shadow-sm bg-white/80 border-slate-300 text-slate-700'>
										{tag}
									</span>
								))}
						</div>
						<h1 className='text-3xl md:text-4xl font-serif font-bold text-foreground leading-none drop-shadow-sm'>
							{title}
						</h1>
					</div>
				</div>
			</div>
		</div>
	);
};

--- END OF features\entity-view\components\EntityHeader.jsx ---

--- FILE: features\entity-view\components\EntityHistory.jsx ---
import { Calendar } from 'lucide-react';
import { clsx } from 'clsx';
import SmartMarkdown from '../../smart-text/SmartMarkdown';

export const EntityHistory = ({ events, showSession = true, fullHeight = true }) => {
	if (!events || events.length === 0) return null;

	return (
		// 1. Container Logic
		// If fullHeight is true, we allow the div to expand naturally.
		// If false, we clamp it to 600px with a scrollbar.
		<div className={clsx(!fullHeight && 'max-h-[600px] overflow-y-auto custom-scrollbar pr-2')}>
			{/* 2. Timeline Container */}
			{/* ml-5 pushes the border line right, creating a safe gutter for the dots (-left-[19px]) 
                so they don't get clipped by overflow:hidden or scroll containers */}
			<div className='border-l-2 border-border ml-2 pl-3 space-y-6 relative my-2'>
				{events.map((evt, idx) => (
					<div key={evt.id || idx} className='relative group'>
						{/* Timeline Dot */}
						<div
							className={clsx(
								'absolute -left-[19px] top-1.5 w-3 h-3 rounded-full border border-background',
								'bg-stone-300 ring-1 ring-border',
								'group-hover:bg-accent group-hover:ring-accent/40 transition-colors shadow-sm'
							)}
						/>

						{/* Title Row with Session Badge */}
						<div className='flex items-center gap-2 mb-1 flex-wrap'>
							<h4 className='font-bold text-foreground text-sm mt-0.5'>{evt.title}</h4>
							{showSession && evt.session_number != null && (
								<span className='inline-flex items-center gap-1 text-[9px] font-bold uppercase tracking-wider px-2 py-0.5 rounded border ml-auto max-w-[45%] truncate bg-stone-100 text-stone-500 border-stone-200/60'>
									<Calendar size={9} />
									Session {evt.session_number}
								</span>
							)}
						</div>

						{/* Description */}
						<div className='text-sm text-muted-foreground leading-relaxed text-justify'>
							<SmartMarkdown>{evt.description}</SmartMarkdown>
						</div>
					</div>
				))}
			</div>
		</div>
	);
};

--- END OF features\entity-view\components\EntityHistory.jsx ---

--- FILE: features\entity-view\components\EntitySidebar.jsx ---
import { useMemo } from 'react';
import { Tag, Network, Shield, Activity } from 'lucide-react';
import { clsx } from 'clsx';
import EntityIcon from '../../../components/entity/EntityIcon';
import EntityLink from '../../../components/entity/EntityLink';
import { capitalize, toTitleCase } from '../../../utils/text/textProcessing';

// --- SUB-COMPONENTS ---
const AbilityGrid = ({ stats }) => (
	<div className='grid grid-cols-3 gap-2 mt-2 mb-4'>
		{stats.map((stat, i) => (
			<div
				key={i}
				className='bg-white/60 border border-stone-200/80 rounded p-1.5 text-center flex flex-col items-center shadow-sm backdrop-blur-sm'>
				<span className='text-[9px] font-bold text-stone-400 uppercase tracking-widest leading-none'>{stat.name}</span>
				<span className='text-lg font-bold text-stone-800 leading-none my-1 font-serif'>{stat.score}</span>
				<span className='text-[10px] font-medium text-stone-500 bg-stone-100 px-1.5 rounded-full'>{stat.mod}</span>
			</div>
		))}
	</div>
);

const TagList = ({ tags }) => (
	<div className='flex flex-wrap gap-1.5 mt-1 mb-3'>
		{tags.map((item, i) => (
			<span
				key={i}
				className='inline-flex items-center px-2 py-0.5 rounded text-[11px] font-semibold bg-stone-100 text-stone-700 border border-stone-200/60 shadow-sm'>
				{toTitleCase(item)} {/* Changed to toTitleCase for consisteny */}
			</span>
		))}
	</div>
);

const StandardTrait = ({ label, value, index }) => (
	<div
		className={clsx(
			'flex justify-between items-baseline px-3 py-2 border-b border-stone-200/40 last:border-0',
			index % 2 === 0 ? 'bg-white/40' : 'bg-transparent'
		)}>
		<span className='text-[10px] font-bold uppercase tracking-widest text-stone-500/90 shrink-0 mr-4'>{label}</span>
		<span className='text-[13px] font-semibold text-stone-800 text-right leading-snug break-words'>
			{/* Changed to toTitleCase to handle "alive" -> "Alive", "neutral good" -> "Neutral Good" */}
			{typeof value === 'string' ? toTitleCase(value) : value}
		</span>
	</div>
);

// --- HELPER: Connection Badge Colors ---
const getRoleStyle = (roleStr) => {
	const r = roleStr?.toLowerCase() || '';

	if (r.includes('enemy') || r.includes('threat') || r.includes('hostile')) {
		return 'bg-red-50 text-red-700 border-red-200/60';
	}
	if (r.includes('ally') || r.includes('allied') || r.includes('friend')) {
		return 'bg-emerald-50 text-emerald-700 border-emerald-200/60';
	}
	if (r.includes('ruled') || r.includes('leader') || r.includes('captain')) {
		return 'bg-amber-50 text-amber-700 border-amber-200/60';
	}
	return 'bg-stone-100 text-stone-500 border-stone-200/60';
};

// --- NEW COMPONENT: Type Divider ---
const TypeDivider = ({ label }) => (
	<div className='flex items-center gap-2 my-3'>
		<div className='h-px bg-stone-200 flex-1' />
		<span className='text-[9px] font-bold text-stone-400 uppercase tracking-widest'>{label}</span>
		<div className='h-px bg-stone-200 flex-1' />
	</div>
);

// --- MAIN COMPONENT ---
export const EntitySidebar = ({ traits, connections }) => {
	const textTraits = traits.filter((t) => t.displayType === 'text');
	const specialTraits = traits.filter((t) => t.displayType !== 'text');

	// Group connections by Type Label
	const groupedConnections = useMemo(() => {
		if (!connections || connections.length === 0) return [];

		// 1. Sort by Type, then Name
		const sorted = [...connections].sort((a, b) => {
			const typeA = a.typeLabel || 'Other';
			const typeB = b.typeLabel || 'Other';
			const compareType = typeA.localeCompare(typeB);
			if (compareType !== 0) return compareType;
			return (a.name || '').localeCompare(b.name || '');
		});

		// 2. Group for rendering
		const groups = [];
		let currentType = null;
		let currentGroup = null;

		sorted.forEach((item) => {
			const type = item.typeLabel || 'Other';
			if (type !== currentType) {
				currentType = type;
				currentGroup = { type, items: [] };
				groups.push(currentGroup);
			}
			currentGroup.items.push(item);
		});

		return groups;
	}, [connections]);

	return (
		<div className='space-y-6 font-sans'>
			{/* 1. Standard Traits Table */}
			{textTraits.length > 0 && (
				<div className='bg-stone-50/50 border border-stone-200 rounded-lg overflow-hidden'>
					{/* Header */}
					<div className='px-3 py-2 border-b border-stone-200 bg-stone-100/40 flex items-center gap-2'>
						<Tag size={12} className='text-amber-700' />
						<h3 className='text-[11px] font-bold text-amber-900/80 uppercase tracking-widest'>Attributes</h3>
					</div>

					{/* Content */}
					<div className='flex flex-col'>
						{textTraits.map((prop, idx) => (
							<StandardTrait key={prop.key} label={prop.key} value={prop.value} index={idx} />
						))}
					</div>
				</div>
			)}

			{/* 2. Special Visual Blocks */}
			{specialTraits.length > 0 && (
				<div className='space-y-4 px-1'>
					{specialTraits.map((prop) => {
						if (prop.displayType === 'stat-grid') {
							return (
								<div key={prop.key}>
									<h3 className='text-[10px] font-bold text-stone-400 uppercase tracking-wider mb-1 flex items-center gap-2 ml-1'>
										<Activity size={10} /> {prop.key}
									</h3>
									<AbilityGrid stats={prop.value} />
								</div>
							);
						}
						if (prop.displayType === 'tags') {
							return (
								<div key={prop.key}>
									<h3 className='text-[10px] font-bold text-stone-400 uppercase tracking-wider mb-1 flex items-center gap-2 ml-1'>
										<Shield size={10} /> {prop.key}
									</h3>
									<TagList tags={prop.value} />
								</div>
							);
						}
						return null;
					})}
				</div>
			)}

			{/* 3. Connections (Grouped with Dividers) */}
			{groupedConnections.length > 0 && (
				<div>
					<h3 className='text-[10px] font-bold text-stone-400 uppercase tracking-wider mb-2 flex items-center gap-2 px-1'>
						<Network size={10} /> Connections
					</h3>

					<div className='space-y-1'>
						{groupedConnections.map((group, gIdx) => (
							<div key={group.type}>
								{/* Divider (skip for first one if desired, currently showing for all as per design pattern) */}
								<TypeDivider label={group.type} />

								<div className='space-y-2'>
									{group.items.map((rel, i) => (
										<EntityLink
											key={rel.id}
											id={rel.id}
											type={rel.typeLabel}
											inline={true}
											showIcon={false}
											className={clsx(
												'!flex !w-full !items-center !justify-between !p-2 !rounded-lg !border !bg-white/60 !transition-all !cursor-pointer !no-underline',
												'!border-stone-200 hover:!border-amber-300 hover:!shadow-sm hover:!bg-white',
												rel.theme.hover
											)}>
											<div className='flex items-center gap-2.5 flex-1 min-w-0'>
												<EntityIcon type={rel.typeLabel} size={14} className='opacity-80 group-hover:opacity-100' />
												<span className='text-sm font-semibold text-stone-700 truncate group-hover:text-foreground transition-colors'>
													{rel.name}
												</span>
											</div>
											<span
												className={clsx(
													'shrink-0 text-[9px] font-bold uppercase tracking-wider px-2 py-0.5 rounded border ml-2 max-w-[45%] truncate',
													getRoleStyle(rel.role)
												)}>
												{rel.role}
											</span>
										</EntityLink>
									))}
								</div>
							</div>
						))}
					</div>
				</div>
			)}
		</div>
	);
};

--- END OF features\entity-view\components\EntitySidebar.jsx ---

--- FILE: features\entity-view\components\QuestObjectives.jsx ---
import { useState } from 'react';
import {
	CheckCircle2,
	Circle,
	XCircle,
	Target,
	Calendar,
	ChevronDown,
	ChevronRight,
	CornerDownRight,
} from 'lucide-react';
import { clsx } from 'clsx';
import SmartMarkdown from '../../smart-text/SmartMarkdown';
import EntityLink from '../../../components/entity/EntityLink';

const QuestObjectiveItem = ({ obj }) => {
	const [isOpen, setIsOpen] = useState(false);

	const isCompleted = obj.status === 'completed';
	const isFailed = obj.status === 'failed';

	const hasUpdate = !!obj.objective_update;
	const hasSession = isCompleted && obj.completed_session_number;
	const hasContent = hasUpdate || (hasSession && obj.completed_session_title);

	const toggle = () => hasContent && setIsOpen(!isOpen);

	return (
		<div
			className={clsx(
				'transition-colors border-b border-border/40 last:border-0',
				isCompleted ? 'bg-emerald-50/10' : isFailed ? 'bg-red-50/10' : 'hover:bg-muted/30'
			)}>
			{/* --- MAIN ROW --- */}
			<div
				className={clsx(
					'flex items-start gap-3 px-3 py-2 cursor-pointer group',
					hasContent ? 'hover:bg-black/5' : 'cursor-default'
				)}
				onClick={toggle}>
				{/* Status Icon */}
				<div className='mt-1.5 shrink-0'>
					{isCompleted ? (
						<CheckCircle2 size={16} className='text-emerald-600' />
					) : isFailed ? (
						<XCircle size={16} className='text-red-500' />
					) : (
						<Circle size={16} className='text-muted-foreground/40' strokeWidth={2} />
					)}
				</div>

				{/* Text Content */}
				<div className='flex-1 min-w-0 pt-0.5'>
					<div className='flex items-center justify-between gap-2 mb-0.5'>
						{obj.objective_name && (
							<div className='text-[10px] font-bold text-muted-foreground/70 uppercase tracking-wide'>
								{obj.objective_name}
							</div>
						)}

						{/* Session Indicator Badge (Inline) */}
						{hasSession && (
							<div
								className='flex items-center gap-1 px-1.5 py-0.5 rounded text-[9px] font-bold uppercase tracking-wider bg-stone-100 text-stone-500 border border-stone-200/60'
								title={`Completed in Session ${obj.completed_session_number}`}>
								<Calendar size={10} />
								<span className='hidden sm:inline'>Session</span> {obj.completed_session_number}
							</div>
						)}
					</div>

					<div
						className={clsx(
							'text-[13px] leading-snug font-medium transition-colors',
							isCompleted ? 'text-stone-600' : isFailed ? 'text-red-800/80' : 'text-foreground'
						)}>
						<SmartMarkdown components={{ p: 'span' }}>{obj.description}</SmartMarkdown>
					</div>
				</div>

				{/* Toggle Chevron */}
				{hasContent && (
					<button
						className={clsx(
							'shrink-0 text-gray-400 group-hover:text-foreground transition-colors mt-0.5',
							isOpen && 'text-foreground'
						)}>
						{isOpen ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
					</button>
				)}
			</div>

			{/* --- DROPDOWN CONTENT --- */}
			{isOpen && hasContent && (
				<div className='pl-9 pr-3 pb-2 -mt-1 animate-in slide-in-from-top-1 fade-in duration-200'>
					<div className='flex flex-col gap-1.5'>
						{/* Update Text */}
						{hasUpdate && (
							<div className='flex gap-2 items-start'>
								<CornerDownRight size={12} className='shrink-0 mt-1 text-accent opacity-60' />
								<span className='text-xs text-stone-600 italic leading-relaxed'>
									<SmartMarkdown>{obj.objective_update}</SmartMarkdown>
								</span>
							</div>
						)}
					</div>
				</div>
			)}
		</div>
	);
};

export const QuestObjectives = ({ objectives }) => {
	if (!objectives || objectives.length === 0) return null;

	return (
		<div className='mb-8 not-prose border border-stone-200 rounded-lg overflow-hidden bg-stone-50/20'>
			<div className='px-3 py-2 border-b border-stone-200 bg-stone-100/50 flex items-center gap-2'>
				<h3 className='text-[10px] font-bold text-muted-foreground uppercase tracking-wider flex items-center gap-2 m-0'>
					<Target size={12} className='text-accent' /> Quest Objectives
				</h3>
				<span className='ml-auto text-[9px] font-bold bg-stone-200/60 px-1.5 py-0.5 rounded text-stone-500'>
					{objectives.filter((o) => o.status === 'completed').length} / {objectives.length}
				</span>
			</div>

			<div className='bg-background'>
				{objectives.map((obj, idx) => (
					<QuestObjectiveItem key={obj.id || idx} obj={obj} />
				))}
			</div>
		</div>
	);
};

--- END OF features\entity-view\components\QuestObjectives.jsx ---

--- FILE: features\entity-view\components\SessionMentions.jsx ---
import { clsx } from 'clsx';
import { getEntityConfig } from '../../../config/entity';
import EntityLink from '../../../components/entity/EntityLink';
import EntityIcon from '../../../components/entity/EntityIcon';

const MentionGroup = ({ type, items }) => {
	const config = getEntityConfig(type);
	const Icon = config.icon;

	return (
		<div className='border border-stone-200 rounded-lg overflow-hidden bg-stone-50/30 flex flex-col'>
			{/* Header */}
			<div className='px-3 py-2 border-b border-stone-200 bg-stone-100/50 flex items-center justify-between shrink-0'>
				<div className='flex items-center gap-2'>
					<Icon size={12} className='text-stone-500' />
					<h3 className='text-[10px] font-bold text-stone-500 uppercase tracking-widest m-0'>{config.labelPlural}</h3>
				</div>
				<span className='text-[9px] font-bold text-stone-400 bg-stone-200/50 px-1.5 py-0.5 rounded-full'>
					{items.length}
				</span>
			</div>

			{/* List Container - Reverted to Vertical Column */}
			<div className='p-2'>
				<div className='flex flex-col gap-1.5'>
					{items.map((item) => (
						<EntityLink
							key={item.id}
							id={item.id}
							type={item.type}
							inline={true} // Use inline mode to get a cleaner DOM structure (A -> SPAN)
							showIcon={false} // We provide our own icon in the children for custom styling
							className={clsx(
								// Override generic InlineLink styles to make it look like a card
								'!block !w-full !no-underline !border',
								'!bg-white/60 !border-stone-200/80 !rounded-md',
								'!px-2 !py-1.5',
								// Colors
								'!text-stone-700 hover:!text-foreground',
								// Hover states
								'hover:!bg-white hover:!border-amber-300 hover:!shadow-sm transition-all'
							)}>
							{/* Inner Layout Wrapper to handle Flex behavior correctly */}
							<span className='flex items-center gap-2.5 min-w-0'>
								<EntityIcon type={item.type} size={14} className='opacity-70 text-stone-500 shrink-0' />
								<span className='text-[13px] font-semibold truncate'>{item.name}</span>
							</span>
						</EntityLink>
					))}
				</div>
			</div>
		</div>
	);
};

export const SessionMentions = ({ mentions }) => {
	if (!mentions || Object.keys(mentions).length === 0) {
		return (
			<div className='p-12 text-center text-stone-400 italic border border-dashed border-stone-200 rounded-lg'>
				No linked entities found in this session.
			</div>
		);
	}

	const order = ['character', 'npc', 'location', 'faction', 'quest', 'encounter'];
	const orderedKeys = order.filter((k) => mentions[k]).concat(Object.keys(mentions).filter((k) => !order.includes(k)));

	return (
		<div className='columns-1 md:columns-2 xl:columns-3 gap-4'>
			{orderedKeys.map((key) => (
				<div key={key} className='break-inside-avoid mb-4'>
					<MentionGroup type={key} items={mentions[key]} />
				</div>
			))}
		</div>
	);
};

--- END OF features\entity-view\components\SessionMentions.jsx ---

--- FILE: features\entity-view\hooks\useEntityContent.js ---
import { useMemo } from 'react';
import { isSession } from '../../../utils/entity/entityHelpers';
import { transformEvents } from '../transforms/eventTransform';
import { getAttributeValue } from '../../../utils/entity/attributeParser';

/**
 * Helper: Extract and group mentioned entities from events and direct relationships
 */
const extractMentions = (entity) => {
	const mentionsMap = new Map();

	// 1. Gather from direct relationships
	if (entity.relationships) {
		entity.relationships.forEach((rel) => {
			if (!rel.entity_id) return;
			mentionsMap.set(rel.entity_id, {
				id: rel.entity_id,
				name: rel.entity_name,
				type: rel.entity_type,
			});
		});
	}

	// 2. Gather from Events (tags)
	if (entity.events) {
		entity.events.forEach((evt) => {
			if (evt.relationships) {
				evt.relationships.forEach((rel) => {
					if (!rel.entity_id) return;
					mentionsMap.set(rel.entity_id, {
						id: rel.entity_id,
						name: rel.entity_name,
						type: rel.entity_type,
					});
				});
			}
		});
	}

	// 3. Group by Type
	const groups = {
		character: [],
		npc: [],
		location: [],
		faction: [],
		quest: [],
		encounter: [],
		other: [],
	};

	mentionsMap.forEach((item) => {
		const type = item.type?.toLowerCase() || 'other';
		if (groups[type]) {
			groups[type].push(item);
		} else {
			groups.other.push(item);
		}
	});

	// 4. Sort each group alphabetically
	Object.keys(groups).forEach((key) => {
		groups[key].sort((a, b) => a.name.localeCompare(b.name));
	});

	// 5. Remove empty groups
	Object.keys(groups).forEach((key) => {
		if (groups[key].length === 0) delete groups[key];
	});

	return groups;
};

export const useEntityContent = (entity, attributes, sections) => {
	return useMemo(() => {
		if (!entity) return null;

		const entityIsSession = isSession(entity);
		const entityIsQuest = entity.type === 'quest';

		// Determine main summary
		let mainSummary = attributes.Summary || entity.summary;
		if (!mainSummary && !entityIsSession) {
			mainSummary = entity.description;
		}

		// Process events
		const events = transformEvents(entity.events);

		// Process Mentions (for Sessions)
		const mentions = entityIsSession ? extractMentions(entity) : null;

		// NEW: Extract Level Up
		const levelUp = getAttributeValue(attributes, ['level_up', 'Level Up', 'levelup']);

		return {
			objectives: entityIsQuest ? entity.objectives || [] : null,
			narrative: entityIsSession ? entity.description || '' : null,
			summary: mainSummary || '',
			sections: sections || [],
			history: events,
			mentions,
			levelUp, // Added to return object
		};
	}, [entity, attributes, sections]);
};

--- END OF features\entity-view\hooks\useEntityContent.js ---

--- FILE: features\entity-view\hooks\useEntityHeader.js ---
/**
 * useEntityHeader Hook
 * Builds header view model from entity data
 */

import { useMemo } from 'react';
import { getEntityConfig } from '../../../config/entity';
import { resolveImageUrl } from '../../../utils/image/imageResolver';
import { getAttributeValue } from '../../../utils/entity/attributeParser';
import { extractHeaderTags } from '../transforms/attributeTransform';
import { capitalize } from '../../../utils/text/textProcessing';

/**
 * Build header view model
 * @param {Object} entity - Raw entity data
 * @param {Object} attributes - Parsed attributes
 * @returns {Object} Header view model
 */
export const useEntityHeader = (entity, attributes) => {
	return useMemo(() => {
		if (!entity) return null;

		const config = getEntityConfig(entity.type);

		// Resolve images
		const headerBackgroundUrl = resolveImageUrl(attributes, 'background');
		const avatarUrl = resolveImageUrl(attributes, 'icon');

		// Resolve status
		let statusRaw = entity.status || getAttributeValue(attributes, ['status']);
		if (Array.isArray(statusRaw)) {
			statusRaw = statusRaw.join(', ');
		}
		if (statusRaw && typeof statusRaw !== 'string') {
			statusRaw = String(statusRaw);
		}

		// Resolve Priority (New)
		const priorityRaw = getAttributeValue(attributes, ['priority', 'Priority']);

		// Extract extra tags (session-specific)
		const extraTags = extractHeaderTags(attributes, entity.type);

		return {
			title: entity.name,
			typeLabel: entity.type?.toUpperCase(),
			imageUrl: headerBackgroundUrl,
			avatarUrl: avatarUrl,
			status: {
				hasStatus: !!statusRaw,
				label: statusRaw ? capitalize(statusRaw) : '',
				isDead: statusRaw?.toLowerCase() === 'dead' || statusRaw?.toLowerCase() === 'failed',
			},
			priority: priorityRaw ? capitalize(priorityRaw) : null,
			extraTags,
			theme: {
				...config.tailwind,
				Icon: config.icon,
			},
		};
	}, [entity, attributes]);
};

--- END OF features\entity-view\hooks\useEntityHeader.js ---

--- FILE: features\entity-view\hooks\useEntitySidebar.js ---
/**
 * useEntitySidebar Hook
 * Builds sidebar view model from entity data
 */

import { useMemo } from 'react';
import { transformRelationships } from '../transforms/relationshipTransform';

/**
 * Build sidebar view model
 * @param {Object} entity - Raw entity data
 * @param {Array} traits - Traits from attribute transform
 * @returns {Object} Sidebar view model
 */
export const useEntitySidebar = (entity, traits) => {
	return useMemo(() => {
		if (!entity) return null;

		const connections = transformRelationships(entity.relationships, 50);

		return {
			traits: traits || [],
			connections,
		};
	}, [entity, traits]);
};

--- END OF features\entity-view\hooks\useEntitySidebar.js ---

--- FILE: features\entity-view\layouts\index.js ---
/**
 * Entity View Layouts
 * Different layout patterns for different entity types
 */

export { default as StandardLayout } from './StandardLayout';
export { default as SessionLayout } from './SessionLayout';
export { default as EncounterLayout } from './EncounterLayout';

--- END OF features\entity-view\layouts\index.js ---

--- FILE: features\entity-view\layouts\SessionLayout.jsx ---
import { useState, useMemo } from 'react';
import { BookOpen, History, Network } from 'lucide-react';
import TabContainer from '../../../components/layout/TabContainer';
import { EntityBody, EntityHistory } from '../components/EntityBody';
import { SessionMentions } from '../components/SessionMentions';
import { TableOfContents } from '../../table-of-contents/TableOfContents';
import { extractHeaders } from '../../../utils/text/markdownHelpers';
import { ThreeColumnLayout } from '../../../components/layout/SplitView';

export default function SessionLayout({ viewModel }) {
	const [activeTab, setActiveTab] = useState('narrative');

	if (!viewModel) return null;

	const tocItems = useMemo(() => {
		if (viewModel.content.narrative) {
			return extractHeaders(viewModel.content.narrative);
		}
		return [];
	}, [viewModel.content.narrative]);

	const renderNarrative = () => (
		<ThreeColumnLayout
			left={null}
			center={
				<div className='max-w-3xl mx-auto px-4 sm:px-6 py-10'>
					<EntityBody
						summary={viewModel.content.narrative}
						sections={[]}
						history={null}
						levelUp={viewModel.content.levelUp} // Pass new prop
					/>
				</div>
			}
			right={
				tocItems.length > 0 ? (
					<TableOfContents
						items={tocItems}
						className='ml-4'
						visibilityClass='hidden min-[1650px]:block'
						mobileToggleClass='min-[1650px]:hidden'
					/>
				) : null
			}
		/>
	);

	const renderMentions = () => (
		<div className='max-w-7xl mx-auto px-4 sm:px-6 py-10'>
			<SessionMentions mentions={viewModel.content.mentions} />
		</div>
	);

	const renderTimeline = () => (
		<div className='max-w-3xl mx-auto px-4 sm:px-6 py-10'>
			<EntityHistory events={viewModel.content.history} fullHeight={true} />
		</div>
	);

	return (
		<>
			<TabContainer
				tabs={[
					{
						id: 'narrative',
						label: 'Narrative',
						icon: BookOpen,
						content: renderNarrative(),
					},
					{
						id: 'mentions',
						label: 'Mentions',
						icon: Network,
						content: renderMentions(),
					},
					{
						id: 'events',
						label: 'Timeline',
						icon: History,
						content: renderTimeline(),
					},
				]}
				defaultTab='narrative'
				sticky
				onChange={setActiveTab}
			/>

			{tocItems.length > 0 && activeTab === 'narrative' && (
				<div className='xl:hidden'>
					<TableOfContents items={tocItems} />
				</div>
			)}
		</>
	);
}

--- END OF features\entity-view\layouts\SessionLayout.jsx ---

--- FILE: features\entity-view\layouts\StandardLayout.jsx ---
/**
 * StandardLayout Component
 * Layout for NPCs, Locations, Items, Factions (sidebar + main content)
 */

import { EntitySidebar } from '../components/EntitySidebar';
import { EntityBody } from '../components/EntityBody';

/**
 * Standard entity layout with sidebar and main content
 * @param {Object} viewModel - Entity view model
 */
export default function StandardLayout({ viewModel }) {
	if (!viewModel) return null;

	return (
		<div className='w-full px-4 sm:px-6 py-10'>
			<div className='max-w-6xl mx-auto'>
				<div className='grid grid-cols-1 lg:grid-cols-[260px_1fr] xl:grid-cols-[280px_1fr] gap-4 lg:gap-6 xl:gap-8'>
					{/* Sidebar */}
					<div className='lg:order-first min-w-0'>
						<EntitySidebar traits={viewModel.sidebar.traits} connections={viewModel.sidebar.connections} />
					</div>

					{/* Main Content */}
					<div className='min-w-0'>
						<EntityBody
							summary={viewModel.content.summary}
							sections={viewModel.content.sections}
							history={viewModel.content.history}
							objectives={viewModel.content.objectives}
						/>
					</div>
				</div>
			</div>
		</div>
	);
}

--- END OF features\entity-view\layouts\StandardLayout.jsx ---

--- FILE: features\entity-view\pages\WikiEntryPage.jsx ---
import { useParams } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { getWikiEntry } from '../../../services/entities';
import { transformWikiEntry } from '../transforms/wikiEntryTransform'; // Import transform
import WikiEntityView from '../WikiEntityView';
import LoadingSpinner from '../../../components/ui/LoadingSpinner';

export default function WikiEntryPage() {
	const { type, entityId } = useParams();
	const normalizedType = type === 'sessions' ? 'session' : type;

	const {
		data: entity,
		isLoading,
		error,
	} = useQuery({
		queryKey: ['entry', normalizedType, entityId],
		queryFn: () => getWikiEntry(entityId, normalizedType),
		select: (res) => transformWikiEntry(res.data, res.type, res.additional),
		enabled: !!entityId && !!normalizedType,
		retry: 1,
	});

	if (isLoading) return <LoadingSpinner className='h-full min-h-[50vh]' text='Loading Entry...' />;
	if (error)
		return (
			<div className='p-8 text-center text-red-600'>
				<p>Failed to load entry</p>
			</div>
		);

	return <WikiEntityView entity={entity} />;
}

--- END OF features\entity-view\pages\WikiEntryPage.jsx ---

--- FILE: features\entity-view\transforms\attributeTransform.js ---
/**
 * Attribute Transform Functions
 * Pure functions for processing entity attributes into view model format
 */

import {
	parseAttributeValue,
	parseAbilityScores,
	parseTagList,
	isIgnoredAttribute,
	isNarrativeAttribute,
	isListAttribute,
} from '../../../utils/entity/attributeParser';

/**
 * Determine if an attribute should go to sidebar or main content
 * @param {string} key - Attribute key
 * @param {*} value - Attribute value
 * @returns {'sidebar'|'main'|'ignore'}
 */
const getAttributeDestination = (key, value) => {
	const normalizedKey = key.toLowerCase();

	if (isIgnoredAttribute(normalizedKey)) {
		return 'ignore';
	}

	// Special widgets always go to sidebar
	if (
		['abilities', 'stats', 'ability score', 'saving throw', 'saves', 'skills', 'languages', 'proficiencies'].includes(
			normalizedKey
		)
	) {
		return 'sidebar';
	}

	// Lists always go to main content
	if (isListAttribute(normalizedKey) && Array.isArray(value)) {
		return 'main';
	}

	// Narrative text goes to main
	if (isNarrativeAttribute(normalizedKey)) {
		return 'main';
	}

	// Long text goes to main
	if (typeof value === 'string' && value.length > 100) {
		return 'main';
	}

	// Everything else to sidebar
	return 'sidebar';
};

/**
 * Process special widget attributes (ability scores, tags)
 * @param {string} key - Attribute key
 * @param {*} value - Raw attribute value
 * @returns {Object|null} Processed trait or null
 */
const processSpecialWidget = (key, value) => {
	const normalizedKey = key.toLowerCase();

	// Ability scores / stats
	if (['abilities', 'stats'].includes(normalizedKey)) {
		const strVal = parseAttributeValue(value);
		return {
			key,
			value: parseAbilityScores(strVal),
			displayType: 'stat-grid',
		};
	}

	// Tag lists
	if (['ability score', 'saving throw', 'saves', 'skills', 'languages', 'proficiencies'].includes(normalizedKey)) {
		const strVal = parseAttributeValue(value);
		return {
			key,
			value: parseTagList(strVal),
			displayType: 'tags',
		};
	}

	return null;
};

/**
 * Transform attributes into sidebar traits and main content sections
 * @param {Object} attributes - Parsed attributes object
 * @param {string} entityDescription - Entity description (to avoid duplication)
 * @returns {{traits: Array, sections: Array}}
 */
export const transformAttributes = (attributes, entityDescription = '') => {
	const traits = [];
	const sections = [];

	Object.entries(attributes).forEach(([key, rawVal]) => {
		// 1. Check for special widgets first
		const widget = processSpecialWidget(key, rawVal);
		if (widget) {
			traits.push(widget);
			return;
		}

		// 2. Parse value
		const displayVal = parseAttributeValue(rawVal, key);
		if (!displayVal) return;

		// 3. Skip if it's the same as description
		const normalizedKey = key.toLowerCase();
		if (normalizedKey === 'description' && displayVal === entityDescription) {
			return;
		}

		// 4. Determine destination
		const destination = getAttributeDestination(key, displayVal);
		if (destination === 'ignore') return;

		// 5. Route to appropriate collection
		if (destination === 'main') {
			// Lists stay as arrays
			if (isListAttribute(normalizedKey) && Array.isArray(displayVal)) {
				sections.push({
					key,
					value: displayVal,
					displayType: 'list',
				});
			} else {
				// Join arrays into text for narrative
				const textValue = Array.isArray(displayVal) ? displayVal.join('\n\n') : displayVal;
				sections.push({
					key,
					value: textValue,
					displayType: 'narrative',
				});
			}
		} else {
			// Sidebar trait
			const textValue = Array.isArray(displayVal) ? displayVal.join(', ') : displayVal;
			traits.push({
				key,
				value: textValue,
				displayType: 'text',
			});
		}
	});

	return { traits, sections };
};

/**
 * Extract extra tags for entity header (session-specific)
 * @param {Object} attributes - Parsed attributes
 * @param {string} entityType - Entity type
 * @returns {string[]}
 */
export const extractHeaderTags = (attributes, entityType) => {
	const tags = [];

	if (entityType === 'session') {
		if (attributes.Session) {
			tags.push(`Session ${attributes.Session}`);
		}
		if (attributes.Date) {
			tags.push(attributes.Date);
		}
	}

	return tags;
};

--- END OF features\entity-view\transforms\attributeTransform.js ---

--- FILE: features\entity-view\transforms\eventTransform.js ---
/**
 * Event Transform Functions
 * Pure functions for processing entity events/history into view model format
 */

/**
 * Parse events from various formats
 * @param {Array|Object} events - Raw events data
 * @returns {Array}
 */
export const parseEvents = (events) => {
	if (!events) return [];

	// Already an array
	if (Array.isArray(events)) {
		return events;
	}

	// Object grouped by type (flatten it)
	if (typeof events === 'object') {
		return Object.values(events).flat();
	}

	return [];
};

/**
 * Transform events into history view model
 * Includes deduplication to prevent React key errors
 * @param {Array|Object} events - Raw events
 * @returns {Array}
 */
export const transformEvents = (events) => {
	const parsed = parseEvents(events);

	// 1. Deduplicate by ID using a Map
	const uniqueEventsMap = new Map();
	parsed.forEach((evt) => {
		if (evt && evt.id) {
			uniqueEventsMap.set(evt.id, evt);
		} else if (evt) {
			// Handle events without IDs (fallback)
			uniqueEventsMap.set(Math.random().toString(), evt);
		}
	});

	// 2. Transform values
	return Array.from(uniqueEventsMap.values()).map((event) => ({
		id: event.id || Math.random().toString(),
		title: event.title || 'Untitled Event',
		description: event.description || '',
		session_number: event.session_number,
		order: event.order || event.event_order || 0,
	}));
};

--- END OF features\entity-view\transforms\eventTransform.js ---

--- FILE: features\entity-view\transforms\relationshipTransform.js ---
/**
 * Relationship Transform Functions
 * Pure functions for processing entity relationships into view model format
 */

import { getEntityConfig } from '../../../config/entity';

/**
 * Parse relationships from various formats
 * @param {string|Array|Object} relationships - Raw relationships data
 * @returns {Array}
 */
export const parseRelationships = (relationships) => {
	if (!relationships) return [];

	// Already an array
	if (Array.isArray(relationships)) {
		return relationships;
	}

	// String (JSON)
	if (typeof relationships === 'string') {
		try {
			return JSON.parse(relationships);
		} catch {
			return [];
		}
	}

	// Object (convert to array)
	if (typeof relationships === 'object') {
		return Object.values(relationships);
	}

	return [];
};

/**
 * Transform relationships into connection view models
 * @param {Array} relationships - Parsed relationships
 * @param {number} maxConnections - Maximum connections to show (default 8)
 * @returns {Array}
 */
export const transformRelationships = (relationships, maxConnections = 8) => {
	const parsed = parseRelationships(relationships);

	return parsed
		.map((rel) => {
			const config = getEntityConfig(rel.entity_type);

			return {
				id: rel.entity_id || Math.random().toString(),
				name: rel.entity_name,
				typeLabel: rel.entity_type,
				role: formatRelationshipType(rel.type),
				theme: {
					...config.tailwind,
					Icon: config.icon,
				},
			};
		})
		.slice(0, maxConnections);
};

/**
 * Format relationship type for display
 * @param {string} type - Raw relationship type
 * @returns {string}
 */
const formatRelationshipType = (type) => {
	if (!type) return 'related';
	return type.toLowerCase().replace(/_/g, ' ');
};

--- END OF features\entity-view\transforms\relationshipTransform.js ---

--- FILE: features\entity-view\transforms\wikiEntryTransform.js ---
import { getAttributeValue, parseAttributes } from '../../../utils/entity/attributeParser';

const extractSessionMeta = (session, attributes = []) => {
	let attrs = attributes;
	if (Array.isArray(attrs)) {
		attrs = attrs.reduce((acc, curr) => {
			acc[curr.name] = curr.value;
			return acc;
		}, {});
	}
	attrs = attrs || {};

	const sessionNumber = getAttributeValue(attrs, ['session_number', 'Session', 'session']) || 999;
	const sessionDate = getAttributeValue(attrs, ['session_date', 'Date', 'date']) || '';

	return {
		...session,
		session_number: Number(sessionNumber),
		session_date: sessionDate,
		attributes: attrs,
	};
};

export const transformWikiEntry = (data, type, additionalData = {}) => {
	if (type === 'session') {
		const meta = extractSessionMeta(data, additionalData.attributes || []);
		const sortedEvents = (data.events || []).sort((a, b) => (a.event_order || 0) - (b.event_order || 0));

		// Attach relationships to events (passed from service)
		const eventRelMap = additionalData.eventRelMap || new Map();
		sortedEvents.forEach((evt) => {
			evt.relationships = eventRelMap.get(evt.id) || [];
		});

		return {
			id: data.id,
			name: data.title,
			type: 'session',
			description: getAttributeValue(meta.attributes, 'Summary') || data.narrative,
			attributes: {
				...meta.attributes,
				Session: meta.session_number,
				Date: meta.session_date,
			},
			relationships: additionalData.sessionRelationships || [],
			events: sortedEvents || [],
		};
	}

	// Standard Entity Transformation
	let entity = { ...data };

	// Quest Objectives
	if (type === 'quest' && additionalData.objectives) {
		// REFACTORED: Flatten session info for the view
		entity.objectives = additionalData.objectives.map((obj) => ({
			...obj,
			completed_session_number: obj.session?.session_number || null,
			completed_session_title: obj.session?.title || null,
		}));
	}

	// Event Processing
	let events = entity.events;
	if (events && typeof events === 'object' && !Array.isArray(events)) {
		events = Object.values(events).flat();
	}

	if (events && Array.isArray(events) && events.length > 0 && additionalData.sessionMap) {
		events = events.map((event) => ({
			...event,
			session_number:
				event.session_id && additionalData.sessionMap.has(event.session_id)
					? additionalData.sessionMap.get(event.session_id) - 1
					: null,
		}));

		events.sort((a, b) => {
			if (a.session_number !== b.session_number) {
				if (a.session_number == null) return 1;
				if (b.session_number == null) return -1;
				return a.session_number - b.session_number;
			}
			return (a.order || 0) - (b.order || 0);
		});
		entity.events = events;
	}

	return entity;
};

--- END OF features\entity-view\transforms\wikiEntryTransform.js ---

--- FILE: features\global-search\GlobalSearch.jsx ---
import { useRef, useEffect } from 'react';
import { SearchTrigger } from './components/SearchTrigger';
import { SearchModal } from './components/SearchModal';
import { useGlobalSearchViewModel } from './useGlobalSearchViewModel';

export default function GlobalSearch() {
	const vm = useGlobalSearchViewModel();
	const inputRef = useRef(null);

	// Focus input when opened
	useEffect(() => {
		if (vm.isOpen && inputRef.current) {
			inputRef.current.focus();
		}
	}, [vm.isOpen]);

	return (
		<>
			<SearchTrigger onClick={() => vm.setIsOpen(true)} />
			{vm.isOpen && <SearchModal vm={vm} inputRef={inputRef} />}
		</>
	);
}

--- END OF features\global-search\GlobalSearch.jsx ---

--- FILE: features\global-search\types.js ---
/**
 * @typedef {Object} SearchResult
 * @property {string} id
 * @property {string} name
 * @property {string} type
 * @property {string} description
 * @property {Object} attributes
 */

/**
 * @typedef {Object} SearchResultViewModel
 * @property {string} id
 * @property {string} name
 * @property {string} typeLabel
 * @property {string} description
 * @property {Object} icon - Lucide Icon Component
 * @property {Object} theme - Tailwind color classes
 */

/**
 * @typedef {Object} GlobalSearchViewModel
 * @property {boolean} isOpen
 * @property {function(boolean): void} setIsOpen
 * @property {string} query
 * @property {function(string): void} setQuery
 * @property {SearchResultViewModel[]} results
 * @property {boolean} isLoading
 * @property {SearchResultViewModel[]} recentSearches
 * @property {number} selectedIndex
 * @property {function(number): void} setSelectedIndex
 * @property {function(SearchResultViewModel): void} handleSelect
 * @property {function(): void} clearRecent
 */

export {};

--- END OF features\global-search\types.js ---

--- FILE: features\global-search\useGlobalSearchViewModel.js ---
import { useState, useEffect, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { useCampaign } from '../campaign-session/CampaignContext';
import { globalSearch } from '../../services/search';
import { getEntityConfig } from '../../config/entity';
import { transformSearchResults } from './transforms/searchTransform'; // Import transform
import './types';

const STORAGE_KEY = 'recent-searches';

/**
 * @returns {import('./types').GlobalSearchViewModel}
 */
export function useGlobalSearchViewModel() {
	const navigate = useNavigate();
	const { campaignId } = useCampaign();
	const [isOpen, setIsOpen] = useState(false);
	const [query, setQuery] = useState('');
	const [selectedIndex, setSelectedIndex] = useState(0);
	const [recentSearches, setRecentSearches] = useState(() => {
		try {
			const stored = localStorage.getItem(STORAGE_KEY);
			return stored ? JSON.parse(stored) : [];
		} catch {
			return [];
		}
	});

	// Fetch search results
	const { data: rawData, isLoading } = useQuery({
		queryKey: ['globalSearch', campaignId, query],
		queryFn: () => globalSearch(campaignId, query),
		enabled: !!campaignId && query.trim().length > 0,
		staleTime: 1000 * 30,
	});

	// Transform results to view model
	const results = useMemo(() => {
		if (!rawData) return [];
		// Apply Transform Layer here
		const processedItems = transformSearchResults(rawData);

		return processedItems.map((result) => {
			const config = getEntityConfig(result.type);
			return {
				id: result.id,
				name: result.name,
				type: result.type,
				typeLabel: result.type.toUpperCase(),
				description: result.description || '',
				icon: config.icon,
				theme: config.tailwind,
			};
		});
	}, [rawData]);

	const flattenedRawResults = useMemo(() => {
		if (!rawData) return [];
		const processedItems = transformSearchResults(rawData);
		return processedItems; // These have { id, name, type, description }
	}, [rawData]);

	// Transform recent searches to view model
	const recentSearchesViewModel = useMemo(() => {
		return recentSearches.map((result) => {
			const config = getEntityConfig(result.type);
			return {
				id: result.id,
				name: result.name,
				type: result.type,
				typeLabel: result.type.toUpperCase(),
				description: result.description || '',
				icon: config.icon,
				theme: config.tailwind,
			};
		});
	}, [recentSearches]);

	const handleSelect = (result) => {
		// Find the raw result from the flattened list
		const rawResult = flattenedRawResults.find((r) => r.id === result.id);

		if (rawResult) {
			// Store minimal data: id, name, type, description
			const toStore = {
				id: rawResult.id,
				name: rawResult.name,
				type: rawResult.type,
				description: rawResult.description || '',
			};

			const updated = [toStore, ...recentSearches.filter((r) => r.id !== toStore.id)].slice(0, 5);
			setRecentSearches(updated);

			try {
				localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
			} catch {
				// Ignore storage errors
			}
		}

		// Navigate
		navigate(`/wiki/${result.type}/${result.id}`);

		// Reset state
		setIsOpen(false);
		setQuery('');
		setSelectedIndex(0);
	};

	// Clear recent searches
	const clearRecent = () => {
		setRecentSearches([]);
		try {
			localStorage.removeItem(STORAGE_KEY);
		} catch {
			// Ignore
		}
	};

	// Keyboard shortcuts
	useEffect(() => {
		const handleKeyDown = (e) => {
			// K / Ctrl+K to open
			if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
				e.preventDefault();
				setIsOpen(true);
			}

			// ESC to close
			if (e.key === 'Escape' && isOpen) {
				setIsOpen(false);
				setQuery('');
			}
		};

		window.addEventListener('keydown', handleKeyDown);
		return () => window.removeEventListener('keydown', handleKeyDown);
	}, [isOpen]);

	// Arrow key navigation
	useEffect(() => {
		if (!isOpen || results.length === 0) return;

		const handleKeyDown = (e) => {
			if (e.key === 'ArrowDown') {
				e.preventDefault();
				setSelectedIndex((prev) => (prev + 1) % results.length);
			} else if (e.key === 'ArrowUp') {
				e.preventDefault();
				setSelectedIndex((prev) => (prev - 1 + results.length) % results.length);
			} else if (e.key === 'Enter' && results[selectedIndex]) {
				e.preventDefault();
				handleSelect(results[selectedIndex]);
			}
		};

		window.addEventListener('keydown', handleKeyDown);
		return () => window.removeEventListener('keydown', handleKeyDown);
	}, [isOpen, results, selectedIndex]);

	return {
		isOpen,
		setIsOpen,
		query,
		setQuery,
		results,
		isLoading,
		recentSearches: recentSearchesViewModel,
		selectedIndex,
		setSelectedIndex,
		handleSelect,
		clearRecent,
	};
}

--- END OF features\global-search\useGlobalSearchViewModel.js ---

--- FILE: features\global-search\components\SearchFooter.jsx ---
export const SearchFooter = () => {
	return (
		<div className='flex items-center justify-between px-4 py-2.5 border-t border-border bg-muted/30 text-[10px] text-gray-500'>
			<div className='flex items-center gap-4'>
				<span className='flex items-center gap-1.5'>
					<kbd className='px-1.5 py-0.5 bg-background border border-border rounded font-semibold'></kbd>
					<kbd className='px-1.5 py-0.5 bg-background border border-border rounded font-semibold'></kbd>
					<span>navigate</span>
				</span>
				<span className='flex items-center gap-1.5'>
					<kbd className='px-1.5 py-0.5 bg-background border border-border rounded font-semibold'></kbd>
					<span>select</span>
				</span>
			</div>
			<span className='flex items-center gap-1.5'>
				<kbd className='px-1.5 py-0.5 bg-background border border-border rounded font-semibold'>ESC</kbd>
				<span>close</span>
			</span>
		</div>
	);
};

--- END OF features\global-search\components\SearchFooter.jsx ---

--- FILE: features\global-search\components\SearchModal.jsx ---
import { createPortal } from 'react-dom'; // 1. Import createPortal
import { Search, X } from 'lucide-react';
import { SearchResults } from './SearchResults';
import { SearchFooter } from './SearchFooter';

export const SearchModal = ({ vm, inputRef }) => {
	// 2. Wrap the entire modal in createPortal, targeting document.body
	return createPortal(
		<div className='fixed inset-0 z-[100] flex items-start justify-center pt-[15vh] px-4'>
			{/* Backdrop */}
			<div
				className='absolute inset-0 bg-black/60 backdrop-blur-sm'
				onClick={() => {
					vm.setIsOpen(false);
					vm.setQuery('');
				}}
			/>

			{/* Search Panel */}
			<div className='relative w-full max-w-2xl bg-background rounded-xl shadow-2xl border border-border overflow-hidden animate-in fade-in zoom-in-95 duration-200'>
				{/* Search Input */}
				<div className='flex items-center gap-3 p-4 border-b border-border'>
					<Search size={18} className='text-gray-400 shrink-0' />
					<input
						ref={inputRef}
						type='text'
						value={vm.query}
						onChange={(e) => {
							vm.setQuery(e.target.value);
							vm.setSelectedIndex(0);
						}}
						placeholder='Search sessions, characters, locations, and more...'
						className='flex-1 bg-transparent text-sm text-foreground placeholder:text-gray-400 outline-none'
					/>
					{vm.query && (
						<button
							onClick={() => {
								vm.setQuery('');
								inputRef.current?.focus();
							}}
							className='p-1 text-gray-400 hover:text-foreground hover:bg-muted rounded transition-colors'>
							<X size={16} />
						</button>
					)}
					<kbd className='hidden sm:inline-block px-2 py-1 text-[10px] font-semibold text-gray-400 bg-muted border border-border rounded'>
						ESC
					</kbd>
				</div>

				{/* Results Area */}
				<SearchResults vm={vm} />

				{/* Footer with keyboard shortcuts */}
				<SearchFooter />
			</div>
		</div>,
		document.body // The target container
	);
};

--- END OF features\global-search\components\SearchModal.jsx ---

--- FILE: features\global-search\components\SearchResultItem.jsx ---
import { clsx } from 'clsx';

export const SearchResultItem = ({ item, isSelected, onSelect, onHover }) => {
	return (
		<button
			onClick={onSelect}
			onMouseEnter={onHover}
			className={clsx(
				'w-full flex items-start gap-3 px-4 py-2.5 transition-colors text-left',
				isSelected ? 'bg-amber-50' : 'hover:bg-muted'
			)}>
			<div
				className={clsx(
					'shrink-0 w-9 h-9 rounded-lg border flex items-center justify-center',
					item.theme.bg,
					item.theme.border,
					item.theme.text
				)}>
				<item.icon size={16} />
			</div>
			<div className='flex-1 min-w-0'>
				<div className='flex items-center gap-2 mb-0.5'>
					<span className='text-sm font-semibold text-foreground truncate'>{item.name}</span>
					<span className='shrink-0 text-[10px] uppercase font-bold tracking-wider text-gray-400 bg-muted px-1.5 py-0.5 rounded'>
						{item.type}
					</span>
				</div>
				{item.description && <p className='text-xs text-gray-600 line-clamp-2 leading-relaxed'>{item.description}</p>}
			</div>
			{isSelected && (
				<kbd className='shrink-0 text-[10px] font-semibold text-gray-400 bg-muted px-2 py-1 rounded border border-border'>
					
				</kbd>
			)}
		</button>
	);
};

--- END OF features\global-search\components\SearchResultItem.jsx ---

--- FILE: features\global-search\components\SearchResults.jsx ---
import { Search, Clock } from 'lucide-react';
import { clsx } from 'clsx';
import { SearchResultItem } from './SearchResultItem';

export const SearchResults = ({ vm }) => {
	const { query, results, isLoading, recentSearches, selectedIndex, setSelectedIndex, handleSelect, clearRecent } = vm;

	return (
		<div className='max-h-[60vh] overflow-y-auto'>
			{query.trim() === '' ? (
				// Recent Searches / Empty State
				<div className='p-4'>
					{recentSearches.length > 0 ? (
						<>
							<div className='flex items-center justify-between mb-3'>
								<h3 className='text-xs font-semibold uppercase tracking-wider text-gray-400'>Recent Searches</h3>
								<button onClick={clearRecent} className='text-xs text-gray-400 hover:text-foreground transition-colors'>
									Clear
								</button>
							</div>
							<div className='space-y-1'>
								{recentSearches.map((item) => (
									<button
										key={item.id}
										onClick={() => handleSelect(item)}
										className='w-full flex items-start gap-3 p-2 rounded-lg hover:bg-muted transition-colors text-left group'>
										<div
											className={clsx(
												'shrink-0 w-8 h-8 rounded-lg border flex items-center justify-center',
												item.theme.bg,
												item.theme.border,
												item.theme.text
											)}>
											<item.icon size={14} />
										</div>
										<div className='flex-1 min-w-0'>
											<div className='flex items-center gap-2 mb-0.5'>
												<span className='text-sm font-semibold text-foreground truncate'>{item.name}</span>
												<span className='shrink-0 text-[10px] uppercase font-bold tracking-wider text-gray-400'>
													{item.type}
												</span>
											</div>
											<p className='text-xs text-gray-500 line-clamp-1'>{item.description}</p>
										</div>
										<Clock
											size={14}
											className='shrink-0 text-gray-300 opacity-0 group-hover:opacity-100 transition-opacity'
										/>
									</button>
								))}
							</div>
						</>
					) : (
						<div className='text-center py-12'>
							<Search size={40} className='mx-auto text-gray-300 mb-3' />
							<p className='text-sm font-medium text-foreground mb-1'>Start typing to search</p>
							<p className='text-xs text-gray-500'>
								Search across sessions, characters, locations, quests, NPCs, and more
							</p>
						</div>
					)}
				</div>
			) : isLoading ? (
				<div className='text-center py-12'>
					<div className='inline-block w-8 h-8 border-2 border-gray-200 border-t-amber-600 rounded-full animate-spin' />
					<p className='text-sm text-gray-500 mt-3'>Searching...</p>
				</div>
			) : results.length > 0 ? (
				// Search Results
				<div className='py-2'>
					{results.map((item, idx) => (
						<SearchResultItem
							key={item.id}
							item={item}
							isSelected={idx === selectedIndex}
							onSelect={() => handleSelect(item)}
							onHover={() => setSelectedIndex(idx)}
						/>
					))}
				</div>
			) : (
				// No Results
				<div className='text-center py-12 px-4'>
					<Search size={40} className='mx-auto text-gray-300 mb-3' />
					<p className='text-sm font-medium text-foreground mb-1'>No results found for "{query}"</p>
					<p className='text-xs text-gray-500'>Try different keywords or check your spelling</p>
				</div>
			)}
		</div>
	);
};

--- END OF features\global-search\components\SearchResults.jsx ---

--- FILE: features\global-search\components\SearchTrigger.jsx ---
import { Search } from 'lucide-react';

export const SearchTrigger = ({ onClick }) => {
	return (
		<button
			onClick={onClick}
			className='w-full flex items-center gap-2 px-3 py-1.5 bg-background border border-border rounded-md text-sm text-gray-500 hover:text-foreground hover:border-amber-500/50 transition-all group'>
			<Search size={14} className='text-gray-400 group-hover:text-amber-600' />
			<span className='flex-1 text-left text-xs'>Search everything...</span>
			<kbd className='hidden sm:inline-block px-1.5 py-0.5 text-[10px] font-semibold text-gray-400 bg-muted border border-border rounded'>
				K
			</kbd>
		</button>
	);
};

--- END OF features\global-search\components\SearchTrigger.jsx ---

--- FILE: features\global-search\transforms\searchTransform.js ---
import { getAttributeValue } from '../../../utils/entity/attributeParser';

export const transformSearchResults = (rawResults) => {
	const { sessions, entities, sessionAttributes } = rawResults;

	// 1. Process Sessions
	const attrMap = new Map();
	(sessionAttributes || []).forEach((attr) => {
		if (!attrMap.has(attr.entity_id)) attrMap.set(attr.entity_id, []);
		attrMap.get(attr.entity_id).push(attr);
	});

	const processedSessions = sessions.map((s) => {
		const rawAttrs = attrMap.get(s.id) || [];
		const attrs = rawAttrs.reduce((acc, c) => ({ ...acc, [c.name]: c.value }), {});

		const num = getAttributeValue(attrs, ['session_number', 'Session']);
		const date = getAttributeValue(attrs, ['session_date', 'Date']);
		const summaryAttr = getAttributeValue(attrs, 'Summary');

		return {
			id: s.id,
			name: s.title,
			type: 'session',
			// Prefer Summary attribute, fallback to snippet of narrative
			description: summaryAttr || s.narrative?.substring(0, 150) || '',
			attributes: {
				Session: num,
				Date: date,
			},
		};
	});

	// 2. Combine with standard entities
	return [...processedSessions, ...(entities || [])];
};

--- END OF features\global-search\transforms\searchTransform.js ---

--- FILE: features\hooks\useTheme.js ---
import { useState, useEffect } from 'react';

export const THEMES = {
	LIGHT: 'light',
	// DARK: 'dark',
	DND: 'dnd',
};

export function useTheme() {
	const [theme, setTheme] = useState(() => {
		const stored = localStorage.getItem('app-theme');
		return stored || THEMES.LIGHT;
	});

	useEffect(() => {
		const root = window.document.documentElement;
		// Remove old themes
		Object.values(THEMES).forEach((t) => root.removeAttribute('data-theme'));

		// Apply new theme
		if (theme !== THEMES.LIGHT) {
			root.setAttribute('data-theme', theme);
		}

		localStorage.setItem('app-theme', theme);
	}, [theme]);

	const cycleTheme = () => {
		const themes = Object.values(THEMES);
		const currentIndex = themes.indexOf(theme);
		const nextIndex = (currentIndex + 1) % themes.length;
		setTheme(themes[nextIndex]);
	};

	return { theme, setTheme, cycleTheme };
}

--- END OF features\hooks\useTheme.js ---

--- FILE: features\layout-main\MainLayout.jsx ---
import { Outlet } from 'react-router-dom';
import { Menu } from 'lucide-react';
import { useMainLayout } from './useMainLayout';
import { Sidebar } from './components/Sidebar';
import DevAdminButton from '../../components/ui/DevAdminButton';

export default function MainLayout() {
	const vm = useMainLayout();

	return (
		<div className='flex h-screen bg-background text-foreground overflow-hidden'>
			{' '}
			{/* UPDATED */}
			<Sidebar vm={vm} />
			<main className='flex-1 h-full overflow-hidden bg-background relative flex flex-col'>
				{' '}
				{/* UPDATED */}
				{/* Mobile Header */}
				<div className='lg:hidden flex items-center justify-between p-4 border-b border-border bg-background shrink-0'>
					{' '}
					{/* UPDATED */}
					<button
						onClick={() => vm.setSidebarOpen(true)}
						className='p-2 text-muted-foreground hover:bg-muted rounded-md'>
						<Menu size={20} />
					</button>
					<h1 className='text-sm font-serif font-bold'>{vm.campaign?.name || 'Campaign'}</h1>
					<div className='w-9' />
				</div>
				<div className='flex-1 overflow-hidden relative'>
					<Outlet />
				</div>
				<DevAdminButton />
			</main>
		</div>
	);
}

--- END OF features\layout-main\MainLayout.jsx ---

--- FILE: features\layout-main\navConfig.js ---
import { Map, History, Network, BookOpen, Users, Scroll, Sword, Shield } from 'lucide-react';

export const NAV_STRUCTURE = [
	{
		title: 'World',
		items: [
			{ label: 'Atlas', Icon: Map, path: '/atlas', key: 'atlas' },
			{ label: 'Timeline', Icon: History, path: '/timeline', key: 'timeline' },
			{ label: 'Graph', Icon: Network, path: '/relationships', key: 'graph' },
		],
	},
	{
		title: 'Wiki',
		items: [
			{ label: 'Sessions', Icon: BookOpen, path: '/wiki/session', key: 'session' },
			{ label: 'Characters', Icon: Users, path: '/wiki/character', key: 'character' },
			{ label: 'NPCs', Icon: Users, path: '/wiki/npc', key: 'npc' },
			{ label: 'Locations', Icon: Map, path: '/wiki/location', key: 'location' },
			{ label: 'Factions', Icon: Shield, path: '/wiki/faction', key: 'faction' },
			{ label: 'Quests', Icon: Scroll, path: '/wiki/quest', key: 'quest' },
			{ label: 'Encounters', Icon: Sword, path: '/wiki/encounter', key: 'encounter' },
		],
	},
];

--- END OF features\layout-main\navConfig.js ---

--- FILE: features\layout-main\types.js ---
/**
 * @typedef {Object} NavItemConfig
 * @property {string} label
 * @property {Object} Icon - Lucide React Icon
 * @property {string} path
 */

/**
 * @typedef {Object} NavGroupConfig
 * @property {string} title
 * @property {NavItemConfig[]} items
 */

/**
 * @typedef {Object} LayoutViewModel
 * @property {boolean} sidebarOpen
 * @property {function(boolean): void} setSidebarOpen
 * @property {string} currentPath
 * @property {function(string): void} navigateTo
 * @property {Object|null} campaign - { name: string, initial: string }
 * @property {function(): void} onSwitchCampaign
 * @property {NavGroupConfig[]} navStructure
 */

export {};

--- END OF features\layout-main\types.js ---

--- FILE: features\layout-main\useMainLayout.js ---
import { useState, useMemo } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { getCampaigns } from '../../services/campaigns';
import { useCampaign } from '../../features/campaign-session/CampaignContext';
import { NAV_STRUCTURE } from './navConfig';
import './types';

export function useMainLayout() {
	const navigate = useNavigate();
	const location = useLocation();
	const { campaignId, setCampaignId } = useCampaign();
	const [sidebarOpen, setSidebarOpen] = useState(false);

	const { data: campaigns } = useQuery({
		queryKey: ['campaigns'],
		queryFn: getCampaigns,
		staleTime: 1000 * 60 * 10,
	});

	const currentCampaignData = campaigns?.find((c) => c.id === campaignId);

	const campaign = currentCampaignData
		? {
				name: currentCampaignData.name || 'Campaign',
				initial: (currentCampaignData.name?.[0] || 'C').toUpperCase(),
		  }
		: null;

	// ARCHITECTURAL CHANGE: Dynamic Navigation Logic
	// We use useMemo to recalculate navigation only when the campaign data changes.
	const navStructure = useMemo(() => {
		const hasMapData = !!currentCampaignData?.map_data;

		return NAV_STRUCTURE.map((group) => ({
			...group,
			items: group.items.filter((item) => {
				// If the item is the Atlas, only show it if map_data exists
				if (item.key === 'atlas') {
					return hasMapData;
				}
				return true;
			}),
		})).filter((group) => group.items.length > 0); // Cleanup empty groups if any
	}, [currentCampaignData]);

	const navigateTo = (path) => {
		navigate(path);
		setSidebarOpen(false);
	};

	const onSwitchCampaign = () => {
		setCampaignId(null);
		navigate('/wiki/session');
	};

	return {
		sidebarOpen,
		setSidebarOpen,
		currentPath: location.pathname,
		navigateTo,
		campaign,
		onSwitchCampaign,
		navStructure, // Return the computed structure
	};
}

--- END OF features\layout-main\useMainLayout.js ---

--- FILE: features\layout-main\components\Sidebar.jsx ---
import { clsx } from 'clsx';
import { Drawer } from '../../../components/ui/Drawer'; // Import generic
import { SidebarHeader } from './SidebarHeader';
import { SidebarNav } from './SidebarNav';
import { SidebarFooter } from './SidebarFooter';

export const Sidebar = ({ vm }) => {
	const { sidebarOpen, setSidebarOpen, campaign, navStructure, currentPath, navigateTo, onSwitchCampaign } = vm;

	const SidebarContent = () => (
		<div className='flex flex-col h-full bg-muted border-r border-border'>
			<SidebarHeader campaign={campaign} />
			<SidebarNav structure={navStructure} currentPath={currentPath} onNavigate={navigateTo} />
			<SidebarFooter onSwitch={onSwitchCampaign} />
		</div>
	);

	return (
		<>
			{/* Mobile: Generic Drawer */}
			<Drawer
				isOpen={sidebarOpen}
				onClose={() => setSidebarOpen(false)}
				title={campaign?.name || 'Menu'}
				position='left'
				className='w-72'>
				<div className='flex flex-col h-full bg-muted'>
					<SidebarHeader campaign={campaign} />
					<SidebarNav structure={navStructure} currentPath={currentPath} onNavigate={navigateTo} />
					<SidebarFooter onSwitch={onSwitchCampaign} />
				</div>
			</Drawer>

			{/* Desktop: Static Sidebar */}
			<aside className='hidden lg:flex w-64 flex-col h-full border-r border-border bg-muted shrink-0'>
				<SidebarContent />
			</aside>
		</>
	);
};

--- END OF features\layout-main\components\Sidebar.jsx ---

--- FILE: features\layout-main\components\SidebarFooter.jsx ---
import { Moon, Sun, Sword, Settings } from 'lucide-react';
import { useTheme, THEMES } from '../../hooks/useTheme';

export const SidebarFooter = ({ onSwitch }) => {
	const { theme, cycleTheme } = useTheme();

	const getThemeIcon = () => {
		switch (theme) {
			case THEMES.DARK:
				return <Moon size={14} className='mr-2' />;
			case THEMES.DND:
				return <Sword size={14} className='mr-2' />;
			default:
				return <Sun size={14} className='mr-2' />;
		}
	};

	const getThemeLabel = () => {
		switch (theme) {
			case THEMES.DARK:
				return 'Dark Mode';
			case THEMES.DND:
				return 'D&D PHB';
			default:
				return 'Light Mode';
		}
	};

	return (
		<div className='mt-auto p-4 border-t border-border space-y-2 bg-inherit'>
			<button
				onClick={cycleTheme}
				className='flex items-center w-full px-2 py-2 text-xs font-medium text-gray-500 hover:text-foreground hover:bg-black/5 rounded-md transition-colors'>
				{getThemeIcon()}
				Theme: {getThemeLabel()}
			</button>

			<button
				onClick={onSwitch}
				className='flex items-center w-full px-2 py-2 text-xs text-gray-500 hover:text-foreground hover:bg-black/5 rounded-md transition-colors'>
				<Settings size={14} className='mr-2' />
				Switch Campaign
			</button>
		</div>
	);
};

--- END OF features\layout-main\components\SidebarFooter.jsx ---

--- FILE: features\layout-main\components\SidebarHeader.jsx ---
import GlobalSearch from '../../global-search/GlobalSearch';

export const SidebarHeader = ({ campaign }) => {
	return (
		<div className='p-4'>
			{/* Campaign Card */}
			<div className='hidden lg:flex items-center gap-3 px-2 py-2 mb-4 hover:bg-gray-100 rounded-lg cursor-pointer transition-colors'>
				<div className='w-8 h-8 rounded bg-gradient-to-br from-amber-700 to-amber-900 flex items-center justify-center text-white font-serif font-bold shadow-sm'>
					{campaign?.initial || 'C'}
				</div>
				<div className='flex-1 min-w-0'>
					<h2 className='text-sm font-bold text-foreground font-serif'>{campaign?.name || 'Loading...'}</h2>
				</div>
			</div>

			{/* Global Search */}
			<div className='lg:mb-6'>
				<GlobalSearch />
			</div>
		</div>
	);
};

--- END OF features\layout-main\components\SidebarHeader.jsx ---

--- FILE: features\layout-main\components\SidebarNav.jsx ---
import { clsx } from 'clsx';

export const SidebarNav = ({ structure, currentPath, onNavigate }) => {
	return (
		<div className='flex-1 overflow-y-auto px-4 space-y-6'>
			{structure.map((group) => (
				<div key={group.title}>
					<h3 className='px-3 text-xs font-semibold text-gray-400 uppercase tracking-wider mb-2'>{group.title}</h3>
					<div className='space-y-0.5'>
						{group.items.map((item) => {
							const isWiki = item.path.startsWith('/wiki/');
							const active = isWiki ? currentPath.startsWith(item.path) : currentPath === item.path;
							const Icon = item.Icon;
							return (
								<button
									key={item.path}
									onClick={() => onNavigate(item.path)}
									className={clsx(
										'flex items-center w-full px-3 py-1.5 text-sm font-medium rounded-md transition-colors',
										active
											? 'bg-background shadow-sm text-black ring-1 ring-gray-200'
											: 'text-gray-500 hover:bg-gray-100 hover:text-foreground'
									)}>
									<Icon size={16} className={clsx('mr-2', active ? 'text-amber-600' : 'text-gray-400')} />
									{item.label}
								</button>
							);
						})}
					</div>
				</div>
			))}
		</div>
	);
};

--- END OF features\layout-main\components\SidebarNav.jsx ---

--- FILE: features\relationship-graph\RelationshipGraph.jsx ---
import { useGraphViewModel } from './useGraphViewModel';
import { GraphLegend } from './components/GraphLegend';
import { CytoscapeCanvas } from './components/CytoscapeCanvas';
import LoadingSpinner from '../../components/ui/LoadingSpinner';

export default function RelationshipGraph() {
	const { elements, isLoading } = useGraphViewModel();

	if (isLoading) {
		return (
			<div className='h-full flex items-center justify-center'>
				<LoadingSpinner text='Analyzing Connections...' />
			</div>
		);
	}

	return (
		// IMPLEMENTATION: Constellation Background via CSS radial-gradient
		<div
			className='h-full w-full relative bg-background overflow-hidden'
			style={{
				backgroundImage:
					'radial-gradient(circle at center, #e5e5e5 1px, transparent 1px), radial-gradient(circle at center, #e5e5e5 1px, transparent 1px)',
				backgroundSize: '40px 40px, 20px 20px',
				backgroundPosition: '0 0, 20px 20px',
			}}>
			{/* Overlay UI */}
			<GraphLegend />

			{/* The Graph Layer */}
			<CytoscapeCanvas elements={elements} />
		</div>
	);
}

--- END OF features\relationship-graph\RelationshipGraph.jsx ---

--- FILE: features\relationship-graph\types.js ---
/**
 * @typedef {Object} GraphNodeData
 * @property {string} id
 * @property {string} label
 * @property {string} color - Hex color
 * @property {string} image - URL to icon/image
 * @property {string} type - Entity type
 */

/**
 * @typedef {Object} GraphEdgeData
 * @property {string} id
 * @property {string} source - Source Node ID
 * @property {string} target - Target Node ID
 * @property {string} label - Edge label (relationship type)
 * @property {string} color - Hex color
 */

/**
 * @typedef {Object} CytoscapeElement
 * @property {string} group - 'nodes' | 'edges'
 * @property {GraphNodeData | GraphEdgeData} data
 */

export {};

--- END OF features\relationship-graph\types.js ---

--- FILE: features\relationship-graph\useGraphViewModel.js ---
import { useQuery } from '@tanstack/react-query';
import { useMemo } from 'react';
import { getGraphData } from '../../services/entities';
import { useCampaign } from '../../features/campaign-session/CampaignContext';
import { transformGraphData } from './transforms/graphTransform'; // Import transform
import './types';

export function useGraphViewModel() {
	const { campaignId } = useCampaign();

	const { data: rawEntities, isLoading } = useQuery({
		queryKey: ['graph', campaignId],
		queryFn: () => getGraphData(campaignId),
		enabled: !!campaignId,
	});

	// Use the pure transform function
	const elements = useMemo(() => {
		return transformGraphData(rawEntities);
	}, [rawEntities]);

	return { elements, isLoading };
}

--- END OF features\relationship-graph\useGraphViewModel.js ---

--- FILE: features\relationship-graph\components\CytoscapeCanvas.jsx ---
import { useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import cytoscape from 'cytoscape';
import fcose from 'cytoscape-fcose'; // IMPLEMENTATION: fCoSE
import { CYTOSCAPE_STYLES, LAYOUT_CONFIG } from '../config/graphStyles';

// Register the layout extension
cytoscape.use(fcose);

export const CytoscapeCanvas = ({ elements }) => {
	const containerRef = useRef(null);
	const cyRef = useRef(null);
	const navigate = useNavigate();

	useEffect(() => {
		if (!containerRef.current) return;

		// 1. Initialize Cytoscape
		cyRef.current = cytoscape({
			container: containerRef.current,
			elements: [],
			style: CYTOSCAPE_STYLES,
			layout: LAYOUT_CONFIG,
			wheelSensitivity: 3,
			minZoom: 0.2,
			maxZoom: 3,
			autoungrabify: true, // CHANGED: Set to true to disable node dragging
		});

		const cy = cyRef.current;

		// --- EVENT HANDLERS ---

		// 1. Click Node: Highlight Connections
		cy.on('tap', 'node', (evt) => {
			const node = evt.target;

			// Clear previous states
			cy.elements().removeClass('highlighted dimmed');

			const connectedEdges = node.connectedEdges();
			const connectedNodes = connectedEdges.connectedNodes();

			// Dim everything else
			cy.elements().difference(connectedNodes.union(connectedEdges).union(node)).addClass('dimmed');

			// Highlight selection
			node.addClass('highlighted');
			connectedNodes.addClass('highlighted');
			connectedEdges.addClass('highlighted');
		});

		// 2. Click Background: Reset
		cy.on('tap', (evt) => {
			if (evt.target === cy) {
				cy.elements().removeClass('highlighted dimmed');
			}
		});

		// 3. IMPLEMENTATION: Double Click to Navigate
		cy.on('dblclick', 'node', (evt) => {
			const node = evt.target;
			const { id, type } = node.data();
			if (id && type) {
				navigate(`/wiki/${type}/${id}`);
			}
		});

		return () => {
			if (cyRef.current) {
				cyRef.current.destroy();
				cyRef.current = null;
			}
		};
	}, [navigate]);

	// 2. Handle Data Updates
	useEffect(() => {
		if (!cyRef.current || !elements) return;

		const cy = cyRef.current;

		cy.batch(() => {
			cy.elements().remove();
			cy.add(elements);
		});

		if (elements.length > 0) {
			// Run fCoSE layout
			cy.layout(LAYOUT_CONFIG).run();
		}
	}, [elements]);

	return <div ref={containerRef} className='absolute inset-0 w-full h-full' />;
};

--- END OF features\relationship-graph\components\CytoscapeCanvas.jsx ---

--- FILE: features\relationship-graph\components\GraphLegend.jsx ---
import { ENTITY_CONFIG } from '../../../config/entity/entityConfig'; // Adjust path

export const GraphLegend = () => {
	// Filter out the 'default' config to keep legend clean
	const legendItems = Object.values(ENTITY_CONFIG).filter((c) => c.label !== 'Entity');

	return (
		<div className='absolute top-4 left-4 z-10 bg-background/90 p-3 rounded shadow border border-border backdrop-blur pointer-events-none select-none'>
			<h2 className='text-xs font-bold uppercase text-gray-400 mb-2'>Legend</h2>
			<div className='space-y-1.5'>
				{legendItems.map((config) => (
					<div key={config.label} className='flex items-center gap-2 text-xs font-medium text-gray-600'>
						<div className='w-2.5 h-2.5 rounded-full shadow-sm' style={{ backgroundColor: config.color }} />
						{config.label}
					</div>
				))}
			</div>
		</div>
	);
};

--- END OF features\relationship-graph\components\GraphLegend.jsx ---

--- FILE: features\relationship-graph\config\graphStyles.js ---
export const CYTOSCAPE_STYLES = [
	// --- MAJOR NODES (Hubs/VIPs) ---
	{
		selector: 'node',
		style: {
			label: 'data(label)',
			'border-color': 'data(color)',
			'background-image': 'data(image)',
			'background-fit': 'cover',
			'border-width': 2,
			width: 'mapData(degree, 3, 20, 30, 50)',
			height: 'mapData(degree, 3, 20, 30, 50)',
			'font-family': 'Inter, sans-serif',
			'font-size': 14,
			'font-weight': 'bold',
			'text-valign': 'bottom',
			'text-margin-y': 6,
			'text-background-color': '#fdfbf7',
			'text-background-opacity': 0.8,
			'text-background-padding': 3,
			'text-background-shape': 'roundrectangle',
			color: '#1f2937',
			'text-wrap': 'ellipsis',
			'text-max-width': 100,
			'transition-property': 'opacity, width, height',
			'transition-duration': '0.3s',
		},
	},
	// --- MINOR NODES (Dots) ---
	{
		selector: 'node.minor',
		style: {
			// ADJUSTED: Increased from 14 to 20 for better visibility
			width: 20,
			height: 20,
			// 'background-image': 'none', // Hide Icon
			'background-color': 'data(color)', // Use entity color as fill
			'border-width': 1,
			'border-color': 'data(color)',
			'font-size': 10,
			'text-margin-y': 4,
			'text-background-opacity': 0, // No background for text to reduce clutter
			color: '#4b5563', // Gray text
		},
	},
	// --- EDGES ---
	{
		selector: 'edge',
		style: {
			'line-color': 'data(color)',
			'target-arrow-color': 'data(color)',
			'curve-style': 'bezier',
			width: 1,
			opacity: 0.2, // Slightly more transparent to handle overlap
			'arrow-scale': 0.6,
			'target-arrow-shape': 'triangle',
			events: 'no',
		},
	},
	// --- INTERACTION STATES ---
	{
		selector: '.dimmed',
		style: {
			opacity: 0.05,
			'text-opacity': 0.1,
			'border-opacity': 0.1,
			'background-opacity': 0.1,
		},
	},
	{
		selector: '.highlighted',
		style: {
			'z-index': 9999,
			'text-wrap': 'wrap',
		},
	},
	{
		selector: 'edge.highlighted',
		style: {
			width: 2,
			opacity: 1,
		},
	},
];

// PERFORMANCE: Switch to fCoSE layout with "High Spacing" profile
export const LAYOUT_CONFIG = {
	name: 'fcose',
	quality: 'default',
	randomize: false,
	animate: false,
	animationDuration: 1000,
	fit: true,
	padding: 50,

	// CRITICAL: Tells the physics engine to treat the node as "Icon + Text Label" size
	// instead of just "Icon" size.
	nodeDimensionsIncludeLabels: true,

	// --- PHYSICS SETTINGS (Aggressive Spacing) ---

	// 1. REPULSION (The "Personal Space" Force)
	// Drastically increased. This ensures that even if two nodes are connected,
	// the text labels push against each other to prevent overlap.
	nodeRepulsion: (node) => {
		const degree = node.data('degree') || 0;
		// Base: 40,000 (was 6,500)
		// Per Connection: 5,000 (was 1,500)
		return 40000 + degree * 5000;
	},

	// 2. EDGE LENGTH (The "Leash" Length)
	// Increased to ensure hubs with many connections have a wider circumference.
	idealEdgeLength: (edge) => {
		const d1 = edge.source().data('degree') || 0;
		const d2 = edge.target().data('degree') || 0;
		const maxDegree = Math.max(d1, d2);

		// Base: 150 (was 100)
		// Per Degree: 30 (was 15)
		return 150 + maxDegree * 30;
	},

	// 3. ELASTICITY
	// Lower = Stretcher edges. Allows Repulsion to win over Edge Length.
	edgeElasticity: (edge) => 0.1,

	// 4. GRAVITY (The "Centering" Force)
	// Lowered significantly. This stops the graph from collapsing on itself.
	gravity: 0.25, // (was 0.25)
	gravityRange: 3.8,

	// 5. ITERATIONS
	// More time for the simulation to resolve collisions
	numIter: 2500,

	// Disconnected components spacing
	tile: true,
	tilingPaddingVertical: 100,
	tilingPaddingHorizontal: 100,
};

--- END OF features\relationship-graph\config\graphStyles.js ---

--- FILE: features\relationship-graph\transforms\graphTransform.js ---
import { getEntityConfig } from '../../../config/entity';
import { resolveImageUrl } from '../../../utils/image/imageResolver';
import { getAffinityRank } from '../../../utils/status/statusHelpers';

const INK_COLORS = {
	ALLY: '#4d7c0f',
	ENEMY: '#7f1d1d',
	NEUTRAL: '#78716c',
};

const FALLBACK_ICON_PATH = 'images/icons';

export const transformGraphData = (rawEntities) => {
	if (!rawEntities || rawEntities.length === 0) return [];

	const entities = rawEntities.filter((e) => {
		const type = e.type?.toLowerCase();
		return type !== 'session_event' && type !== 'event';
	});

	const nodes = [];
	const edges = [];
	const entityIds = new Set(entities.map((e) => e.id));
	const connectedNodeIds = new Set();
	const uniqueEdgeTracker = new Set();
	const degreeMap = new Map();

	// Pass 1: Edges
	entities.forEach((entity) => {
		(entity.relationships || []).forEach((rel) => {
			if (!entityIds.has(rel.entity_id)) return;

			const [id1, id2] = [entity.id, rel.entity_id].sort();
			const edgeKey = `${id1}-${id2}`;

			if (uniqueEdgeTracker.has(edgeKey)) return;
			uniqueEdgeTracker.add(edgeKey);

			connectedNodeIds.add(entity.id);
			connectedNodeIds.add(rel.entity_id);

			degreeMap.set(entity.id, (degreeMap.get(entity.id) || 0) + 1);
			degreeMap.set(rel.entity_id, (degreeMap.get(rel.entity_id) || 0) + 1);

			const rank = getAffinityRank(rel.type);
			let edgeColor = INK_COLORS.NEUTRAL;
			if (rank === 1) edgeColor = INK_COLORS.ALLY;
			if (rank === 3) edgeColor = INK_COLORS.ENEMY;

			edges.push({
				group: 'edges',
				data: {
					id: `e-${edgeKey}`,
					source: entity.id,
					target: rel.entity_id,
					color: edgeColor,
				},
			});
		});
	});

	// Pass 2: Nodes
	entities.forEach((entity) => {
		if (!connectedNodeIds.has(entity.id)) return;

		const config = getEntityConfig(entity.type);
		const finalIconUrl = resolveImageUrl(entity.attributes, 'icon') || `${FALLBACK_ICON_PATH}/${entity.type}.png`;
		const degree = degreeMap.get(entity.id) || 1;
		const isMinor = degree < 3;

		nodes.push({
			group: 'nodes',
			classes: isMinor ? 'minor' : 'major',
			data: {
				id: entity.id,
				label: entity.name,
				color: config.color,
				image: finalIconUrl,
				type: entity.type,
				degree: degree,
			},
		});
	});

	return [...nodes, ...edges];
};

--- END OF features\relationship-graph\transforms\graphTransform.js ---

--- FILE: features\smart-text\SmartMarkdown.jsx ---
import ReactMarkdown from 'react-markdown';
import { useSmartText } from './useSmartText';
import { SmartEntityLink } from './components/SmartEntityLink';
import { generateId, extractText } from '../../utils/text/textProcessing';

export default function SmartMarkdown({ children, ...props }) {
	// ... existing safety check code ...
	let safeText = children;
	if (Array.isArray(children)) {
		safeText = children.join('');
	} else if (typeof children !== 'string' && children !== null && children !== undefined) {
		safeText = String(children);
	}

	const processedText = useSmartText(safeText);

	const HeadingRenderer = ({ level, children }) => {
		const text = extractText(children);
		const id = generateId(text);
		const Tag = `h${level}`;
		return <Tag id={id}>{children}</Tag>;
	};

	return (
		<ReactMarkdown
			{...props}
			components={{
				...props.components,
				// Inject ID generators
				h1: (props) => <HeadingRenderer level={1} {...props} />,
				h2: (props) => <HeadingRenderer level={2} {...props} />,
				h3: (props) => <HeadingRenderer level={3} {...props} />,
				// Existing link renderer
				a: ({ href, children }) => {
					// ... existing link logic ...
					if (href && href.startsWith('#entity/')) {
						const [, id, type] = href.split('/');
						return (
							<SmartEntityLink id={id} type={type}>
								{children}
							</SmartEntityLink>
						);
					}
					return (
						<a href={href} className='text-blue-600 hover:underline' target='_blank' rel='noopener noreferrer'>
							{children}
						</a>
					);
				},
			}}>
			{processedText}
		</ReactMarkdown>
	);
}

--- END OF features\smart-text\SmartMarkdown.jsx ---

--- FILE: features\smart-text\types.js ---
/**
 * @typedef {Object} EntityIndexItem
 * @property {string} id
 * @property {string} name
 * @property {string} type
 */

/**
 * @typedef {Object} TextMatch
 * @property {number} start
 * @property {number} end
 * @property {string} text
 * @property {EntityIndexItem} entity
 */

export {};

--- END OF features\smart-text\types.js ---

--- FILE: features\smart-text\useEntityIndex.js ---
import { useQuery } from '@tanstack/react-query';
import { getEntityIndex } from '../../services/entities';
import { useCampaign } from '../../features/campaign-session/CampaignContext';
import { resolveImageUrl, parseAttributes } from '../../utils/image/imageResolver'; // Use util
import './types';

export function useEntityIndex() {
	const { campaignId } = useCampaign();

	const { data } = useQuery({
		queryKey: ['entityIndex', campaignId],
		queryFn: async () => {
			const rawData = await getEntityIndex(campaignId);
			return rawData.map((entity) => {
				const attrs = parseAttributes(entity.attributes);
				return {
					...entity,
					// Use standard resolver
					iconUrl: resolveImageUrl(attrs, 'icon'),
				};
			});
		},
		staleTime: 1000 * 60 * 30,
		enabled: !!campaignId,
	});

	return data || [];
}

--- END OF features\smart-text\useEntityIndex.js ---

--- FILE: features\smart-text\useSmartText.js ---
import { useMemo } from 'react';
import { useEntityIndex } from './useEntityIndex';

/**
 * Escape special regex characters
 */
const escapeRegex = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

/**
 * Find non-overlapping entity mentions in text
 * Uses greedy matching (longest names first) to handle nested entities
 */
const findEntityMatches = (text, entityIndex) => {
	const matches = [];
	const processedRanges = [];

	// Sort by length DESC to match "Loc the Phoenix" before "Loc"
	const sortedEntities = [...entityIndex].sort((a, b) => b.name.length - a.name.length);

	for (const entity of sortedEntities) {
		// Create word-boundary regex for this entity
		const pattern = new RegExp(`\\b${escapeRegex(entity.name)}\\b`, 'gi');
		let match;

		while ((match = pattern.exec(text)) !== null) {
			const start = match.index;
			const end = start + match[0].length;

			// Check if this range overlaps with any processed range
			const overlaps = processedRanges.some(
				(range) =>
					(start >= range.start && start < range.end) ||
					(end > range.start && end <= range.end) ||
					(start <= range.start && end >= range.end)
			);

			if (!overlaps) {
				matches.push({
					start,
					end,
					text: match[0],
					entity,
				});
				processedRanges.push({ start, end });
			}
		}
	}

	// Sort by position for reconstruction
	return matches.sort((a, b) => a.start - b.start);
};

/**
 * Replace entity mentions with markdown links
 */
const replaceMatches = (text, matches) => {
	if (matches.length === 0) return text;

	let result = '';
	let lastIndex = 0;

	for (const match of matches) {
		// Add text before match
		result += text.slice(lastIndex, match.start);

		// Add markdown link
		result += `[${match.text}](#entity/${match.entity.id}/${match.entity.type})`;

		lastIndex = match.end;
	}

	// Add remaining text
	result += text.slice(lastIndex);

	return result;
};

/**
 * Parses text and injects markdown links for known entities.
 * OPTIMIZED: Added threshold checks and better memoization
 *
 * @param {string} text
 * @returns {string} The processed markdown string
 */
export function useSmartText(text) {
	const entityIndex = useEntityIndex();

	// OPTIMIZATION 1: Early exit checks (before expensive useMemo)
	const shouldProcess = useMemo(() => {
		// Don't process empty, short, or null text
		if (!text || typeof text !== 'string' || text.length < 3) return false;

		// Don't process if no entities loaded
		if (!entityIndex || entityIndex.length === 0) return false;

		// Don't process very short text (performance trade-off)
		// You can adjust this threshold based on your use case
		if (text.length < 10) return false;

		return true;
	}, [text, entityIndex.length]); // Only re-check when text or index count changes

	return useMemo(() => {
		if (!shouldProcess) return text || '';

		try {
			const matches = findEntityMatches(text, entityIndex);
			return replaceMatches(text, matches);
		} catch (err) {
			console.error('SmartMarkdown processing error:', err);
			return text; // Fallback to original
		}
	}, [text, entityIndex, shouldProcess]); // Better dependency array
}

--- END OF features\smart-text\useSmartText.js ---

--- FILE: features\smart-text\components\SmartEntityLink.jsx ---
/**
 * SmartEntityLink - MIGRATED to use EntityLink component
 * This is now just a thin wrapper that adds entity index lookup
 */

import EntityLink from '../../../components/entity/EntityLink';
import { useEntityIndex } from '../useEntityIndex';

export const SmartEntityLink = ({ id, type, children }) => {
	const entityIndex = useEntityIndex();

	// Look up custom icon from entity index
	const entity = entityIndex.find((e) => e.id === id);
	const customIconUrl = entity?.iconUrl;

	return (
		<EntityLink id={id} type={type} customIconUrl={customIconUrl} inline>
			{children}
		</EntityLink>
	);
};

--- END OF features\smart-text\components\SmartEntityLink.jsx ---

--- FILE: features\smart-tooltip\TooltipContainer.jsx ---
import { createPortal } from 'react-dom';
import { useQuery } from '@tanstack/react-query';
import { getTooltipData } from '../../services/entities'; // Use Service
import { TooltipCard } from './components/TooltipCard';
import { getAttributeValue } from '../../utils/entity/attributeParser';

export const TooltipContainer = ({ target, onMouseEnter, onMouseLeave }) => {
	const targetId = target?.id;
	const targetType = target?.type;
	const isValidId = targetId ? /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(targetId) : false;

	const { data, isLoading } = useQuery({
		queryKey: ['tooltip', targetId],
		// Call Service instead of Supabase directly
		queryFn: async () => {
			if (!targetId) return null;
			const rawData = await getTooltipData(targetId, targetType);

			// Small amount of VIEW logic remains here to shape it for the Card
			if (targetType === 'session') {
				const attrs = (rawData.attributes || []).reduce((acc, c) => ({ ...acc, [c.name]: c.value }), {});
				const num = getAttributeValue(attrs, ['session_number', 'Session']);
				const date = getAttributeValue(attrs, ['session_date', 'Date']);
				const summaryAttr = getAttributeValue(attrs, 'Summary');

				return {
					name: rawData.name,
					type: 'session',
					description: summaryAttr || rawData.description,
					attributes: { Session: num, Date: date },
				};
			}
			return rawData;
		},
		enabled: !!targetId && isValidId,
		staleTime: 1000 * 60 * 5,
		retry: false,
	});

	if (!target) return null;
	const isMobile = window.matchMedia('(pointer: coarse)').matches || window.innerWidth < 1024;

	return createPortal(
		<>
			{isMobile && target.isPinned && (
				<div
					className='fixed inset-0 bg-black/20 z-[9998]'
					onClick={(e) => {
						e.stopPropagation();
						onMouseLeave && onMouseLeave();
					}}
					style={{ touchAction: 'none' }}
				/>
			)}
			<TooltipCard
				data={data}
				type={target.type}
				id={target.id}
				position={target.pos}
				isLoading={isLoading}
				onMouseEnter={onMouseEnter}
				onMouseLeave={onMouseLeave}
			/>
		</>,
		document.body
	);
};

--- END OF features\smart-tooltip\TooltipContainer.jsx ---

--- FILE: features\smart-tooltip\TooltipContext.jsx ---
import { createContext, useContext } from 'react';
import { useTooltipState } from './useTooltipState';
import { TooltipContainer } from './TooltipContainer';

const TooltipContext = createContext(null);

export const TooltipProvider = ({ children }) => {
	const { activeTooltip, openTooltip, closeTooltip, cancelClose } = useTooltipState();

	return (
		<TooltipContext.Provider value={{ openTooltip, closeTooltip, cancelClose }}>
			{children}

			{/* Pass interaction handlers to the Overlay Layer */}
			<TooltipContainer target={activeTooltip} onMouseEnter={cancelClose} onMouseLeave={closeTooltip} />
		</TooltipContext.Provider>
	);
};

export const useTooltip = () => {
	const context = useContext(TooltipContext);
	if (!context) {
		throw new Error('useTooltip must be used within a TooltipProvider');
	}
	return context;
};

--- END OF features\smart-tooltip\TooltipContext.jsx ---

--- FILE: features\smart-tooltip\types.js ---
/**
 * @typedef {Object} TooltipPosition
 * @property {number} x - Client X coordinate
 * @property {number} y - Client Y coordinate
 */

/**
 * @typedef {Object} TooltipTarget
 * @property {string} id - Entity UUID
 * @property {string} type - Entity Type
 * @property {TooltipPosition} pos
 */

/**
 * @typedef {Object} TooltipContextValue
 * @property {function(React.MouseEvent, string, string): void} openTooltip
 * @property {function(): void} closeTooltip
 */

export {};

--- END OF features\smart-tooltip\types.js ---

--- FILE: features\smart-tooltip\useSmartPosition.js ---
import { useState, useEffect, useRef } from 'react';

/**
 * Calculates smart positioning for tooltips to keep them onscreen
 * @param {Object} targetPosition - { x, y } coordinates of the trigger element
 * @param {boolean} isOpen - Whether the tooltip is currently visible
 * @returns {Object} - { style, tooltipRef } for positioning
 */
export function useSmartPosition(targetPosition, isOpen) {
	const tooltipRef = useRef(null);
	const [position, setPosition] = useState({ top: 0, left: 0, transform: '' });
	const [isPositioned, setIsPositioned] = useState(false);

	useEffect(() => {
		if (!isOpen || !tooltipRef.current || !targetPosition) {
			setIsPositioned(false);
			return;
		}

		const calculatePosition = () => {
			const tooltip = tooltipRef.current;
			const rect = tooltip.getBoundingClientRect();

			// Get viewport dimensions
			const viewportWidth = window.innerWidth;
			const viewportHeight = window.innerHeight;

			// Configuration
			const EDGE_PADDING = 10; // Minimum distance from screen edges
			const OFFSET_Y = 20; // Distance below cursor
			const TOOLTIP_WIDTH = 300; // Match your tooltip width

			let top = targetPosition.y + OFFSET_Y;
			let left = targetPosition.x;
			let transform = 'translateX(-50%)'; // Center by default

			// --- HORIZONTAL POSITIONING ---

			// Calculate where the tooltip would end up with center alignment
			const leftEdge = left - TOOLTIP_WIDTH / 2;
			const rightEdge = left + TOOLTIP_WIDTH / 2;

			if (rightEdge > viewportWidth - EDGE_PADDING) {
				// Tooltip would overflow right side
				// Align to right edge of viewport with padding
				left = viewportWidth - EDGE_PADDING;
				transform = 'translateX(-100%)'; // Right align
			} else if (leftEdge < EDGE_PADDING) {
				// Tooltip would overflow left side
				// Align to left edge of viewport with padding
				left = EDGE_PADDING;
				transform = 'translateX(0)'; // Left align
			}

			// --- VERTICAL POSITIONING ---

			// Check if tooltip would overflow bottom
			if (top + rect.height > viewportHeight - EDGE_PADDING) {
				// Position above the cursor instead
				top = targetPosition.y - rect.height - 10;

				// If it still doesn't fit above, clamp to top
				if (top < EDGE_PADDING) {
					top = EDGE_PADDING;
				}
			}

			// Ensure tooltip doesn't go above viewport
			if (top < EDGE_PADDING) {
				top = EDGE_PADDING;
			}

			setPosition({ top, left, transform });
			setIsPositioned(true);
		};

		// Initial calculation
		calculatePosition();

		// Recalculate on resize (debounced)
		let resizeTimer;
		const handleResize = () => {
			clearTimeout(resizeTimer);
			resizeTimer = setTimeout(calculatePosition, 100);
		};

		window.addEventListener('resize', handleResize);

		return () => {
			window.removeEventListener('resize', handleResize);
			clearTimeout(resizeTimer);
		};
	}, [targetPosition, isOpen]);

	const style = {
		position: 'fixed',
		top: `${position.top}px`,
		left: `${position.left}px`,
		transform: position.transform,
		zIndex: 9999,
		width: '300px',
		pointerEvents: 'auto',
		opacity: isPositioned ? 1 : 0,
		transition: 'opacity 0.15s ease-out',
	};

	return { style, tooltipRef, isPositioned };
}

--- END OF features\smart-tooltip\useSmartPosition.js ---

--- FILE: features\smart-tooltip\useTooltipState.js ---
import { useState, useRef, useCallback, useEffect } from 'react';
import './types';

export function useTooltipState() {
	const [activeTooltip, setActiveTooltip] = useState(null);
	const timeoutRef = useRef(null);

	useEffect(() => {
		return () => {
			if (timeoutRef.current) {
				clearTimeout(timeoutRef.current);
			}
		};
	}, []);

	const openTooltip = useCallback((e, id, type, isPinned = false) => {
		// If we are opening a new one, clear any pending close
		if (timeoutRef.current) clearTimeout(timeoutRef.current);

		// Get position from event
		let x = e.clientX;
		let y = e.clientY;

		// For touch events on mobile, use touch coordinates
		if (e.touches && e.touches[0]) {
			x = e.touches[0].clientX;
			y = e.touches[0].clientY;
		}

		setActiveTooltip({ id, type, pos: { x, y }, isPinned });
	}, []);

	const closeTooltip = useCallback(() => {
		// Add a delay so the user can move their mouse from the link TO the tooltip
		timeoutRef.current = setTimeout(() => {
			setActiveTooltip(null);
		}, 300); // 300ms grace period
	}, []);

	// Allows the Tooltip Card to say "I'm being hovered, don't close!"
	const cancelClose = useCallback(() => {
		if (timeoutRef.current) clearTimeout(timeoutRef.current);
	}, []);

	return {
		activeTooltip,
		openTooltip,
		closeTooltip,
		cancelClose,
	};
}

--- END OF features\smart-tooltip\useTooltipState.js ---

--- FILE: features\smart-tooltip\components\TooltipCard.jsx ---
import { useNavigate } from 'react-router-dom';
import { clsx } from 'clsx';
import { getEntityConfig } from '../../../config/entity';
import { getAttributeValue } from '../../../utils/entity/attributeParser';
import { ArrowRight } from 'lucide-react';
import { useSmartPosition } from '../useSmartPosition';
import { resolveImageUrl, parseAttributes } from '../../../utils/image/imageResolver';

export const TooltipCard = ({ data, type, id, position, isLoading, onMouseEnter, onMouseLeave }) => {
	const navigate = useNavigate();
	const config = getEntityConfig(type);
	const Icon = config.icon;

	// Use smart positioning hook
	const { style, tooltipRef, isPositioned } = useSmartPosition(position, true);

	const handleClick = (e) => {
		e.stopPropagation();
		navigate(`/wiki/${type}/${id}`);
		onMouseLeave && onMouseLeave();
	};

	if (isLoading) {
		return (
			<div
				ref={tooltipRef}
				style={style}
				className='bg-background p-3 rounded-lg shadow-xl border border-border text-xs text-gray-400'>
				Loading info...
			</div>
		);
	}

	if (!data) return null;

	const attributes = parseAttributes(data.attributes);
	const image = resolveImageUrl(attributes, 'background');
	const status = getAttributeValue(attributes, ['status', 'disposition']);
	const race = getAttributeValue(attributes, ['race', 'ancestry']);
	const classJob = getAttributeValue(attributes, ['class', 'occupation', 'role']);

	const tags = [status, race, classJob].filter(Boolean).join('  ');

	return (
		<div
			ref={tooltipRef}
			style={style}
			onClick={handleClick}
			onMouseEnter={onMouseEnter}
			onMouseLeave={onMouseLeave}
			className={clsx(
				'bg-background rounded-xl shadow-2xl overflow-hidden ring-1 ring-black/10 cursor-pointer group',
				'hover:ring-amber-500/50 transition-shadow'
			)}>
			{/* IMAGE BANNER */}
			{image ? (
				<div className='h-24 w-full relative bg-gray-900 overflow-hidden'>
					<img
						src={image}
						alt={data.name}
						onError={(e) => {
							e.target.style.display = 'none';
							e.target.parentElement.classList.add('bg-amber-900');
						}}
						className='w-full h-full object-cover object-top opacity-80 group-hover:scale-105 transition-transform duration-500'
					/>
					<div className='absolute inset-0 bg-gradient-to-t from-background to-transparent' />
				</div>
			) : (
				<div
					className={clsx(
						'h-1.5 w-full',
						config.tailwind.bg.replace(
							'bg-',
							'bg-gradient-to-r from-transparent via-current to-transparent opacity-50'
						),
						config.tailwind.text
					)}
				/>
			)}

			<div className={clsx('px-4', image ? '-mt-6 relative z-10' : 'pt-3')}>
				<div className='flex items-start justify-between'>
					<div>
						<span
							className={clsx(
								'text-[10px] font-bold uppercase tracking-wider opacity-70 mb-0.5 block',
								config.tailwind.text
							)}>
							{data.type}
						</span>
						<h3 className='font-serif font-bold text-lg leading-none text-foreground group-hover:text-amber-700 transition-colors'>
							{data.name}
						</h3>
					</div>
					<div
						className={clsx(
							'p-1.5 rounded-lg shadow-sm border bg-background',
							config.tailwind.border,
							config.tailwind.text
						)}>
						<Icon size={16} />
					</div>
				</div>
				{tags && <p className='text-[11px] font-medium text-gray-500 mt-1.5 pb-2 border-b border-border/50'>{tags}</p>}
			</div>

			<div className='p-4 pt-3'>
				<p className='text-xs text-gray-600 overflow-auto h-full max-h-32 leading-relaxed'>
					{data.description || 'No overview available.'}
				</p>
			</div>

			<div className='bg-muted/50 p-2 border-t border-border flex justify-end'>
				<span className='text-[10px] font-semibold text-gray-400 flex items-center gap-1 group-hover:text-amber-600 transition-colors'>
					View Details <ArrowRight size={10} />
				</span>
			</div>
		</div>
	);
};

--- END OF features\smart-tooltip\components\TooltipCard.jsx ---

--- FILE: features\table-of-contents\TableOfContents.jsx ---
import { useState } from 'react';
import { clsx } from 'clsx';
import { List, AlignLeft } from 'lucide-react';
import { useTocObserver } from './hooks/useTocObserver';
import { useTocScroll } from './hooks/useTocScroll';
import { TocItem } from './components/TocItem';
import { TocMobileDrawer } from './components/TocMobileDrawer';

export const TableOfContents = ({
	items,
	className,
	visibilityClass = 'hidden 2xl:block',
	mobileToggleClass = '2xl:hidden',
}) => {
	const [isOpen, setIsOpen] = useState(false);

	// Hooks
	const activeId = useTocObserver(items.map((i) => i.id));
	const { scrollToId } = useTocScroll(() => setIsOpen(false));

	if (!items || items.length === 0) return null;

	const renderList = () => (
		<div className='flex flex-col space-y-0.5'>
			{items.map((item) => (
				<TocItem key={item.id} item={item} isActive={activeId === item.id} onClick={scrollToId} />
			))}
		</div>
	);

	return (
		<>
			{/* --- DESKTOP VIEW --- */}
			{/* 
				Sticky Positioning Logic:
				- top-40 (160px): Increased from top-32 to ensure no overlap with sticky TabContainers or Headers.
				- self-start: Critical for CSS Grid contexts (like Timeline) to prevent the item from stretching 
				  to full height, which breaks sticky behavior.
			*/}
			<div className={clsx(visibilityClass, 'sticky top-70 w-64 shrink-0 self-start', className)}>
				<div className='max-h-[calc(100vh-12rem)] overflow-y-auto custom-scrollbar pb-10 pr-2'>
					<div className='flex items-center gap-2 mb-4 px-4 text-xs font-bold uppercase tracking-widest text-gray-400'>
						<AlignLeft size={12} />
						<span>On this Page</span>
					</div>
					<nav>{renderList()}</nav>
				</div>
			</div>

			{/* --- MOBILE/TABLET TOGGLE --- */}
			<div className={clsx('fixed bottom-6 right-6 z-40', mobileToggleClass)}>
				<button
					onClick={() => setIsOpen(true)}
					className='h-12 w-12 bg-background border border-border shadow-lg rounded-full flex items-center justify-center text-foreground hover:bg-amber-50 hover:border-amber-300 hover:text-amber-700 transition-all active:scale-95'
					aria-label='Open Table of Contents'>
					<List size={20} />
				</button>
			</div>

			{/* --- MOBILE DRAWER --- */}
			<TocMobileDrawer
				isOpen={isOpen}
				items={items}
				activeId={activeId}
				onClose={() => setIsOpen(false)}
				onScrollTo={scrollToId}
			/>
		</>
	);
};

--- END OF features\table-of-contents\TableOfContents.jsx ---

--- FILE: features\table-of-contents\components\TocItem.jsx ---
import { clsx } from 'clsx';

export const TocItem = ({ item, isActive, onClick }) => {
	return (
		<button
			onClick={() => onClick(item.id)}
			className={clsx(
				'group flex items-start text-left w-full py-1.5 transition-all duration-200 border-l-[3px] px-4',
				isActive
					? 'border-amber-600 text-amber-700 font-bold bg-amber-50/50'
					: 'border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300'
			)}>
			<span className={clsx('text-[13px] leading-snug', item.depth === 3 && 'ml-3 opacity-90 text-[12px]')}>
				{item.text}
			</span>
		</button>
	);
};

--- END OF features\table-of-contents\components\TocItem.jsx ---

--- FILE: features\table-of-contents\components\TocMobileDrawer.jsx ---
import { Drawer } from '../../../components/ui/Drawer';
import { TocItem } from './TocItem';

export const TocMobileDrawer = ({ isOpen, items, activeId, onClose, onScrollTo }) => {
	return (
		<Drawer isOpen={isOpen} onClose={onClose} title='Table of Contents' position='right'>
			<div className='py-4 flex flex-col space-y-0.5'>
				{items.map((item) => (
					<TocItem key={item.id} item={item} isActive={activeId === item.id} onClick={onScrollTo} />
				))}
			</div>
		</Drawer>
	);
};

--- END OF features\table-of-contents\components\TocMobileDrawer.jsx ---

--- FILE: features\table-of-contents\hooks\useTocObserver.js ---
import { useState, useEffect, useRef } from 'react';

export function useTocObserver(itemIds) {
	const [activeId, setActiveId] = useState('');
	const observer = useRef(null);
	const headingsMap = useRef(new Map());

	useEffect(() => {
		// 1. Safety Check
		if (!itemIds || itemIds.length === 0) return;

		// 2. The Callback
		const handleObserver = (entries) => {
			entries.forEach((entry) => {
				// Store all intersecting states in a map
				headingsMap.current.set(entry.target.id, entry);
			});

			// 3. Determine the "Winner"
			// We find the first visible heading from the top
			const visibleHeadings = [];

			headingsMap.current.forEach((entry) => {
				if (entry.isIntersecting) {
					visibleHeadings.push(entry);
				}
			});

			if (visibleHeadings.length > 0) {
				// Sort by their position relative to the top of the viewport
				// The one closest to 0 (top) without being way off-screen is the winner
				visibleHeadings.sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top);

				// Pick the top-most visible one
				setActiveId(visibleHeadings[0].target.id);
			} else {
				// Edge case: User scrolled past a section but next one hasn't entered.
				// We keep the last active ID or check if we are at the very top.
				const scrollY = window.scrollY;
				if (scrollY < 100 && itemIds.length > 0) {
					setActiveId(itemIds[0]);
				}
			}
		};

		// 4. Initialize Observer
		// rootMargin: '-10% 0px -80% 0px' creates a "reading line" at the top of the screen.
		// An element must cross this top zone to trigger the update.
		observer.current = new IntersectionObserver(handleObserver, {
			rootMargin: '-80px 0px -80% 0px',
			threshold: [0, 1],
		});

		// 5. Observe elements
		itemIds.forEach((id) => {
			const el = document.getElementById(id);
			if (el) {
				observer.current.observe(el);
			}
		});

		return () => {
			if (observer.current) observer.current.disconnect();
			headingsMap.current.clear();
		};
	}, [itemIds]);

	return activeId;
}

--- END OF features\table-of-contents\hooks\useTocObserver.js ---

--- FILE: features\table-of-contents\hooks\useTocScroll.js ---
import { useCallback } from 'react';

export function useTocScroll(callback) {
	const scrollToId = useCallback(
		(id) => {
			const element = document.getElementById(id);

			if (element) {
				// CSS 'scroll-margin-top' handles the offset (sticky header)
				element.scrollIntoView({ behavior: 'smooth', block: 'start' });

				// Optional callback (e.g., to close mobile drawer)
				if (callback) callback();
			} else {
				console.warn(`[ToC] Target element not found: #${id}`);
			}
		},
		[callback]
	);

	return { scrollToId };
}

--- END OF features\table-of-contents\hooks\useTocScroll.js ---

--- FILE: features\timeline\TimelineView.jsx ---
import { useTimelineViewModel } from './useTimelineViewModel';
import { TimelineSession } from './components/TimelineSession';
import { TableOfContents } from '../table-of-contents/TableOfContents';

export default function TimelineView() {
	const { sessions, isLoading } = useTimelineViewModel();

	if (isLoading) return <div className='p-8 text-center text-gray-400'>Loading timeline...</div>;

	// Construct ToC items manually for the timeline sessions
	const tocItems = sessions.map((s) => ({
		id: `session-marker-${s.number}`,
		text: `${s.title}`,
		depth: 1,
	}));

	return (
		<div className='h-full overflow-hidden flex flex-col'>
			<div className='flex-1 overflow-y-auto bg-background custom-scrollbar'>
				{/* ARCHITECTURE FIX: Grid Layout for Timeline + ToC */}
				<div className='max-w-7xl mx-auto p-6 md:p-12'>
					<h1 className='text-3xl font-serif font-bold text-foreground mb-10'>Campaign History</h1>

					<div className='grid grid-cols-1 xl:grid-cols-[1fr_240px] gap-12 relative'>
						{/* Column 1: Timeline Content */}
						<div className='relative border-l-2 border-slate-100 ml-4 space-y-16 pb-20'>
							{sessions.map((session) => (
								/* Added scroll-mt to account for sticky headers if any */
								<div key={session.id} id={`session-marker-${session.number}`} className='scroll-mt-24'>
									<TimelineSession session={session} />
								</div>
							))}
						</div>

						{/* Column 2: ToC */}
						{/* Sync visibility with the grid breakpoint (xl) */}
						<TableOfContents items={tocItems} visibilityClass='hidden xl:block' mobileToggleClass='xl:hidden' />
					</div>
				</div>
			</div>
		</div>
	);
}

--- END OF features\timeline\TimelineView.jsx ---

--- FILE: features\timeline\types.js ---
/**
 * @typedef {Object} EventStyle
 * @property {Object} Icon - Lucide React Component
 * @property {string} container - Tailwind classes for the bubble (bg, border, text)
 * @property {string} line - Tailwind classes for the connector line
 */

/**
 * @typedef {Object} TimelineEventModel
 * @property {string} id
 * @property {string} title
 * @property {string} typeLabel
 * @property {string} description
 * @property {Object|null} location - { name: string }
 * @property {Object|null} npc - { name: string }
 * @property {EventStyle} style
 */

/**
 * @typedef {Object} TimelineSessionModel
 * @property {string} id
 * @property {number} number
 * @property {string} dateLabel
 * @property {string} title
 * @property {TimelineEventModel[]} events
 */

export {};

--- END OF features\timeline\types.js ---

--- FILE: features\timeline\useTimelineViewModel.js ---
import { useMemo } from 'react';
import { useQuery } from '@tanstack/react-query';
import { getTimeline } from '../../services/timeline'; // Adjust path based on your root
import { useCampaign } from '../../features/campaign-session/CampaignContext';
import { getEventStyle } from './utils/eventStyles';
import './types';

/**
 * @returns {{ sessions: import('./types').TimelineSessionModel[], isLoading: boolean }}
 */
export function useTimelineViewModel() {
	const { campaignId } = useCampaign();

	const { data, isLoading } = useQuery({
		queryKey: ['timeline', campaignId],
		queryFn: () => getTimeline(campaignId),
		enabled: !!campaignId,
	});

	const sessions = useMemo(() => {
		return (data || []).map((session) => {
			// Sort events safely: Use spread to avoid mutating read-only cache, handle nulls
			const sortedEvents = [...(session.events || [])].sort((a, b) => (a.event_order || 0) - (b.event_order || 0));

			// Map events to View Model
			const events = sortedEvents.map((event) => {
				// TRANSFORMATION: Convert relationships to tags
				const tags = (event.relationships || [])
					.map((rel) => {
						if (!rel.target) return null;
						return {
							name: rel.target.name,
							type: rel.target.type?.toLowerCase() || 'default',
						};
					})
					.filter(Boolean); // Remove nulls

				return {
					id: event.id,
					title: event.title,
					typeLabel: event.event_type?.replace(/_/g, ' ') || 'Event',
					description: event.description,
					tags, // New property containing all connected entities
					style: getEventStyle(event.event_type),
				};
			});

			return {
				id: session.id,
				number: session.session_number,
				dateLabel: session.session_date || 'Unknown Date',
				title: session.title,
				events,
			};
		});
	}, [data]);

	return { sessions, isLoading };
}

--- END OF features\timeline\useTimelineViewModel.js ---

--- FILE: features\timeline\components\TimelineEvent.jsx ---
import { clsx } from 'clsx';
import { getEntityConfig } from '../../../config/entity'; // Use central config
import SmartMarkdown from '../../smart-text/SmartMarkdown';

export const TimelineEvent = ({ event }) => {
	const { Icon, container } = event.style;

	return (
		<div className='relative flex gap-4 group'>
			{/* Icon Bubble */}
			<div
				className={clsx(
					'shrink-0 w-8 h-8 rounded-full flex items-center justify-center shadow-sm border-2 z-10 transition-transform group-hover:scale-110',
					container
				)}>
				<Icon size={14} strokeWidth={2.5} />
			</div>

			{/* Content */}
			<div className='flex-1 -mt-1 pb-2'>
				<h4 className='text-sm font-bold text-gray-800 mb-1 flex items-center gap-2'>
					{event.title}
					<span className='text-[9px] font-normal uppercase tracking-wider text-gray-800 border border-border px-1.5 rounded-sm bg-muted ml-auto'>
						{event.typeLabel}
					</span>
				</h4>

				{event.description && (
					<div className='text-sm text-gray-600 leading-relaxed text-pretty text-justify'>
						<SmartMarkdown>{event.description}</SmartMarkdown>
					</div>
				)}

				{/* Dynamic Tags - Refactored to use Entity Config */}
				{event.tags && event.tags.length > 0 && (
					<div className='flex flex-wrap gap-2 mt-2'>
						{event.tags.map((tag, idx) => {
							const config = getEntityConfig(tag.type);
							const TagIcon = config.icon;
							const styles = config.tailwind;

							return (
								<span
									key={`${tag.name}-${idx}`}
									className={clsx(
										'inline-flex items-center gap-1 text-[10px] uppercase font-bold px-1.5 py-0.5 rounded border cursor-default',
										// Use dynamic styles from config
										styles.bg,
										styles.text,
										styles.border
									)}>
									<TagIcon size={10} /> {tag.name}
								</span>
							);
						})}
					</div>
				)}
			</div>
		</div>
	);
};

--- END OF features\timeline\components\TimelineEvent.jsx ---

--- FILE: features\timeline\components\TimelineSession.jsx ---
import { Calendar } from 'lucide-react';
import { TimelineEvent } from './TimelineEvent';

export const TimelineSession = ({ session }) => {
	return (
		<div className='relative pl-8 md:pl-12'>
			{/* Session Marker (Circle on the main line) */}
			<div className='absolute -left-[9px] top-0 flex items-center justify-center w-5 h-5 rounded-full bg-background border-2 border-gray-300 shadow-sm z-10'>
				<div className='w-2 h-2 rounded-full bg-gray-400' />
			</div>

			{/* Session Header */}
			<div className='mb-8'>
				<div className='flex flex-col sm:flex-row sm:items-center gap-2 sm:gap-4 mb-2'>
					<span className='text-[10px] font-bold uppercase tracking-wider text-gray-500 bg-gray-100 px-2 py-0.5 rounded self-start border border-border'>
						Session {session.number - 1}
					</span>
					<time className='text-xs text-gray-400 flex items-center gap-1 font-medium'>
						<Calendar size={12} /> {session.dateLabel}
					</time>
				</div>
				<h2 className='text-2xl font-serif font-bold text-foreground mb-3'>{session.title}</h2>
			</div>

			{/* Events List */}
			<div className='space-y-6 relative'>
				{/* Connector Line for events */}
				<div className='absolute left-[15px] top-4 bottom-4 w-0.5 bg-gray-100 -z-10' />

				{session.events.map((event) => (
					<TimelineEvent key={event.id} event={event} />
				))}
			</div>
		</div>
	);
};

--- END OF features\timeline\components\TimelineSession.jsx ---

--- FILE: features\timeline\utils\eventStyles.js ---
import { getEntityStyles } from '../../../config/entity';
import {
	Sword,
	Skull,
	MessageSquare,
	Scroll,
	CheckCircle2,
	Footprints,
	Map,
	MapPin,
	User,
	Flag,
	Search,
	BookOpen,
	Sparkles,
	Eye,
	ShoppingBag,
	Star,
	Tent,
} from 'lucide-react';

export const getEventStyle = (eventType) => {
	const type = eventType?.toLowerCase() || '';

	let entityType = 'default';
	let Icon = Star;

	switch (type) {
		case 'combat':
			entityType = 'encounter'; // Orange
			Icon = Skull;
			break;
		case 'social':
			entityType = 'npc'; // Amber
			Icon = MessageSquare;
			break;
		case 'quest_started':
			entityType = 'quest'; // Blue
			Icon = Scroll;
			break;
		case 'quest_progressed':
			entityType = 'quest'; // Blue
			Icon = CheckCircle2;
			break;
		case 'travel':
			entityType = 'location'; // Emerald
			Icon = Footprints; // Journeys
			break;
		case 'location_discovered':
			entityType = 'location'; // Emerald
			Icon = Map; // Finding new places
			break;
		case 'location_visited':
			entityType = 'location'; // Emerald
			Icon = MapPin; // Arriving at known places
			break;
		case 'npc_encountered':
			entityType = 'npc'; // Amber
			Icon = User;
			break;
		case 'faction_discovered':
			entityType = 'faction'; // Purple
			Icon = Flag;
			break;
		case 'investigation':
			entityType = 'default'; // Gray (Neutral/Mechanics)
			Icon = Search;
			break;
		case 'backstory':
			entityType = 'character'; // Red (Personal)
			Icon = BookOpen;
			break;
		case 'discovery':
			entityType = 'encounter'; // Orange (Loot/Items/Secrets)
			Icon = Sparkles;
			break;
		case 'vision':
			entityType = 'faction'; // Purple (Magic/Mystical)
			Icon = Eye;
			break;
		case 'shopping':
			entityType = 'npc'; // Amber (Trade/Commerce)
			Icon = ShoppingBag;
			break;
		case 'special_event':
			entityType = 'session'; // Slate (Meta/Unique)
			Icon = Star;
			break;
		// Fallbacks for legacy types or fuzzy matches
		default:
			if (type.match(/combat|fight|kill/)) {
				entityType = 'encounter';
				Icon = Sword;
			} else if (type.match(/npc|social|meet/)) {
				entityType = 'npc';
				Icon = MessageSquare;
			} else if (type.match(/location|visit|arrive/)) {
				entityType = 'location';
				Icon = MapPin;
			} else if (type.match(/quest|mission/)) {
				entityType = 'quest';
				Icon = Scroll;
			} else if (type.match(/camp|rest/)) {
				entityType = 'location';
				Icon = Tent;
			} else {
				entityType = 'default';
				Icon = Star;
			}
	}

	// Use centralized styles
	const styles = getEntityStyles(entityType);

	return {
		Icon,
		// Map standard styles to timeline specific class structure
		container: `${styles.border} ${styles.bg} ${styles.text}`,
		// Heuristic for line color (usually 200 or 300 shade) based on bg class
		line: styles.bg.replace('-50', '-200'),
	};
};

--- END OF features\timeline\utils\eventStyles.js ---

--- FILE: features\wiki-layout\types.js ---
/**
 * @typedef {Object} WikiConfig
 * @property {string} label - Pluralized label (e.g., "Characters")
 * @property {Object} Icon - Lucide React Icon
 * @property {string} textClass - Tailwind text color class
 */

/**
 * @typedef {Object} WikiNavItem
 * @property {string} id
 * @property {string} name
 * @property {string} path - The relative path for the link
 */

/**
 * @typedef {Object} WikiNavigationModel
 * @property {WikiConfig} config
 * @property {boolean} isLoading
 * @property {boolean} hasItems - True if any items exist (ignoring filter)
 * @property {WikiNavItem[]} items - The filtered list to display
 * @property {string} search - Current search term
 * @property {function(string): void} setSearch - Search setter
 */

export {};

--- END OF features\wiki-layout\types.js ---

--- FILE: features\wiki-layout\useWikiNavigation.js ---
import { useState } from 'react';
import { useParams } from 'react-router-dom';
import { getEntityConfig } from '../../config/entity';
import { useEntityFetching } from './hooks/useEntityFetching';
import { useEntityGrouping } from './hooks/useEntityGrouping';
import './types';

export function useWikiNavigation() {
	const { type } = useParams();
	const [search, setSearch] = useState('');

	const normalizedType = type === 'sessions' ? 'session' : type;

	// 1. Fetch entities
	const { entities, isLoading } = useEntityFetching(normalizedType);

	// 2. Group and filter entities
	const groups = useEntityGrouping(entities, normalizedType, search);

	// 3. Build UI config
	const entityConfig = getEntityConfig(normalizedType);
	const config = {
		label: `${entityConfig.label}s`,
		Icon: entityConfig.icon,
		textClass: entityConfig.tailwind.text,
	};

	return {
		config,
		isLoading,
		hasItems: groups.length > 0 && groups.some((g) => g.items.length > 0),
		groups,
		search,
		setSearch,
	};
}

--- END OF features\wiki-layout\useWikiNavigation.js ---

--- FILE: features\wiki-layout\WikiLayout.jsx ---
import { Outlet, useNavigate, useParams } from 'react-router-dom';
import { useEffect } from 'react';
import { useWikiNavigation } from './useWikiNavigation';
import { WikiSidebar } from './components/WikiSidebar';

export default function WikiLayout() {
	const navigation = useWikiNavigation();
	const navigate = useNavigate();
	const { type, entityId } = useParams();

	// Auto-select first item if on index route and items exist
	useEffect(() => {
		// Only run if:
		// 1. We're on the index route (no entityId)
		// 2. Data has loaded
		// 3. We have groups with items
		if (!entityId && !navigation.isLoading && navigation.groups.length > 0) {
			// Find the first item across all groups
			const firstGroup = navigation.groups[0];
			if (firstGroup && firstGroup.items.length > 0) {
				const firstItem = firstGroup.items[0];
				// Navigate to the first item
				navigate(`/wiki/${type}/${firstItem.path}`, { replace: true });
			}
		}
	}, [entityId, navigation.isLoading, navigation.groups, navigate, type]);

	return (
		<div className='relative flex flex-col lg:flex-row h-full bg-background overflow-hidden'>
			<WikiSidebar navigation={navigation} className='lg:w-72 lg:order-2 lg:border-l lg:border-border lg:h-full z-30' />

			<div className='flex-1 lg:order-1 overflow-y-auto bg-background relative z-0'>
				<Outlet />
			</div>
		</div>
	);
}

--- END OF features\wiki-layout\WikiLayout.jsx ---

--- FILE: features\wiki-layout\components\SidebarEmptyState.jsx ---
import { BookOpen } from 'lucide-react';
import EmptyState from '../../../components/ui/EmptyState'; // Adjust path

export const SidebarEmptyState = ({ label }) => {
	// Remove 's' from end for singular usage if needed, or just use as is
	const singular = label.endsWith('s') ? label.slice(0, -1) : label;

	return (
		<EmptyState
			icon={BookOpen}
			title={`No ${label} Yet`}
			description={`Create your first ${singular.toLowerCase()} to get started.`}
			className='py-8'
		/>
	);
};

--- END OF features\wiki-layout\components\SidebarEmptyState.jsx ---

--- FILE: features\wiki-layout\components\WikiSidebar.jsx ---
import { useState } from 'react';
import { clsx } from 'clsx';
import { WikiSidebarHeader } from './WikiSidebarHeader';
import { WikiSidebarList } from './WikiSidebarList';

export const WikiSidebar = ({ navigation, className }) => {
	const [mobileOpen, setMobileOpen] = useState(false);

	return (
		<div
			className={clsx(
				'bg-muted border-b border-border flex flex-col transition-all',
				'sticky top-0 w-full z-30',
				'lg:static lg:border-b-0 lg:w-72 lg:order-2 lg:border-l lg:border-border lg:h-full',
				className
			)}>
			{/* Header - Always Visible */}
			<WikiSidebarHeader
				config={navigation.config}
				search={navigation.search}
				onSearchChange={navigation.setSearch}
				onToggle={() => setMobileOpen(!mobileOpen)}
				isOpen={mobileOpen}
			/>

			{/* Content - Collapsible on Mobile, Static on Desktop */}
			<div
				className={clsx(
					'bg-muted border-b border-border shadow-xl max-h-[60vh] overflow-y-auto',
					'lg:static lg:shadow-none lg:border-0 lg:max-h-full lg:flex-1 lg:flex lg:flex-col',
					// Mobile: Dropdown behavior
					mobileOpen ? 'absolute top-full left-0 right-0 block' : 'hidden lg:flex'
				)}>
				<WikiSidebarList
					groups={navigation.groups}
					isLoading={navigation.isLoading}
					hasItems={navigation.hasItems}
					config={navigation.config}
					onItemClick={() => setMobileOpen(false)}
				/>
			</div>

			{/* Mobile Backdrop (when expanded) */}
			{mobileOpen && (
				<div className='fixed inset-0 bg-black/20 z-[-1] lg:hidden' onClick={() => setMobileOpen(false)} />
			)}
		</div>
	);
};

--- END OF features\wiki-layout\components\WikiSidebar.jsx ---

--- FILE: features\wiki-layout\components\WikiSidebarHeader.jsx ---
import { Search, ChevronDown, ChevronUp } from 'lucide-react';
import { clsx } from 'clsx';

export const WikiSidebarHeader = ({ config, search, onSearchChange, onToggle, isOpen }) => {
	const { Icon, label, textClass } = config;

	return (
		<div className='p-3 lg:p-4 bg-muted border-b border-border/50'>
			{/* Title Row - Clickable on mobile */}
			<div
				className='flex items-center justify-between cursor-pointer lg:cursor-default select-none'
				onClick={onToggle}>
				<div className='flex items-center gap-2.5'>
					{Icon && <Icon size={16} className={textClass} />}
					<h1 className='text-sm font-serif font-bold text-foreground capitalize tracking-wide'>{label}</h1>
				</div>

				{/* Mobile Toggle Button */}
				<button className='lg:hidden text-gray-500 hover:text-foreground hover:bg-black/5 p-1 rounded transition-colors'>
					{isOpen ? <ChevronUp size={16} /> : <ChevronDown size={16} />}
				</button>
			</div>

			{/* Search Bar - Always visible on desktop, hidden when collapsed on mobile */}
			<div className={clsx('mt-3 relative', !isOpen && 'hidden lg:block')}>
				<Search className='absolute left-2.5 top-2 text-gray-400' size={13} />
				<input
					type='text'
					placeholder='Filter list...'
					value={search}
					onChange={(e) => onSearchChange(e.target.value)}
					onClick={(e) => e.stopPropagation()}
					className='w-full bg-background border border-border rounded-md pl-8 pr-2 py-1.5 text-xs focus:ring-1 focus:ring-amber-500/50 focus:border-amber-500 outline-none transition-shadow shadow-sm'
				/>
			</div>
		</div>
	);
};

--- END OF features\wiki-layout\components\WikiSidebarHeader.jsx ---

--- FILE: features\wiki-layout\components\WikiSidebarList.jsx ---
import LoadingSpinner from '../../../components/ui/LoadingSpinner';
import { SidebarEmptyState } from './SidebarEmptyState';
import { CollapsibleGroup } from './sidebar/CollapsibleGroup';
import { EntityListItem } from './sidebar/EntityListItem';
import { SidebarTreeItem } from './sidebar/SidebarTreeItem';

export const WikiSidebarList = ({ groups, isLoading, hasItems, config, onItemClick }) => {
	if (isLoading) {
		return (
			<div className='p-8 flex justify-center'>
				<LoadingSpinner size='sm' text='Loading...' />
			</div>
		);
	}

	if (!hasItems) {
		return <SidebarEmptyState label={config.label} />;
	}

	// Flatten check for empty search results
	const totalItems = groups.reduce((acc, g) => acc + g.items.length, 0);
	if (totalItems === 0) {
		return <div className='p-6 text-center text-xs text-gray-400 italic'>No matches found.</div>;
	}

	// Check if we have standard grouped data (multiple groups with titles)
	const isGrouped = !groups[0].isTree && (groups.length > 1 || (groups.length === 1 && groups[0].title !== null));

	return (
		<div className='lg:overflow-y-auto lg:h-full bg-muted py-1 custom-scrollbar'>
			{/* MODE 1: TREE (Recursive) */}
			{groups[0].isTree ? (
				<div className='px-1 space-y-0.5'>
					{groups[0].items.map((item) => (
						<SidebarTreeItem key={item.id} item={item} onItemClick={onItemClick} />
					))}
				</div>
			) : /* MODE 2: GROUPED (Collapsible Categories) */
			isGrouped ? (
				<div className='space-y-1'>
					{groups.map((group) => (
						<CollapsibleGroup key={group.id} group={group} onItemClick={onItemClick} />
					))}
				</div>
			) : (
				/* MODE 3: FLAT LIST */
				<div className='px-2 space-y-0.5'>
					{groups[0].items.map((item) => {
						const showStatus = ['npc', 'faction', 'quest'].includes(item.type);
						return <EntityListItem key={item.id} item={item} showStatus={showStatus} onItemClick={onItemClick} />;
					})}
				</div>
			)}
		</div>
	);
};

--- END OF features\wiki-layout\components\WikiSidebarList.jsx ---

--- FILE: features\wiki-layout\components\sidebar\CollapsibleGroup.jsx ---
import { useState } from 'react';
import { ChevronRight, ChevronDown } from 'lucide-react';
import { EntityListItem } from './EntityListItem';

export const CollapsibleGroup = ({ group, onItemClick }) => {
	const [isOpen, setIsOpen] = useState(true);

	// Determine if we should show status icons
	const showStatus = group.items.some((item) => ['npc', 'faction', 'quest'].includes(item.type));

	return (
		<div className='select-none'>
			{/* Group Header - Collapsible */}
			<button
				onClick={() => setIsOpen(!isOpen)}
				className='w-full flex items-center gap-1.5 px-2 py-1 text-[11px] font-semibold uppercase tracking-wider text-gray-500 hover:text-gray-700 hover:bg-black/5 transition-colors'>
				{isOpen ? <ChevronDown size={12} /> : <ChevronRight size={12} />}
				<span className='truncate'>{group.title}</span>
				<span className='ml-auto text-[10px] font-normal text-gray-400'>{group.items.length}</span>
			</button>

			{/* Items */}
			{isOpen && (
				<div className='space-y-0.5 pb-1'>
					{group.items.map((item) => (
						<EntityListItem key={item.id} item={item} showStatus={showStatus} onItemClick={onItemClick} />
					))}
				</div>
			)}
		</div>
	);
};

--- END OF features\wiki-layout\components\sidebar\CollapsibleGroup.jsx ---

--- FILE: features\wiki-layout\components\sidebar\EntityListItem.jsx ---
import { NavLink } from 'react-router-dom';
import { clsx } from 'clsx';
import { StatusIcon } from './StatusIcon';
import { PriorityIcon } from './PriorityIcon';
import EntityIcon from '../../../../components/entity/EntityIcon';
import { resolveImageUrl } from '../../../../utils/image/imageResolver';
import { resolveEntityIcon } from '../../../../config/entity/icons'; // Import Central Config

export const EntityListItem = ({ item, showStatus, onItemClick }) => {
	const isQuest = item.type === 'quest';
	const hasPriority = isQuest && item.meta.priority;

	const iconUrl = resolveImageUrl(item.attributes, 'icon');
	const hasCustomIcon = !!iconUrl;

	// Use Centralized Resolver
	const ResolvedIcon = resolveEntityIcon({ type: item.type, attributes: item.attributes });

	// Determine if we show the icon.
	// Logic: If it has a custom icon, YES.
	// If it's a specific type that usually hides icons in lists (like Quest/Faction) because Status is more important, check here.
	// We can add a property to ENTITY_TYPES config or keep a minimal logic here, but relying on the resolver is safer.
	const shouldShowIcon = hasCustomIcon || !['quest', 'faction'].includes(item.type);

	return (
		<NavLink
			to={item.path}
			onClick={onItemClick}
			className={({ isActive }) =>
				clsx(
					'group flex items-center w-full text-left pl-6 pr-2 py-1 text-[13px] transition-colors',
					isActive ? 'bg-accent/10 text-accent font-medium' : 'text-gray-700 hover:bg-black/5 hover:text-foreground'
				)
			}>
			{shouldShowIcon && (
				<span
					className={clsx(
						'shrink-0 flex items-center justify-center mr-2',
						!hasCustomIcon && 'opacity-70 text-stone-500'
					)}>
					{hasCustomIcon ? (
						<EntityIcon type={item.type} customIconUrl={iconUrl} size={16} className='rounded-full object-cover' />
					) : (
						<ResolvedIcon size={14} />
					)}
				</span>
			)}

			{showStatus && (
				<span
					className={clsx(
						'flex-shrink-0 flex items-center justify-center opacity-70',
						hasPriority ? 'mr-1' : 'mr-2',
						!shouldShowIcon && 'ml-[-2px]'
					)}>
					<StatusIcon entity={item} />
				</span>
			)}

			{hasPriority && (
				<span className='mr-2 flex-shrink-0 flex items-center justify-center opacity-90'>
					<PriorityIcon priority={item.meta.priority} />
				</span>
			)}

			<span className='truncate flex-1'>{item.name}</span>
		</NavLink>
	);
};

--- END OF features\wiki-layout\components\sidebar\EntityListItem.jsx ---

--- FILE: features\wiki-layout\components\sidebar\PriorityIcon.jsx ---
import { ChevronsUp, ChevronsDown, Minus, AlertCircle } from 'lucide-react';

export const PriorityIcon = ({ priority }) => {
	if (!priority) return null;
	const p = priority.toLowerCase();

	// High / Urgent
	if (p.includes('high') || p.includes('urgent') || p.includes('critical')) {
		return <ChevronsUp size={14} className='text-orange-600' strokeWidth={3} />;
	}

	// Low
	if (p.includes('low')) {
		return <ChevronsDown size={14} className='text-slate-400' strokeWidth={3} />;
	}

	// Medium / Normal
	if (p.includes('medium') || p.includes('normal')) {
		return <Minus size={14} className='text-blue-400' strokeWidth={3} />;
	}

	return null;
};

--- END OF features\wiki-layout\components\sidebar\PriorityIcon.jsx ---

--- FILE: features\wiki-layout\components\sidebar\SidebarTreeItem.jsx ---
import { useState } from 'react';
import { NavLink } from 'react-router-dom';
import { ChevronRight, ChevronDown } from 'lucide-react';
import { clsx } from 'clsx';
import EntityIcon from '../../../../components/entity/EntityIcon';
import { StatusIcon } from './StatusIcon';
import { resolveImageUrl } from '../../../../utils/image/imageResolver';
import { resolveEntityIcon } from '../../../../config/entity/icons'; // Import

export const SidebarTreeItem = ({ item, onItemClick }) => {
	const [isExpanded, setIsExpanded] = useState(true);
	const hasChildren = item.children && item.children.length > 0;
	const showStatus = ['npc', 'faction', 'quest'].includes(item.type);

	const iconUrl = resolveImageUrl(item.attributes, 'icon');
	const hasCustomIcon = !!iconUrl;

	// Use centralized resolver
	const ResolvedIcon = resolveEntityIcon({ type: item.type, attributes: item.attributes });

	return (
		<div className='select-none font-sans'>
			<div className='flex items-center w-full group py-0.5 hover:bg-black/5 rounded-sm transition-colors'>
				<button
					onClick={(e) => {
						e.preventDefault();
						e.stopPropagation();
						if (hasChildren) setIsExpanded(!isExpanded);
					}}
					className={clsx(
						'w-5 h-6 flex items-center justify-center shrink-0 text-gray-400 hover:text-foreground transition-colors cursor-pointer',
						!hasChildren && 'invisible pointer-events-none'
					)}>
					{isExpanded ? <ChevronDown size={10} /> : <ChevronRight size={10} />}
				</button>

				<NavLink
					to={item.path}
					onClick={onItemClick}
					className={({ isActive }) =>
						clsx(
							'flex-1 flex items-center gap-1.5 pr-2 text-[13px] truncate transition-colors rounded-r-sm',
							isActive ? 'text-accent font-semibold bg-accent/5' : 'text-gray-700'
						)
					}>
					<span
						className={clsx(
							'shrink-0 flex items-center justify-center',
							!hasCustomIcon && 'opacity-100',
							!hasCustomIcon && (item.type === 'location' ? 'text-stone-400' : 'text-stone-600')
						)}>
						{hasCustomIcon ? (
							<EntityIcon type={item.type} customIconUrl={iconUrl} size={14} />
						) : (
							<ResolvedIcon size={14} strokeWidth={2} />
						)}
					</span>

					<span className='truncate'>{item.name}</span>
					{showStatus && (
						<span className='ml-auto opacity-70 flex items-center'>
							<StatusIcon entity={item} />
						</span>
					)}
				</NavLink>
			</div>
			{isExpanded && hasChildren && (
				<div className='ml-[9px] border-l border-border/60 pl-1'>
					{item.children.map((child) => (
						<SidebarTreeItem key={child.id} item={child} onItemClick={onItemClick} />
					))}
				</div>
			)}
		</div>
	);
};

--- END OF features\wiki-layout\components\sidebar\SidebarTreeItem.jsx ---

--- FILE: features\wiki-layout\components\sidebar\StatusIcon.jsx ---
import { getStatusIcon } from '../../../../utils/status/statusHelpers';

/**
 * StatusIcon Component
 * Displays status/affinity icon for entities in sidebar
 *
 * @param {Object} entity - Entity with status/affinity
 */
export const StatusIcon = ({ entity }) => {
	// Prioritize affinity over status for NPCs/Factions
	const statusValue = entity.affinity && entity.affinity !== 'unknown' ? entity.affinity : entity.status;

	const { Icon, className } = getStatusIcon(statusValue, entity.type);

	return <Icon size={12} className={className} strokeWidth={2.5} />;
};

--- END OF features\wiki-layout\components\sidebar\StatusIcon.jsx ---

--- FILE: features\wiki-layout\config\groupingConfig.js ---
export const GROUPING_CONFIG = {
	location: {
		mode: 'tree',
		sortItems: (a, b) => a.name.localeCompare(b.name),
	},
	npc: {
		mode: 'tree', // Changed from groupBy to tree
		sortItems: (a, b) => {
			// Locations (folders) should generally come first or sort A-Z
			if (a.type !== b.type) {
				// Locations first
				if (a.type === 'location') return -1;
				if (b.type === 'location') return 1;
			}

			// For NPCs: Rank by Affinity, then Name
			if (a.type === 'npc' && b.type === 'npc') {
				const rankDiff = a.meta.affinityRank - b.meta.affinityRank;
				if (rankDiff !== 0) return rankDiff;
			}

			return a.name.localeCompare(b.name);
		},
	},
	faction: {
		groupBy: (item) => {
			const rank = item.meta.affinityRank;
			if (rank === 1) return 'Allies';
			if (rank === 2) return 'Neutral';
			if (rank === 3) return 'Enemies';
			return 'Unknown';
		},
		sortGroups: ['Allies', 'Neutral', 'Enemies', 'Unknown'],
		sortItems: (a, b) => a.name.localeCompare(b.name),
	},
	quest: {
		groupBy: (item) => {
			const t = item.meta.questType.toLowerCase();
			if (t.includes('main')) return 'Main Quest';
			if (t.includes('personal')) return 'Personal Quest';
			return 'Side Quest';
		},
		sortGroups: ['Main Quest', 'Personal Quest', 'Side Quest'],
		sortItems: (a, b) => {
			const statusOrder = ['active', 'in progress', 'pending', 'completed', 'success', 'failed', 'abandoned'];
			const idxA = statusOrder.indexOf(a.meta.status);
			const idxB = statusOrder.indexOf(b.meta.status);
			const valA = idxA === -1 ? 99 : idxA;
			const valB = idxB === -1 ? 99 : idxB;
			if (valA !== valB) return valA - valB;
			return a.name.localeCompare(b.name);
		},
	},
};

--- END OF features\wiki-layout\config\groupingConfig.js ---

--- FILE: features\wiki-layout\hooks\useEntityFetching.js ---
import { useQuery } from '@tanstack/react-query';
import { useCampaign } from '../../campaign-session/CampaignContext';
import { getEntities } from '../../../services/entities';

/**
 * Fetches entity data for a given type
 * Handles query invalidation and error states
 */
export function useEntityFetching(type) {
	const { campaignId } = useCampaign();
	const normalizedType = type === 'sessions' ? 'session' : type;

	const {
		data: entities,
		isLoading,
		error,
	} = useQuery({
		queryKey: ['entities', campaignId, normalizedType],
		queryFn: async () => {
			// Special Case: For NPCs, we need Locations too to build the tree (Region -> City -> NPC)
			if (normalizedType === 'npc') {
				const [npcs, locations] = await Promise.all([
					getEntities(campaignId, 'npc'),
					getEntities(campaignId, 'location'),
				]);
				// Merge them (ensure uniqueness just in case, though types differ)
				return [...npcs, ...locations];
			}
			return getEntities(campaignId, normalizedType);
		},
		enabled: !!campaignId && !!normalizedType,
		staleTime: 1000 * 60 * 5, // 5 minutes
	});

	return {
		entities: entities || [],
		isLoading,
		error,
	};
}

--- END OF features\wiki-layout\hooks\useEntityFetching.js ---

--- FILE: features\wiki-layout\hooks\useEntityGrouping.js ---
import { useMemo } from 'react';
import { GROUPING_CONFIG } from '../config/groupingConfig';
import { transformEntityToViewModel } from '../transforms/entityTransforms';

// --- TREE BUILDER HELPER ---
const buildTree = (items, sortFn) => {
	const idMap = new Map();
	const roots = [];

	// 1. Initialize map
	items.forEach((item) => {
		idMap.set(item.id, { ...item, children: [] });
	});

	// 2. Build Hierarchy
	items.forEach((item) => {
		const node = idMap.get(item.id);
		const parentId = item.meta.parentId;

		if (parentId && idMap.has(parentId)) {
			const parent = idMap.get(parentId);
			parent.children.push(node);
		} else {
			roots.push(node);
		}
	});

	// 3. Prune Empty Folders (Recursive)
	// We want to remove 'location' nodes that have no children,
	// UNLESS we are in the Location wiki (where locations ARE the content).
	// But in NPC wiki, Locations are just containers.
	// Since we don't pass 'type' context here easily, we rely on the fact
	// that if a Location was fetched as a "container" for NPCs, it's expendable if empty.

	const prune = (nodes) => {
		// Filter out nodes that are locations AND have no children
		// But wait, if we are in Location View, we don't want to prune leaf locations.
		// Simple heuristic: If we are in 'tree' mode for NPCs, we probably have mixed types.
		// If ALL items are Locations, we shouldn't prune leaf locations.

		// Let's rely on the calling context. If we have mixed types, we prune "empty folders".
		const hasMixedTypes = items.some((i) => i.type === 'npc');

		if (!hasMixedTypes) return nodes; // Don't prune if we are just listing locations

		return nodes.filter((node) => {
			if (node.children.length > 0) {
				node.children = prune(node.children);
			}

			// If it's a location (folder) and has no children after pruning, remove it
			if (node.type === 'location' && node.children.length === 0) {
				return false;
			}
			return true;
		});
	};

	let finalRoots = prune(roots);

	// 4. Recursive Sort
	const sortRecursive = (nodes) => {
		if (sortFn) nodes.sort(sortFn);
		nodes.forEach((node) => {
			if (node.children.length > 0) {
				sortRecursive(node.children);
			}
		});
	};

	sortRecursive(finalRoots);
	return finalRoots;
};

export function useEntityGrouping(entities, type, searchQuery = '') {
	return useMemo(() => {
		if (!entities || entities.length === 0) return [];

		// 1. Filter by search
		const filtered = searchQuery
			? entities.filter((e) => e.name.toLowerCase().includes(searchQuery.toLowerCase()))
			: entities;

		// 2. Transform to view model
		const items = filtered.map((entity) => transformEntityToViewModel(entity, type));

		const strategy = GROUPING_CONFIG[type];

		// --- STRATEGY 1: TREE (Nested) ---
		if (strategy?.mode === 'tree') {
			const treeRoots = buildTree(items, strategy.sortItems);
			return [
				{
					id: 'root',
					title: null,
					items: treeRoots,
					isTree: true,
				},
			];
		}

		// --- STRATEGY 2: GROUPED (Flat Categories) ---
		if (strategy && strategy.groupBy) {
			const grouped = {};
			items.forEach((item) => {
				const groupKey = strategy.groupBy(item) || 'Other';
				if (!grouped[groupKey]) grouped[groupKey] = [];
				grouped[groupKey].push(item);
			});

			let groupKeys = Object.keys(grouped);

			if (typeof strategy.sortGroups === 'function') {
				groupKeys.sort(strategy.sortGroups);
			} else if (Array.isArray(strategy.sortGroups)) {
				groupKeys.sort((a, b) => {
					const idxA = strategy.sortGroups.indexOf(a);
					const idxB = strategy.sortGroups.indexOf(b);
					const valA = idxA === -1 ? 999 : idxA;
					const valB = idxB === -1 ? 999 : idxB;
					return valA - valB || a.localeCompare(b);
				});
			} else if (strategy.sortGroups === 'alpha') {
				groupKeys.sort();
			}

			return groupKeys.map((key) => {
				const groupItems = grouped[key];
				if (typeof strategy.sortItems === 'function') {
					groupItems.sort(strategy.sortItems);
				} else {
					groupItems.sort((a, b) => a.name.localeCompare(b.name));
				}
				return {
					id: key,
					title: key,
					items: groupItems,
				};
			});
		}

		// --- STRATEGY 3: DEFAULT (Flat A-Z) ---
		return [
			{
				id: 'all',
				title: null,
				items: items.sort((a, b) => a.name.localeCompare(b.name)),
			},
		];
	}, [entities, type, searchQuery]);
}

--- END OF features\wiki-layout\hooks\useEntityGrouping.js ---

--- FILE: features\wiki-layout\transforms\entityTransforms.js ---
import { getAttributeValue } from '../../../utils/entity/attributeParser';
import { getAffinityRank } from '../../../utils/status/statusHelpers';

// Helper to find parent relationship
const getParentId = (entity) => {
	const relationships = entity.relationships;
	if (!relationships || !Array.isArray(relationships)) return null;

	// 1. Check for explicit parent (Location hierarchy: Location -> Parent Location)
	const parentRel = relationships.find(
		(r) =>
			(r.type === 'parent_location' || r.type === 'parent') && (r.direction === 'outgoing' || r.direction === undefined)
	);
	if (parentRel) return parentRel.entity_id;

	// 2. Check for location link (NPC hierarchy: NPC -> Location)
	if (entity.type === 'npc') {
		// Get ALL relationships to locations
		const locationRels = relationships.filter((r) => r.entity_type === 'location');

		if (locationRels.length > 0) {
			// Priority 1: Look for specific semantic types
			const primary = locationRels.find((r) =>
				['location', 'located_in', 'base', 'home', 'residence', 'origin'].includes(r.type?.toLowerCase())
			);

			// Priority 2: Fallback to the first location found (e.g. generic 'related')
			return primary ? primary.entity_id : locationRels[0].entity_id;
		}
	}

	return null;
};

export function transformEntityToViewModel(entity, type) {
	// Context type (e.g. 'npc' or 'location')
	const contextType = type === 'sessions' ? 'session' : type;

	// Actual entity type (e.g. 'location' inside 'npc' view)
	const actualType = entity.type || contextType;

	// Extract raw values
	const statusRaw = getAttributeValue(entity.attributes, ['status', 'Quest Status']) || entity.status || 'unknown';
	const affinityRaw = getAttributeValue(entity.attributes, ['affinity', 'disposition']);

	const status = statusRaw.toLowerCase();
	const affinity = affinityRaw ? affinityRaw.toLowerCase() : 'unknown';

	// Determine effective sorting rank
	const effectiveSortString = affinity !== 'unknown' ? affinity : status;
	const affinityRank = getAffinityRank(effectiveSortString);

	// Extract Region & Quest Type
	const region = getAttributeValue(entity.attributes, ['region', 'parent location']) || 'Uncharted';
	const questType = getAttributeValue(entity.attributes, ['Quest Type', 'Type']) || 'Side Quest';

	// Extract Priority for Quests
	const priority = getAttributeValue(entity.attributes, ['Priority', 'priority']) || null;

	// Extract Parent ID using the smarter logic
	const parentId = getParentId(entity);

	return {
		id: entity.id,
		name: entity.name,
		path: entity.id,
		type: actualType, // Use actual type so icons render correctly

		status,
		affinity,
		attributes: entity.attributes || {},
		relationships: entity.relationships,

		meta: {
			status,
			affinity,
			affinityRank,
			region,
			questType,
			priority,
			parentId,
		},
	};
}

--- END OF features\wiki-layout\transforms\entityTransforms.js ---

--- FILE: features\world-map\mapConfig.js ---
export const MAP_CONFIG = {
	defaultCenter: [51.505, -0.09],
	defaultZoom: 13,
	tileLayer: {
		// Dark Matter theme matches your D&D aesthetic
		url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
		attribution: '&copy; <a href="https://carto.com/attributions">CARTO</a>',
	},
	style: {
		height: '100%',
		width: '100%',
		background: '#111',
	},
};

--- END OF features\world-map\mapConfig.js ---

--- FILE: features\world-map\MapView.jsx ---
import { useMapData } from './useMapData';
import { MapCanvas } from './components/MapCanvas';
import LoadingSpinner from '../../components/ui/LoadingSpinner';

export default function MapView() {
	const { data, navigateToMap, isLoading, currentMapKey } = useMapData();

	if (isLoading) {
		return (
			<div className='h-full flex items-center justify-center bg-[#1a1412]'>
				<LoadingSpinner text='Unrolling the parchment...' className='text-amber-500' />
			</div>
		);
	}

	return <MapCanvas data={data} onNavigate={navigateToMap} currentMapKey={currentMapKey} />;
}

--- END OF features\world-map\MapView.jsx ---

--- FILE: features\world-map\useMapData.js ---
import { useSearchParams } from 'react-router-dom';
import { useMemo } from 'react';
import { useCampaign } from '../campaign-session/CampaignContext';
import { getMapConfig } from './utils/mapNavigation';

export function useMapData() {
	const { campaignData } = useCampaign();
	const [searchParams, setSearchParams] = useSearchParams();

	const currentMapKey = searchParams.get('map') || 'world_map';

	const mapConfig = useMemo(() => {
		const sourceData = campaignData?.map_data || null;
		return getMapConfig(currentMapKey, sourceData);
	}, [currentMapKey, campaignData]);

	const viewData = useMemo(() => {
		if (!mapConfig) return null;

		const { metadata, annotations, paths, areas, overlays } = mapConfig;

		// --- MATH FIX ---
		const scaleFactor = Math.pow(2, metadata.sizes.maxZoom);
		const bounds = [
			[-metadata.sizes.imageHeight / scaleFactor, 0],
			[0, metadata.sizes.imageWidth / scaleFactor],
		];

		// --- MARKER FLATTENING ---
		const markers = [];
		if (annotations) {
			Object.entries(annotations).forEach(([categoryKey, category]) => {
				if (category.items) {
					category.items.forEach((item) => {
						markers.push({
							...item,
							category: category.name,
							categoryId: categoryKey,
							position: [Number(item.lat), Number(item.lng)],
						});
					});
				}
			});
		}

		// 3. Process Areas
		const mapAreas = [];
		if (areas) {
			Object.values(areas).forEach((category) => {
				category.items.forEach((area) => {
					mapAreas.push({
						...area,
						positions: area.points.map((p) => p.coordinates),
					});
				});
			});
		}

		return {
			config: metadata,
			bounds,
			markers,
			sessions: paths || [],
			areas: mapAreas,
			overlays: overlays || [],
		};
	}, [mapConfig]);

	const navigateToMap = (mapKey) => {
		setSearchParams({ map: mapKey });
	};

	return {
		data: viewData,
		currentMapKey,
		navigateToMap,
		isLoading: false, // FIX: Since we're using static data, never loading
	};
}

--- END OF features\world-map\useMapData.js ---

--- FILE: features\world-map\components\MapCanvas.jsx ---
import { useEffect, useState, useMemo, useRef } from 'react';
import { MapContainer, TileLayer, useMap } from 'react-leaflet';
import { Map, BookOpen, MapPin, Image as ImageIcon } from 'lucide-react';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';

import { MapMarkers } from './layers/MapMarkers';
import { MapRecaps } from './layers/MapRecaps';
import { MapAreas } from './layers/MapAreas';
import { MapOverlays } from './layers/MapOverlays';
import { MapLayerControl } from './MapLayerControl';
import { useMapCanvasViewModel } from './useMapCanvasViewModel';

const MapController = ({ bounds, minZoom, config }) => {
	const map = useMap();
	const prevConfigRef = useRef();

	useEffect(() => {
		if (!bounds) return;

		const isNewMap = prevConfigRef.current !== config.path;
		prevConfigRef.current = config.path;

		map.setMaxBounds(L.latLngBounds(bounds).pad(0.1));
		if (minZoom !== undefined) map.setMinZoom(minZoom);

		// Smooth transition for navigation, instant for new map
		map.fitBounds(bounds, {
			animate: !isNewMap,
			duration: isNewMap ? 0 : 0.5,
		});
	}, [map, bounds, minZoom, config.path]);

	return null;
};

export const MapCanvas = ({ data, onNavigate }) => {
	if (!data) return null;

	const { config, bounds, areas } = data;
	const vm = useMapCanvasViewModel(data); // Use Hook

	const tileUrl = `https://raw.githubusercontent.com/aethere92/dnd-campaign-map/main/${config.path}/{z}/{x}_{y}.png`;
	const minZoom = 0;
	const bgValue = config.backgroundColor || '#1a1412';
	const isImage = bgValue.includes('url') || bgValue.includes('gradient');

	return (
		<div
			style={{
				height: '100%',
				width: '100%',
				backgroundColor: isImage ? '#1a1412' : bgValue,
				backgroundImage: isImage ? bgValue : 'none',
				backgroundSize: 'cover',
				backgroundPosition: 'center',
				backgroundRepeat: 'no-repeat',
			}}>
			<MapContainer
				center={[0, 0]}
				zoom={minZoom}
				crs={L.CRS.Simple}
				minZoom={minZoom}
				maxZoom={config.sizes.maxZoom}
				scrollWheelZoom={true}
				attributionControl={false}
				zoomControl={false}
				style={{ height: '100%', width: '100%', background: 'transparent' }}>
				{/* ... MapController ... */}

				<TileLayer key={tileUrl} url={tileUrl} noWrap={true} bounds={bounds} maxNativeZoom={config.sizes.maxZoom} />

				<MapOverlays overlays={vm.visibleOverlays} />
				{vm.showAreas && <MapAreas areas={areas} />}
				<MapRecaps sessions={vm.visibleSessions} />
				<MapMarkers markers={vm.visibleMarkers} onNavigate={onNavigate} />

				<MapLayerControl groups={vm.controlGroups} visibility={vm.visibility} toggleLayer={vm.toggleLayer} />
			</MapContainer>
		</div>
	);
};

--- END OF features\world-map\components\MapCanvas.jsx ---

--- FILE: features\world-map\components\MapLayerControl.jsx ---
import { useState, useEffect, useRef } from 'react';
import { Layers, ChevronDown, ChevronRight, Eye, EyeOff, Check } from 'lucide-react';
import { clsx } from 'clsx';
import L from 'leaflet';

// Reusable styled Group Header matching Sidebar aesthetics
const Group = ({ label, icon: Icon, children, defaultOpen = true }) => {
	const [isOpen, setIsOpen] = useState(defaultOpen);
	if (!children || children.length === 0) return null;

	return (
		<div className='mb-2'>
			<button
				onClick={(e) => {
					e.stopPropagation();
					setIsOpen(!isOpen);
				}}
				className='flex items-center w-full text-left text-[10px] font-bold uppercase tracking-widest text-gray-500 hover:text-amber-700 transition-colors mb-1 select-none font-sans'>
				<span className='mr-1 opacity-70'>{isOpen ? <ChevronDown size={10} /> : <ChevronRight size={10} />}</span>
				<span className='flex items-center gap-1.5'>
					{Icon && <Icon size={12} />}
					{label}
				</span>
			</button>
			{isOpen && <div className='pl-2 space-y-0.5 border-l border-black/5 ml-1'>{children}</div>}
		</div>
	);
};

// Toggle Item with explicit Checkmark UI
const ToggleItem = ({ label, checked, onChange }) => (
	<div
		className='flex items-center gap-2 cursor-pointer group px-2 py-1 hover:bg-black/5 rounded-md transition-colors select-none'
		onClick={(e) => {
			e.stopPropagation();
			onChange();
		}}>
		{/* Custom Checkbox UI - Reduced size */}
		<div
			className={clsx(
				'w-3.5 h-3.5 rounded-[3px] border flex items-center justify-center transition-all shadow-sm shrink-0',
				checked ? 'bg-amber-600 border-amber-700 text-white' : 'bg-white border-gray-300 group-hover:border-amber-400'
			)}>
			{checked && <Check size={10} strokeWidth={3.5} />}
		</div>

		<span
			className={clsx(
				'text-[11px] font-medium leading-tight pt-0.5 font-sans',
				checked ? 'text-foreground' : 'text-gray-500'
			)}>
			{label}
		</span>
	</div>
);

export const MapLayerControl = ({ groups, visibility, toggleLayer }) => {
	const [expanded, setExpanded] = useState(true);
	const containerRef = useRef(null);

	// Prevent Leaflet map interactions when clicking inside this control
	useEffect(() => {
		if (containerRef.current) {
			L.DomEvent.disableClickPropagation(containerRef.current);
			L.DomEvent.disableScrollPropagation(containerRef.current);
		}
	}, []);

	return (
		<div className='leaflet-top leaflet-right font-sans' style={{ pointerEvents: 'none', zIndex: 1000 }}>
			<div
				ref={containerRef}
				className={clsx(
					'leaflet-control m-3 transition-all duration-200 ease-in-out',
					// Theme colors
					'bg-[#fdfbf7] border border-[#c9c2b8] rounded-lg shadow-xl overflow-hidden'
				)}
				style={{ pointerEvents: 'auto' }}>
				{/* Header */}
				<div
					className='flex items-center justify-between p-2.5 bg-[#f2efe9] border-b border-[#c9c2b8] cursor-pointer min-w-[180px]'
					onClick={() => setExpanded(!expanded)}>
					<div className='flex items-center gap-2 text-xs font-serif font-bold text-amber-900'>
						<Layers size={14} />
						<span>Atlas Layers</span>
					</div>
					<button className='p-0.5 hover:bg-black/5 rounded text-amber-900/70'>
						{expanded ? <Eye size={12} /> : <EyeOff size={12} />}
					</button>
				</div>

				{/* Content */}
				{expanded && (
					<div className='p-2 max-h-[60vh] overflow-y-auto w-56 custom-scrollbar bg-background/50'>
						{groups.overlays?.length > 0 && (
							<Group label='Overlays' icon={groups.icons.overlays} defaultOpen={false}>
								{groups.overlays.map((l) => (
									<ToggleItem
										key={l.id}
										label={l.label}
										checked={!!visibility[l.id]}
										onChange={() => toggleLayer(l.id)}
									/>
								))}
							</Group>
						)}

						{groups.sessions?.length > 0 && (
							<Group label='Journal & Paths' icon={groups.icons.sessions} defaultOpen={false}>
								{groups.sessions.map((l) => (
									<ToggleItem
										key={l.id}
										label={l.label}
										checked={!!visibility[l.id]}
										onChange={() => toggleLayer(l.id)}
									/>
								))}
							</Group>
						)}

						{groups.markers?.length > 0 && (
							<Group label='Map Markers' icon={groups.icons.markers} defaultOpen={true}>
								{groups.markers.map((cat) => (
									<ToggleItem
										key={cat.id}
										label={cat.label}
										checked={!!visibility[cat.id]}
										onChange={() => toggleLayer(cat.id)}
									/>
								))}
							</Group>
						)}

						<div className='mt-2 pt-2 border-t border-black/5'>
							<ToggleItem
								label='Show Areas & Regions'
								checked={!!visibility['areas']}
								onChange={() => toggleLayer('areas')}
							/>
						</div>
					</div>
				)}
			</div>
		</div>
	);
};

--- END OF features\world-map\components\MapLayerControl.jsx ---

--- FILE: features\world-map\components\useMapCanvasViewModel.js ---
import { useState, useEffect, useMemo } from 'react';
import { BookOpen, MapPin, Image as ImageIcon, Map as MapIcon } from 'lucide-react';

export function useMapCanvasViewModel(data) {
	// 1. Initialize Visibility
	const [visibility, setVisibility] = useState(() => {
		const init = { areas: false };
		if (!data) return init;

		// Initialize marker categories to TRUE
		const uniqueCats = [...new Set(data.markers.map((m) => m.category))].filter(Boolean);
		uniqueCats.forEach((cat) => {
			init[`marker-${cat}`] = true;
		});

		// Sessions/Overlays: OFF by default
		data.sessions.forEach((s) => (init[`session-${s.name}`] = false));
		data.overlays.forEach((o) => (init[`overlay-${o.name}`] = false));

		return init;
	});

	// Sync with data updates
	useEffect(() => {
		if (!data) return;
		const uniqueCats = [...new Set(data.markers.map((m) => m.category))].filter(Boolean);
		setVisibility((prev) => {
			const next = { ...prev };
			let changed = false;
			uniqueCats.forEach((cat) => {
				const key = `marker-${cat}`;
				if (next[key] === undefined) {
					next[key] = true;
					changed = true;
				}
			});
			return changed ? next : prev;
		});
	}, [data?.markers]);

	const toggleLayer = (id) => {
		setVisibility((prev) => ({ ...prev, [id]: !prev[id] }));
	};

	// 2. Control Groups Configuration
	const controlGroups = useMemo(() => {
		if (!data) return {};
		const uniqueCats = [...new Set(data.markers.map((m) => m.category))].filter(Boolean).sort();

		return {
			overlays: data.overlays.map((o) => ({ id: `overlay-${o.name}`, label: o.name })),
			sessions: data.sessions.map((s) => ({ id: `session-${s.name}`, label: s.name })),
			markers: uniqueCats.map((c) => ({ id: `marker-${c}`, label: c })),
			icons: {
				overlays: ImageIcon,
				sessions: BookOpen,
				markers: MapPin,
				areas: MapIcon,
			},
		};
	}, [data]);

	// 3. Filter Layers
	const visibleMarkers = useMemo(
		() => data?.markers.filter((m) => visibility[`marker-${m.category}`]) || [],
		[data, visibility]
	);
	const visibleSessions = useMemo(
		() => data?.sessions.filter((s) => visibility[`session-${s.name}`]) || [],
		[data, visibility]
	);
	const visibleOverlays = useMemo(
		() => data?.overlays.filter((o) => visibility[`overlay-${o.name}`]) || [],
		[data, visibility]
	);

	return {
		visibility,
		toggleLayer,
		controlGroups,
		visibleMarkers,
		visibleSessions,
		visibleOverlays,
		showAreas: visibility['areas'],
	};
}

--- END OF features\world-map\components\useMapCanvasViewModel.js ---

--- FILE: features\world-map\components\layers\MapAreas.jsx ---
import { Polygon, Tooltip } from 'react-leaflet';

export const MapAreas = ({ areas }) => {
	if (!areas || areas.length === 0) return null;

	return (
		<>
			{areas.map((area, idx) => (
				<Polygon
					key={`${area.name}-${idx}`}
					positions={area.positions}
					pathOptions={{
						color: area.lineColor || 'transparent',
						fillColor: area.interiorColor || '#ff0000',
						fillOpacity: 0.3,
						weight: 1,
					}}>
					<Tooltip
						permanent
						direction='center'
						className='bg-transparent border-0 shadow-none font-serif text-lg font-bold text-white drop-shadow-md text-center'>
						<div style={{ transform: `rotate(${area.textRotation || '0deg'})` }}>{area.name}</div>
					</Tooltip>
				</Polygon>
			))}
		</>
	);
};

--- END OF features\world-map\components\layers\MapAreas.jsx ---

--- FILE: features\world-map\components\layers\MapMarkers.jsx ---
import { Marker, Popup } from 'react-leaflet';
import { ArrowRight, MapPin, Skull, Castle, User, Tent, Sparkles } from 'lucide-react';
import { resolveMarkerIcon } from '../../utils/markerUtils';

/**
 * Resolves Lucide Icons for the Popup header based on Category
 */
const getCategoryIcon = (category) => {
	const cat = category?.toLowerCase() || '';
	if (cat.includes('combat') || cat.includes('danger') || cat.includes('encounter')) return Skull;
	if (cat.includes('citie') || cat.includes('town')) return Castle;
	if (cat.includes('npc') || cat.includes('people')) return User;
	if (cat.includes('camp')) return Tent;
	if (cat.includes('magic') || cat.includes('shrine')) return Sparkles;
	return MapPin;
};

export const MapMarkers = ({ markers, onNavigate }) => {
	if (!markers || markers.length === 0) return null;

	return (
		<>
			{markers.map((marker, idx) => {
				const CategoryIcon = getCategoryIcon(marker.category);
				const leafletIcon = resolveMarkerIcon(marker);

				return (
					<Marker key={`${marker.label}-${idx}`} position={marker.position} icon={leafletIcon}>
						<Popup closeButton={true}>
							<div className='flex flex-col w-[260px] font-sans bg-background'>
								{/* Header */}
								<div className='px-4 pt-4 pb-2 pr-7 flex items-start justify-between gap-3'>
									<div>
										<span className='text-[10px] font-bold uppercase tracking-wider text-amber-600/90 block mb-1'>
											{marker.category}
										</span>
										<h3 className='font-serif font-bold text-xl leading-none text-foreground'>{marker.label}</h3>
									</div>
									<div className='shrink-0 p-1.5 rounded-lg shadow-sm border border-amber-200 bg-amber-50 text-amber-700'>
										<CategoryIcon size={16} strokeWidth={2} />
									</div>
								</div>

								<div className='h-px w-full bg-border/50 my-1' />

								{/* Description */}
								<div className='px-4 py-2'>
									{marker.description ? (
										<p className='text-xs text-gray-600 leading-relaxed line-clamp-6'>{marker.description}</p>
									) : (
										<p className='text-xs text-gray-400 italic'>No details available.</p>
									)}
								</div>

								{/* Navigation Link (Map-to-Map) */}
								{marker.mapLink && (
									<div className='mt-2 bg-muted/50 p-2 border-t border-border flex justify-end rounded-b-lg'>
										<button
											onClick={() => onNavigate(marker.mapLink)}
											className='text-[10px] font-bold text-amber-700 hover:text-amber-800 flex items-center gap-1 transition-colors uppercase tracking-wide cursor-pointer'>
											Enter Location <ArrowRight size={10} />
										</button>
									</div>
								)}
							</div>
						</Popup>
					</Marker>
				);
			})}
		</>
	);
};

--- END OF features\world-map\components\layers\MapMarkers.jsx ---

--- FILE: features\world-map\components\layers\MapOverlays.jsx ---
import { ImageOverlay } from 'react-leaflet';

export const MapOverlays = ({ overlays }) => {
	if (!overlays || overlays.length === 0) return null;

	return (
		<>
			{overlays.map((overlay, idx) => (
				<ImageOverlay
					key={`${overlay.name}-${idx}`}
					url={`${import.meta.env.BASE_URL}${overlay.image}`}
					bounds={overlay.bounds}
					opacity={1}
				/>
			))}
		</>
	);
};

--- END OF features\world-map\components\layers\MapOverlays.jsx ---

--- FILE: features\world-map\components\layers\MapRecaps.jsx ---
import { Polyline, Marker, Popup } from 'react-leaflet';
import { Calendar } from 'lucide-react';
import { createDotIcon } from '../../utils/markerUtils'; // Import

export const MapRecaps = ({ sessions }) => {
	if (!sessions || sessions.length === 0) return null;

	return (
		<>
			{sessions.map((session, idx) => (
				<div key={session.name}>
					<Polyline
						positions={session.points.map((p) => p.coordinates)}
						pathOptions={{ color: session.lineColor || '#d97706', weight: 3, dashArray: '8, 8', opacity: 0.7 }}
					/>

					{session.points
						.filter((p) => p.text)
						.map((point, pIdx) => (
							<Marker
								key={`${session.name}-p-${pIdx}`}
								position={point.coordinates}
								icon={createDotIcon(session.lineColor || '#d97706')}>
								<Popup>{/* ... Popup content ... */}</Popup>
							</Marker>
						))}
				</div>
			))}
		</>
	);
};

--- END OF features\world-map\components\layers\MapRecaps.jsx ---

--- FILE: features\world-map\utils\mapNavigation.js ---
import { CAMPAIGN_01, CAMPAIGN_01_ALIASES } from '../data/campaign_01';

/**
 * Resolves the configuration object for a specific map key.
 * Handles aliases (e.g. 'korinis_island' -> 'world_maps.submaps...')
 */
export const getMapConfig = (mapKey, campaignData) => {
	// 1. If we have dynamic campaign data from Supabase/Context, use it.
	// Otherwise fallback to the static file.
	const rootData = campaignData || CAMPAIGN_01;

	// 2. Resolve Alias
	const fullPath = CAMPAIGN_01_ALIASES[mapKey] || mapKey || 'world_map';
	const pathParts = fullPath.split('.');

	// 3. Traverse
	// Note: We skip 'submaps' keyword if it appears in the path to make traversal robust
	// but based on your alias structure, we just follow the dots exactly.
	try {
		const config = pathParts.reduce((current, key) => {
			return current && current[key] ? current[key] : null;
		}, rootData);

		return config;
	} catch (e) {
		console.error(`Failed to load map config for: ${mapKey}`, e);
		return null;
	}
};

/**
 * Helper to calculate map bounds based on image size
 */
export const calculateBounds = (imageWidth, imageHeight) => {
	// In CRS.Simple, [0,0] is usually bottom-left.
	// We map [0,0] to top-left for easier mental mapping if needed,
	// but standard Leaflet CRS.Simple treats Y as going up.
	// Typically: [[0,0], [height, width]]
	return [
		[-imageHeight, 0],
		[0, imageWidth],
	];
};

--- END OF features\world-map\utils\mapNavigation.js ---

--- FILE: features\world-map\utils\markerUtils.js ---
import L from 'leaflet';

// Singleton for invisible/interactive-only markers
export const invisibleIcon = L.divIcon({
	className: 'bg-transparent border-none',
	html: '<div style="width: 100%; height: 100%;"></div>',
	iconSize: [20, 20],
	iconAnchor: [10, 10],
	popupAnchor: [0, -10],
});

// Text Label Marker Generator
export const createTextMarker = (label, fontSize) => {
	const sizeStyle = fontSize ? `${fontSize}px` : '1.5rem';
	return L.divIcon({
		className: 'map-text-marker',
		html: `
            <div style="transform: translate(-50%, -50%); width: max-content; text-align: center; display: flex; justify-content: center; align-items: center;">
                <span style="font-family: 'Inter', sans-serif; text-transform: uppercase; font-weight: 600; font-size: ${sizeStyle}; color: #2c1a0e; text-shadow: 0 0 4px #fdfbf7, 0 0 8px #fdfbf7, 0 0 15px #fdfbf7; pointer-events: auto; cursor: pointer; white-space: nowrap;">
                    ${label}
                </span>
            </div>`,
		iconSize: [0, 0],
		iconAnchor: [0, 0],
		popupAnchor: [0, -10],
	});
};

// Custom Image Icon Generator
export const createCustomIcon = (iconName) => {
	return L.divIcon({
		className: 'custom-marker-icon',
		html: `
            <div class="group relative flex flex-col items-center">
                <div class="w-8 h-8 transition-transform group-hover:-translate-y-1 duration-200">
                    <img src="${import.meta.env.BASE_URL}images/custom-icons/${iconName}.png" 
                         class="w-full h-full object-contain drop-shadow-md filter" />
                </div>
            </div>`,
		iconSize: [32, 32],
		iconAnchor: [16, 32],
		popupAnchor: [0, -28],
	});
};

// Logic Hub: Resolves the appropriate Leaflet icon
export const resolveMarkerIcon = (marker) => {
	const { icon, type, label, fontSize } = marker;

	// 1. Text Marker (Check both 'type' and 'icon' properties per your original code)
	if (type === 'text' || icon === 'text') {
		return createTextMarker(label, fontSize);
	}

	// 2. Invisible / Null Icon (Interactive only)
	if (!icon) {
		return invisibleIcon;
	}

	// 3. Custom Image Icon (Fallback to your specific images folder)
	return createCustomIcon(icon);
};

// For session paths/dots
export const createDotIcon = (color) =>
	L.divIcon({
		className: 'path-dot',
		html: `<div style="background-color: ${color};" class="w-3 h-3 rounded-full border-2 border-white shadow-sm"></div>`,
		iconSize: [12, 12],
		iconAnchor: [6, 6],
	});

--- END OF features\world-map\utils\markerUtils.js ---

--- FILE: lib\supabase.js ---
import { createClient } from '@supabase/supabase-js';

// 1. Load variables from .env
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

// 2. Safety Check (Helps debug if .env is missing)
if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
	console.error(
		' Supabase Critical Error: Missing environment variables.\n' +
			'Please check that your .env file exists and contains VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY.'
	);
}

// 3. Initialize and Export the Client
export const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

--- END OF lib\supabase.js ---

--- FILE: services\admin.js ---
import { supabase } from '../lib/supabase';
import { getStrategy } from '../features/admin-console/config/strategies';

// Helper to prepare attribute rows
const prepareAttributeRows = (entityId, data) => {
	// If we have a prepared list (from the new form logic), use it
	if (data.attributesList && Array.isArray(data.attributesList)) {
		return data.attributesList
			.filter((attr) => attr.name && String(attr.value).trim() !== '')
			.map((attr) => ({
				entity_id: entityId,
				name: attr.name,
				value: attr.value,
				is_private: false,
			}));
	}

	// Fallback for legacy object format (just in case)
	if (data.attributes) {
		return Object.entries(data.attributes)
			.filter(([_, value]) => value && String(value).trim() !== '')
			.map(([key, value]) => ({
				entity_id: entityId,
				name: key,
				value: value,
				is_private: false,
			}));
	}
	return [];
};

export const createEntity = async (type, data) => {
	const strategy = getStrategy(type);

	// 1. Prepare Core Payload
	const corePayload = {};

	// Only add parent campaign_id if it's NOT a campaign itself
	if (type !== 'campaign') {
		corePayload.campaign_id = data.campaign_id;
	}

	// Name/Desc Mapping
	if (strategy.colMapping) {
		if (data.name) corePayload[strategy.colMapping.name] = data.name;
		if (data.description) corePayload[strategy.colMapping.description] = data.description;
	}
	if (strategy.primaryTable === 'entities') corePayload.type = type;

	// FIX #4: Extract Special Columns from Attributes (e.g. Campaign ID, Map Data)
	// We look at the incoming attributesList or attributes object
	const rawAttributes =
		data.attributesList ||
		(data.attributes ? Object.entries(data.attributes).map(([k, v]) => ({ name: k, value: v })) : []);

	const attributesToInsert = [];

	rawAttributes.forEach((attr) => {
		// Does this attribute match a known column in the definitions?
		// Simple check: For campaigns, 'campaign_id' and 'map_data' are columns.
		const isSpecialColumn = strategy.defaultAttributes?.find((def) => def.key === attr.name && type === 'campaign');

		if (isSpecialColumn) {
			// It's a column! Add to core payload.
			corePayload[attr.name] = attr.value;
		} else {
			// It's a normal attribute. Keep for attributes table.
			attributesToInsert.push(attr);
		}
	});

	console.log('[Admin] Creating:', corePayload);

	// 2. Insert Core
	const { data: insertedRecord, error: insertError } = await supabase
		.from(strategy.primaryTable)
		.insert(corePayload)
		.select()
		.single();

	if (insertError) throw insertError;
	const newId = insertedRecord.id;

	// 3. Insert Remaining Attributes (if any)
	// Campaigns usually don't use the attributes table, so this might be empty, which is fine.
	if (attributesToInsert.length > 0 && strategy.primaryTable !== 'campaigns') {
		const rows = attributesToInsert.map((attr) => ({
			entity_id: newId,
			name: attr.name,
			value: attr.value,
			is_private: false,
		}));

		const { error: attrError } = await supabase.from('attributes').insert(rows);
		if (attrError) throw attrError;
	}

	return { id: newId, ...insertedRecord };
};

export const updateEntity = async (type, id, data) => {
	const strategy = getStrategy(type);

	// 1. Prepare Core Payload
	const corePayload = {};
	if (strategy.colMapping) {
		if (data.name) corePayload[strategy.colMapping.name] = data.name;
		if (data.description) corePayload[strategy.colMapping.description] = data.description;
	}

	// FIX: Extract Special Columns from Attributes
	const rawAttributes =
		data.attributesList ||
		(data.attributes ? Object.entries(data.attributes).map(([k, v]) => ({ name: k, value: v })) : []);

	const attributesToInsert = [];

	rawAttributes.forEach((attr) => {
		const isSpecialColumn = strategy.defaultAttributes?.find((def) => def.key === attr.name && type === 'campaign');

		if (isSpecialColumn) {
			corePayload[attr.name] = attr.value;
		} else {
			attributesToInsert.push(attr);
		}
	});

	// 2. Update Core
	const { error: updateError } = await supabase.from(strategy.primaryTable).update(corePayload).eq('id', id);

	if (updateError) throw updateError;

	// 3. Handle Attributes (Skip for campaigns usually)
	if (strategy.primaryTable !== 'campaigns') {
		// Delete old
		const { error: deleteError } = await supabase.from('attributes').delete().eq('entity_id', id);
		if (deleteError) throw deleteError;

		// Insert new
		if (attributesToInsert.length > 0) {
			const rows = attributesToInsert.map((attr) => ({
				entity_id: id,
				name: attr.name,
				value: attr.value,
				is_private: false,
			}));
			const { error: insertError } = await supabase.from('attributes').insert(rows);
			if (insertError) throw insertError;
		}
	}

	return { success: true };
};

export const fetchRawEntity = async (type, id) => {
	const strategy = getStrategy(type);

	// 1. Fetch Core Data
	const { data: coreData, error: coreError } = await supabase
		.from(strategy.primaryTable)
		.select('*')
		.eq('id', id)
		.single();

	if (coreError) throw coreError;

	// 2. Fetch Attributes (As List)
	const { data: attrData, error: attrError } = await supabase
		.from('attributes')
		.select('name, value')
		.eq('entity_id', id);

	if (attrError) throw attrError;

	// 3. Reverse Map Core Columns
	const formData = { ...coreData };
	if (strategy.colMapping) {
		Object.entries(strategy.colMapping).forEach(([formField, dbCol]) => {
			if (coreData[dbCol] !== undefined) {
				formData[formField] = coreData[dbCol];
			}
		});
	}

	// 4. FIX: Map Column-based attributes (Campaigns) into the Attribute List
	// If the strategy says 'campaign_id' is an attribute, but it exists on 'coreData',
	// we fake it as an attribute so the UI renders it.
	if (strategy.defaultAttributes) {
		strategy.defaultAttributes.forEach((defAttr) => {
			if (coreData[defAttr.key] !== undefined) {
				attrData.push({
					name: defAttr.key,
					value: coreData[defAttr.key],
				});
			}
		});
	}

	// RETURN RAW ATTRIBUTE LIST
	// We intentionally do NOT convert to an object here to preserve duplicates
	return { ...formData, attributesList: attrData };
};

/**
 * Fetch all relationships for a specific entity
 */
export const fetchRelationships = async (id) => {
	const { data, error } = await supabase
		.from('entity_relationships')
		.select(
			`
            id,
            relationship_type,
            description,
            is_bidirectional,
            is_hidden,
            target:entities!to_entity_id ( id, name, type )
        `
		)
		.eq('from_entity_id', id);

	if (error) throw error;
	return data;
};

/**
 * Add a new relationship
 * Note: Your DB trigger 'create_reverse_relationship' handles the reverse link automatically
 * if is_bidirectional is true.
 */
export const addRelationship = async (payload) => {
	// payload = { from_entity_id, to_entity_id, relationship_type, is_bidirectional }
	const { data, error } = await supabase.from('entity_relationships').insert(payload).select().single();

	if (error) throw error;
	return data;
};

/**
 * Delete a relationship
 */
export const deleteRelationship = async (relId) => {
	const { error } = await supabase.from('entity_relationships').delete().eq('id', relId);

	if (error) throw error;
	return true;
};

/**
 * Fetch child rows (e.g., session_events)
 */
export const fetchChildRows = async (table, foreignKeyCol, parentId, orderBy = 'id') => {
	const { data, error } = await supabase
		.from(table)
		.select('*')
		.eq(foreignKeyCol, parentId)
		.order(orderBy, { ascending: true });

	if (error) throw error;
	return data;
};

/**
 * Save a single event.
 * If no ID, it creates. If ID, it updates.
 */
export const upsertSessionEvent = async (eventData) => {
	// 1. Remove ID if it's a placeholder "new"
	const payload = { ...eventData };
	if (String(payload.id).startsWith('new')) {
		delete payload.id;
	}

	const { data, error } = await supabase.from('session_events').upsert(payload).select().single();

	if (error) throw error;
	return data;
};

/**
 * Delete a generic row
 */
export const deleteRow = async (table, id) => {
	const { error } = await supabase.from(table).delete().eq('id', id);
	if (error) throw error;
	return true;
};

/**
 * Save a single quest objective.
 */
export const upsertQuestObjective = async (objectiveData) => {
	// Remove temp ID
	const payload = { ...objectiveData };
	if (String(payload.id).startsWith('new')) {
		delete payload.id;
	}

	const { data, error } = await supabase.from('quest_objectives').upsert(payload).select().single();

	if (error) throw error;
	return data;
};

export const deleteEntity = async (type, id) => {
	const strategy = getStrategy(type);

	// 1. Delete Attributes
	const { error: attrError } = await supabase.from('attributes').delete().eq('entity_id', id);

	if (attrError) console.warn('Attribute delete warning:', attrError);

	// 2. Delete Primary Row (Cascades to 'entities' via DB trigger)
	const { error: mainError } = await supabase.from(strategy.primaryTable).delete().eq('id', id);

	if (mainError) throw mainError;
	return true;
};

export const updateRelationship = async (relId, updates) => {
	const { error } = await supabase.from('entity_relationships').update(updates).eq('id', relId);

	if (error) throw error;
	return true;
};

export const searchEntitiesByName = async (campaignId, query) => {
	const searchTerm = `%${query}%`;

	// 1. Search Entities (NPCs, Locations, Characters, Factions, Quests, Items)
	// We strictly search the 'name' column here.
	const { data: entities } = await supabase
		.from('entities')
		.select('id, name, type, description')
		.eq('campaign_id', campaignId)
		.ilike('name', searchTerm)
		.limit(15); // Higher limit

	// 2. Search Sessions (Sessions are often separate)
	const { data: sessions } = await supabase
		.from('sessions')
		.select('id, title, narrative')
		.eq('campaign_id', campaignId)
		.ilike('title', searchTerm)
		.limit(5);

	// Normalize Sessions to match Entity structure
	const normSessions = (sessions || []).map((s) => ({
		id: s.id,
		name: s.title,
		type: 'session',
		description: s.narrative,
	}));

	return [...(entities || []), ...normSessions];
};

export const getSessionList = async (campaignId) => {
	const { data, error } = await supabase
		.from('sessions')
		.select('id, title')
		.eq('campaign_id', campaignId)
		.order('title', { ascending: true }); // Assuming title starts with "01", "02", etc.

	if (error) throw error;
	return data;
};

/**
 * Fetch session events AND their relationships (mentions) efficiently.
 */
export const fetchSessionEventsWithRelationships = async (sessionId) => {
	// 1. Fetch Events
	const { data: events, error: eventError } = await supabase
		.from('session_events')
		.select('*')
		.eq('session_id', sessionId)
		.order('event_order', { ascending: true });

	if (eventError) throw eventError;
	if (!events || events.length === 0) return [];

	// 2. Fetch Relationships for ALL these events at once
	const eventIds = events.map((e) => e.id);
	const { data: rels, error: relError } = await supabase
		.from('entity_relationships')
		.select(
			`
            id,
            from_entity_id,
            target:entities!to_entity_id ( id, name, type )
        `
		)
		.in('from_entity_id', eventIds);

	if (relError) throw relError;

	// 3. Group Relationships by Event ID
	const relMap = {};
	rels.forEach((r) => {
		if (!relMap[r.from_entity_id]) relMap[r.from_entity_id] = [];
		relMap[r.from_entity_id].push(r);
	});

	// 4. Merge back into Event objects
	return events.map((e) => ({
		...e,
		relationships: relMap[e.id] || [],
	}));
};

--- END OF services\admin.js ---

--- FILE: services\campaigns.js ---
import { supabase } from '../lib/supabase';

export const getCampaigns = async () => {
	// We fetch campaigns and use a subquery to get names of entities with type 'character'
	// ARCHITECTURAL UPDATE: Added 'map_data' to check if Atlas should be enabled
	const { data, error } = await supabase
		.from('campaigns')
		.select(
			`
            id,
			campaign_id,
            name, 
            description,
			map_data,
            characters:entity_complete_view(name)
        `
		)
		.eq('entity_complete_view.type', 'character');

	if (error) throw error;

	// Clean up the nested character structure
	return data.map((campaign) => ({
		...campaign,
		characterNames: campaign.characters?.map((c) => c.name) || [],
	}));
};

--- END OF services\campaigns.js ---

--- FILE: services\entities.js ---
import { supabase } from '../lib/supabase';
import { getAttributeValue } from '../utils/entity/attributeParser';
import { getCampaigns } from './campaigns';

// --- HELPER: Extract Session Meta ---
const extractSessionMeta = (session, attributes = []) => {
	let attrs = attributes;
	if (Array.isArray(attrs)) {
		attrs = attrs.reduce((acc, curr) => {
			acc[curr.name] = curr.value;
			return acc;
		}, {});
	}
	attrs = attrs || {};

	const sessionNumber = getAttributeValue(attrs, ['session_number', 'Session', 'session']) || 999;
	const sessionDate = getAttributeValue(attrs, ['session_date', 'Date', 'date']) || '';

	return {
		...session,
		session_number: Number(sessionNumber),
		session_date: sessionDate,
		attributes: attrs,
	};
};

// --- API METHODS ---

export const getSessions = async (campaignId) => {
	const { data: sessions, error } = await supabase
		.from('sessions')
		.select('id, title, narrative')
		.eq('campaign_id', campaignId);

	if (error) throw error;
	if (!sessions.length) return [];

	const sessionIds = sessions.map((s) => s.id);
	const { data: attributes } = await supabase
		.from('attributes')
		.select('entity_id, name, value')
		.in('entity_id', sessionIds);

	const attrMap = new Map();
	(attributes || []).forEach((attr) => {
		if (!attrMap.has(attr.entity_id)) attrMap.set(attr.entity_id, []);
		attrMap.get(attr.entity_id).push(attr);
	});

	const processed = sessions.map((s) => {
		const sAttrs = attrMap.get(s.id) || [];
		const meta = extractSessionMeta(s, sAttrs);

		return {
			id: meta.id,
			name: meta.title,
			type: 'session',
			session_number: meta.session_number,
			session_date: meta.session_date,
			summary: getAttributeValue(meta.attributes, 'Summary') || meta.narrative,
			narrative: meta.narrative,
			attributes: meta.attributes,
		};
	});

	return processed.sort((a, b) => a.session_number - b.session_number);
};

// Generic fetcher
const getCompleteEntities = async (campaignId, type) => {
	const { data, error } = await supabase
		.from('entity_complete_view')
		.select('id, name, type, description, attributes, relationships')
		.eq('campaign_id', campaignId)
		.eq('type', type)
		.order('name');

	if (error) throw error;
	return data;
};

const entityStrategies = {
	session: getSessions,
	quest: getCompleteEntities,
	default: getCompleteEntities,
	campaign: async () => getCampaigns(),
};

export const getEntities = async (campaignId, type) => {
	const strategy = entityStrategies[type] || entityStrategies.default;
	return strategy(campaignId, type);
};

export const getGraphData = async (campaignId) => {
	const { data, error } = await supabase
		.from('entity_complete_view')
		.select('id, name, type, relationships, attributes')
		.eq('campaign_id', campaignId);

	if (error) {
		console.error('Graph Fetch Error:', error);
		return [];
	}
	return data || [];
};

export const getEntityIndex = async (campaignId) => {
	const { data, error } = await supabase
		.from('entity_complete_view')
		.select('id, name, type, attributes')
		.eq('campaign_id', campaignId);

	if (error) return [];
	return data.sort((a, b) => b.name.length - a.name.length);
};

export const getWikiEntry = async (id, type) => {
	if (type === 'session') {
		const { data, error } = await supabase
			.from('sessions')
			.select(`*, events:session_events (*)`)
			.eq('id', id)
			.single();
		if (error) throw error;

		const { data: attributes } = await supabase.from('attributes').select('name, value').eq('entity_id', id);

		const eventIds = (data.events || []).map((e) => e.id);
		let eventRelMap = new Map();

		if (eventIds.length > 0) {
			const { data: rels } = await supabase
				.from('entity_relationships')
				.select(`from_entity_id, target:entities!to_entity_id ( id, name, type )`)
				.in('from_entity_id', eventIds);

			(rels || []).forEach((rel) => {
				if (!eventRelMap.has(rel.from_entity_id)) eventRelMap.set(rel.from_entity_id, []);
				eventRelMap.get(rel.from_entity_id).push({
					entity_id: rel.target.id,
					entity_name: rel.target.name,
					entity_type: rel.target.type,
					type: 'mention',
				});
			});
		}

		const { data: directRels } = await supabase
			.from('entity_relationships')
			.select(`target:entities!to_entity_id ( id, name, type ), relationship_type`)
			.eq('from_entity_id', id);

		const sessionRelationships = (directRels || []).map((rel) => ({
			entity_id: rel.target.id,
			entity_name: rel.target.name,
			entity_type: rel.target.type,
			type: rel.relationship_type,
		}));

		return {
			data,
			type: 'session',
			additional: { attributes, eventRelMap, sessionRelationships },
		};
	}

	// --- STANDARD ENTITY FETCH ---
	const { data, error: entityError } = await supabase.from('entity_complete_view').select('*').eq('id', id).single();
	if (entityError) throw entityError;

	const additional = {};

	// FETCH QUEST OBJECTIVES WITH SESSION DATA
	if (type === 'quest') {
		const { data: objectives, error: objError } = await supabase
			.from('quest_objectives')
			.select('*, session:sessions(id, title)') // Basic join for title
			.eq('quest_id', id)
			.order('order_index', { ascending: true });

		if (objError) console.error('Error fetching objectives:', objError);

		if (objectives && objectives.length > 0) {
			// 2. Fetch Session Numbers (stored as attributes)
			const sessionIds = objectives.map((o) => o.completed_session_id).filter(Boolean);

			if (sessionIds.length > 0) {
				const { data: attrs } = await supabase
					.from('attributes')
					.select('entity_id, value')
					.in('entity_id', sessionIds)
					.or('name.eq.session_number,name.eq.Session');

				const sessionNumMap = new Map();
				(attrs || []).forEach((a) => sessionNumMap.set(a.entity_id, a.value));

				// 3. Attach number to the session object inside the objective
				objectives.forEach((obj) => {
					if (obj.session) {
						obj.session.session_number = sessionNumMap.get(obj.session.id);
					}
				});
			}
		}

		additional.objectives = objectives || [];
	}

	// RESOLVE SESSION NUMBERS FOR EVENTS
	let events = data.events;
	if (events && typeof events === 'object' && !Array.isArray(events)) {
		events = Object.values(events).flat();
	}

	if (events && Array.isArray(events) && events.length > 0) {
		const sessionIds = [...new Set(events.map((e) => e.session_id).filter(Boolean))];
		if (sessionIds.length > 0) {
			const { data: sessions } = await supabase.from('sessions').select('id').in('id', sessionIds);

			const { data: attrs } = await supabase
				.from('attributes')
				.select('entity_id, name, value')
				.in('entity_id', sessionIds)
				.or('name.eq.session_number,name.eq.Session');

			const sessionMap = new Map();
			(sessions || []).forEach((s) => {
				const sAttr = (attrs || []).find((a) => a.entity_id === s.id);
				const num = sAttr ? parseInt(sAttr.value) : null;
				sessionMap.set(s.id, num);
			});

			additional.sessionMap = sessionMap;
		}
	}

	return { data, type, additional };
};

export const getTooltipData = async (id, type) => {
	if (type === 'session') {
		const { data } = await supabase.from('sessions').select('title, narrative').eq('id', id).single();
		const { data: attributes } = await supabase.from('attributes').select('name, value').eq('entity_id', id);
		return {
			name: data.title,
			type: 'session',
			description: data.narrative,
			attributes,
		};
	}

	const { data, error } = await supabase
		.from('entity_complete_view')
		.select('name, type, description, attributes')
		.eq('id', id)
		.single();
	if (error) throw error;
	return data;
};

--- END OF services\entities.js ---

--- FILE: services\search.js ---
import { supabase } from '../lib/supabase';

export const globalSearch = async (campaignId, query) => {
	if (!query || query.trim().length === 0) return { sessions: [], entities: [], sessionAttributes: [] };

	const searchTerm = `%${query.trim()}%`;

	// 1. Search Entities
	const { data: entities, error: entitiesError } = await supabase
		.from('entities')
		.select('id, name, type, description')
		.eq('campaign_id', campaignId)
		.or(`name.ilike.${searchTerm},description.ilike.${searchTerm}`)
		.limit(8);

	if (entitiesError) console.error('Entity search error:', entitiesError);

	// 2. Search Sessions
	const { data: sessions, error: sessionsError } = await supabase
		.from('sessions')
		.select('id, title, narrative')
		.eq('campaign_id', campaignId)
		.or(`title.ilike.${searchTerm},narrative.ilike.${searchTerm}`)
		.limit(5);

	if (sessionsError) console.error('Session search error:', sessionsError);

	// 3. Fetch Attributes for Sessions (if any found)
	let sessionAttributes = [];
	if (sessions && sessions.length > 0) {
		const sessionIds = sessions.map((s) => s.id);
		const { data } = await supabase.from('attributes').select('entity_id, name, value').in('entity_id', sessionIds);
		sessionAttributes = data || [];
	}

	return {
		sessions: sessions || [],
		entities: entities || [],
		sessionAttributes,
	};
};

--- END OF services\search.js ---

--- FILE: services\timeline.js ---
import { supabase } from '../lib/supabase';
import { getAttributeValue } from '../utils/entity/attributeParser';

export const getTimeline = async (campaignId) => {
	// 1. Fetch Sessions (No summary)
	const { data: sessions, error: sessionError } = await supabase
		.from('sessions')
		.select(
			`
            id, 
            title, 
            narrative,
            events:session_events (
                id, 
                title, 
                description, 
                event_type, 
                event_order
            )
        `
		)
		.eq('campaign_id', campaignId);

	if (sessionError) throw sessionError;
	if (!sessions || sessions.length === 0) return [];

	// 2. Fetch Attributes
	const sessionIds = sessions.map((s) => s.id);
	const { data: attributes } = await supabase
		.from('attributes')
		.select('entity_id, name, value')
		.in('entity_id', sessionIds);

	const attrMap = new Map();
	(attributes || []).forEach((attr) => {
		if (!attrMap.has(attr.entity_id)) attrMap.set(attr.entity_id, []);
		attrMap.get(attr.entity_id).push(attr);
	});

	// 3. Process
	const processedSessions = sessions
		.map((s) => {
			const rawAttrs = attrMap.get(s.id) || [];
			const attrs = rawAttrs.reduce((acc, c) => {
				acc[c.name] = c.value;
				return acc;
			}, {});

			const num = getAttributeValue(attrs, ['session_number', 'Session']) || 999;
			const date = getAttributeValue(attrs, ['session_date', 'Date']) || 'Unknown Date';

			return {
				...s,
				session_number: Number(num),
				session_date: date,
				attributes: attrs,
				events: s.events || [],
			};
		})
		.sort((a, b) => a.session_number - b.session_number);

	// ... Steps 4, 5, 6 (Tags logic) remain exactly the same ...
	// (Included for completeness)
	const allEvents = processedSessions.flatMap((s) => s.events);
	const eventIds = allEvents.map((e) => e.id);

	if (eventIds.length === 0) return processedSessions;

	const { data: relationships, error: relError } = await supabase
		.from('entity_relationships')
		.select(`from_entity_id, target:entities!to_entity_id ( name, type )`)
		.in('from_entity_id', eventIds);

	if (relError) return processedSessions;

	const relMap = new Map();
	relationships.forEach((rel) => {
		if (!relMap.has(rel.from_entity_id)) relMap.set(rel.from_entity_id, []);
		relMap.get(rel.from_entity_id).push(rel);
	});

	processedSessions.forEach((session) => {
		if (session.events.length > 0) {
			session.events.sort((a, b) => (a.event_order || 0) - (b.event_order || 0));
			session.events.forEach((event) => {
				event.relationships = relMap.get(event.id) || [];
			});
		}
	});

	return processedSessions;
};

--- END OF services\timeline.js ---

--- FILE: utils\index.js ---
/**
 * Centralized Utility Exports
 * Single import point for all utilities
 */

// Entity utilities
export * from './entity/entityHelpers';
export * from './entity/attributeParser';

// Image utilities
export * from './image/imageResolver';

// Status utilities
export * from './status/statusHelpers';

// Text utilities
export * from './text/textProcessing';
export * from './text/markdownHelpers';

// Theme utilities
export * from './theme/colorHelpers';
export * from './theme/cssVariables';

--- END OF utils\index.js ---

--- FILE: utils\entity\attributeParser.js ---
/**
 * Attribute Parsing Utilities
 * Safe parsing and extraction of entity attributes
 */

/**
 * Parse attributes safely from JSON string or object
 * @param {string|Object} attrs - Raw attributes
 * @returns {Object} Parsed attributes object
 */
export const parseAttributes = (attrs) => {
	if (!attrs) return {};
	if (typeof attrs === 'object') return attrs;

	try {
		return JSON.parse(attrs);
	} catch {
		console.warn('Failed to parse attributes:', attrs);
		return {};
	}
};

/**
 * Extract a single attribute value (case-insensitive key lookup)
 * Handles nested structures: { value: "..." }, [{ value: "..." }], or plain strings
 *
 * @param {Object} attributes - Parsed attributes object
 * @param {string|string[]} keys - Key(s) to search for (tries each in order)
 * @returns {string|null} Extracted value or null
 */
export const getAttributeValue = (attributes, keys) => {
	if (!attributes) return null;

	// Normalize keys to array
	const keyList = Array.isArray(keys) ? keys : [keys];

	for (const key of keyList) {
		// Try exact match
		let val = attributes[key];

		// Try lowercase match
		if (!val) {
			val = attributes[key.toLowerCase()];
		}

		// Try capitalized match
		if (!val) {
			val = attributes[key.charAt(0).toUpperCase() + key.slice(1)];
		}

		if (!val) continue;

		// Unwrap nested structures
		if (typeof val === 'string') return val;
		if (Array.isArray(val) && val[0]?.value) return val[0].value;
		if (Array.isArray(val) && val[0]) return String(val[0]);
		if (typeof val === 'object' && val.value) return val.value;

		// Fallback: stringify
		return String(val);
	}

	return null;
};

/**
 * Parse attribute value intelligently based on context
 * Handles arrays, objects, and type conversion
 *
 * @param {*} val - Raw attribute value
 * @param {string} key - Attribute key (for context)
 * @returns {*} Parsed value
 */
export const parseAttributeValue = (val, key) => {
	if (val === null || val === undefined) return null;

	// 1. Already an array - clean it
	if (Array.isArray(val)) {
		return val.map((item) => (typeof item === 'object' && item.value ? item.value : item));
	}

	// 2. Check if this should be a list based on key name
	const listKeys = ['feature', 'features', 'traits', 'inventory', 'loot', 'spells'];
	if (typeof val === 'string' && listKeys.includes(key?.toLowerCase())) {
		return val
			.split(',')
			.map((s) => s.trim())
			.filter(Boolean);
	}

	// 3. Unwrap objects
	if (typeof val === 'object' && val.value) {
		return val.value;
	}

	// 4. Return as string
	return String(val);
};

/**
 * Parse ability scores from attribute string
 * Format: "STR 16 (+3), DEX 14 (+2), ..."
 *
 * @param {string} val - Ability scores string
 * @returns {Array<{name: string, score: string, mod: string}>}
 */
export const parseAbilityScores = (val) => {
	if (!val || typeof val !== 'string') return [];

	return val.split(',').map((s) => {
		const parts = s.trim().split(' ');
		const name = parts[0];
		const score = parts.find((p) => /^\d+$/.test(p)) || '';
		const mod = parts.find((p) => p.includes('('))?.replace(/[()]/g, '') || '';

		return { name, score, mod };
	});
};

/**
 * Parse comma-separated tags/list
 *
 * @param {string|Array} val - Raw value
 * @returns {string[]} Array of cleaned tags
 */
export const parseTagList = (val) => {
	if (!val) return [];
	if (Array.isArray(val)) return val.map(String);

	return String(val)
		.split(',')
		.map((s) => s.trim())
		.filter(Boolean);
};

/**
 * Check if an attribute key should be ignored in display
 * @param {string} key - Attribute key
 * @returns {boolean}
 */
export const isIgnoredAttribute = (key) => {
	const ignoredKeys = [
		'image',
		'portrait',
		'icon',
		'token',
		'session',
		'date',
		'summary',
		'background_image',
		'background',
		'is_active',
	];

	return ignoredKeys.includes(key.toLowerCase());
};

/**
 * Check if an attribute should be treated as narrative text
 * @param {string} key - Attribute key
 * @returns {boolean}
 */
export const isNarrativeAttribute = (key) => {
	const narrativeKeys = [
		'background',
		'personality',
		'history',
		'bio',
		'biography',
		'goals',
		'ideals',
		'bonds',
		'flaws',
		'notes',
		'gm notes',
		'description',
		'appearance',
		'tactics',
		'narrative',
	];

	return narrativeKeys.includes(key.toLowerCase());
};

/**
 * Check if an attribute should be displayed as a list
 * @param {string} key - Attribute key
 * @returns {boolean}
 */
export const isListAttribute = (key) => {
	const listKeys = ['feature', 'features', 'traits', 'inventory', 'loot', 'spells'];
	return listKeys.includes(key.toLowerCase());
};

/**
 * Determine display type for an attribute
 * @param {string} key - Attribute key
 * @param {*} value - Attribute value
 * @returns {'text'|'list'|'stat-grid'|'tags'|'narrative'}
 */
export const getAttributeDisplayType = (key, value) => {
	const normalizedKey = key.toLowerCase();

	// Special widgets
	if (['abilities', 'stats'].includes(normalizedKey)) {
		return 'stat-grid';
	}

	if (['ability score', 'saving throw', 'saves', 'skills', 'languages', 'proficiencies'].includes(normalizedKey)) {
		return 'tags';
	}

	// Force list display
	if (isListAttribute(key) && Array.isArray(value)) {
		return 'list';
	}

	// Narrative text
	if (isNarrativeAttribute(key)) {
		return 'narrative';
	}

	// Long text becomes narrative
	if (typeof value === 'string' && value.length > 100) {
		return 'narrative';
	}

	// Default
	return 'text';
};

--- END OF utils\entity\attributeParser.js ---

--- FILE: utils\entity\entityHelpers.js ---
/**
 * Entity Type Utilities
 * Pure functions for entity type checking and normalization
 */

/**
 * Normalize entity type string
 * @param {string} type - Raw type string
 * @returns {string} Normalized type
 */
export const normalizeEntityType = (type) => {
	if (!type) return 'default';
	const normalized = type.toLowerCase().trim();
	// Handle plurals
	return normalized === 'sessions' ? 'session' : normalized;
};

/**
 * Check if entity type is a specific value
 * @param {Object} entity - Entity object
 * @param {string} type - Type to check
 * @returns {boolean}
 */
export const isEntityType = (entity, type) => {
	return normalizeEntityType(entity?.type) === normalizeEntityType(type);
};

/**
 * Check if entity is a session
 */
export const isSession = (entity) => isEntityType(entity, 'session');

/**
 * Check if entity is a quest
 */
export const isQuest = (entity) => isEntityType(entity, 'quest');

/**
 * Check if entity is an NPC
 */
export const isNPC = (entity) => isEntityType(entity, 'npc');

/**
 * Check if entity is a location
 */
export const isLocation = (entity) => isEntityType(entity, 'location');

/**
 * Check if entity type should show status icons
 * @param {string} type - Entity type
 * @returns {boolean}
 */
export const shouldShowStatus = (type) => {
	const normalized = normalizeEntityType(type);
	return ['npc', 'faction', 'quest'].includes(normalized);
};

/**
 * Get entity display name
 * Handles different name fields across entity types
 * @param {Object} entity - Entity object
 * @returns {string}
 */
export const getEntityName = (entity) => {
	if (!entity) return 'Unknown';

	// Sessions use 'title'
	if (isSession(entity)) {
		return entity.title || entity.name || 'Untitled Session';
	}

	// Quests use 'title'
	if (isQuest(entity)) {
		return entity.title || entity.name || 'Untitled Quest';
	}

	// Everyone else uses 'name'
	return entity.name || 'Unnamed';
};

/**
 * Get entity description
 * Handles different description fields
 * @param {Object} entity - Entity object
 * @returns {string|null}
 */
export const getEntityDescription = (entity) => {
	if (!entity) return null;

	// Try description first
	if (entity.description) return entity.description;

	// Sessions might use summary
	if (isSession(entity)) {
		return entity?.summary || entity.narrative || null;
	}

	// Characters might use background
	if (isEntityType(entity, 'character')) {
		return entity.background || entity.short_description || null;
	}

	return null;
};

/**
 * Get entity icon initial (first letter)
 * @param {Object} entity - Entity object
 * @returns {string}
 */
export const getEntityInitial = (entity) => {
	const name = getEntityName(entity);
	return (name[0] || 'E').toUpperCase();
};

/**
 * Check if entity is marked as dead/inactive
 * @param {Object} entity - Entity object
 * @returns {boolean}
 */
export const isEntityDead = (entity) => {
	const status = entity.status?.toLowerCase();
	return status === 'dead' || status === 'deceased' || status === 'inactive';
};

/**
 * Check if entity/quest is completed
 * @param {Object} entity - Entity object
 * @returns {boolean}
 */
export const isEntityCompleted = (entity) => {
	const status = entity.status?.toLowerCase();
	return ['completed', 'finished', 'done', 'success'].some((k) => status?.includes(k));
};

/**
 * Check if entity/quest has failed
 * @param {Object} entity - Entity object
 * @returns {boolean}
 */
export const isEntityFailed = (entity) => {
	const status = entity.status?.toLowerCase();
	return ['failed', 'failure', 'abandoned'].some((k) => status?.includes(k));
};

--- END OF utils\entity\entityHelpers.js ---

--- FILE: utils\image\imageResolver.js ---
/**
 * Centralized image URL resolution
 * Used by: EntityViewModel, EntityIndex, TooltipCard
 */

const IMAGE_KEYS = {
	background: ['background_image', 'background', 'Background', 'Background_image'],
	icon: ['icon', 'Icon', 'token', 'Token', 'portrait', 'Portrait'],
	any: ['background_image', 'background', 'image', 'Image', 'portrait', 'Portrait', 'icon', 'Icon'],
};

/**
 * Extract value from nested attribute structure
 */
const extractValue = (val) => {
	if (!val) return null;
	if (typeof val === 'string') return val;
	if (Array.isArray(val)) return val[0]?.value || val[0];
	if (typeof val === 'object' && val.value) return val.value;
	return null;
};

/**
 * Resolve image URL from attributes object
 * @param {Object} attributes - Entity attributes
 * @param {'background' | 'icon' | 'any'} type - Type of image to find
 * @returns {string|null} - Resolved URL or null
 */
export const resolveImageUrl = (attributes, type = 'any') => {
	if (!attributes) return null;

	const keys = IMAGE_KEYS[type] || IMAGE_KEYS.any;

	for (const key of keys) {
		const val = attributes[key] || attributes[key.toLowerCase()];
		const rawUrl = extractValue(val);

		if (rawUrl) {
			// Clean path and prepend base URL
			const cleanPath = rawUrl
				.trim()
				.replace(/(\.\.\/)+/g, '')
				.replace(/^\//, '');

			return `${import.meta.env.BASE_URL}${cleanPath}`;
		}
	}

	return null;
};

/**
 * Safe attribute parser
 */
export const parseAttributes = (attrs) => {
	if (!attrs) return {};
	if (typeof attrs === 'object') return attrs;
	try {
		return JSON.parse(attrs);
	} catch {
		return {};
	}
};

--- END OF utils\image\imageResolver.js ---

--- FILE: utils\status\statusHelpers.js ---
import { Sword, Shield, Circle, HelpCircle, CheckCircle2, XCircle, Clock } from 'lucide-react';
import { getAttributeValue } from '../entity/attributeParser';

/**
 * Rank definitions for sorting.
 * Lower number = Higher priority in lists.
 */
const AFFINITY_RANKS = {
	// Rank 1: Allies
	ally: 1,
	allies: 1,
	friend: 1,
	friendly: 1,
	helpful: 1,
	allied: 1,
	alliance: 1,
	aligned: 1,
	// Rank 2: Neutral
	neutral: 2,
	indifferent: 2,
	unknown: 2, // 'Unknown' faction status often implies neutral
	// Rank 3: Enemies
	enemy: 3,
	enemies: 3,
	hostile: 3,
	rival: 3,
	villain: 3,
	threat: 3,
	// Rank 99: Fallback
	other: 99,
};

/**
 * Calculate a numeric rank for an entity based on status/affinity string.
 * Used for sorting: Allies -> Neutral -> Enemies -> Unknown
 *
 * @param {string} statusOrAffinity
 * @returns {number} 1, 2, 3, or 99
 */
export const getAffinityRank = (statusOrAffinity) => {
	const key = (statusOrAffinity || '').toLowerCase();

	// Check for exact matches or substring matches
	for (const [term, rank] of Object.entries(AFFINITY_RANKS)) {
		if (key.includes(term)) return rank;
	}

	return 99;
};

/**
 * Get status icon based on entity type and status
 */
export const getStatusIcon = (status, type) => {
	const s = status?.toLowerCase() || 'unknown';

	// Quest-specific icons
	if (type === 'quest') {
		if (['active', 'in progress', 'started'].some((k) => s.includes(k))) {
			return { Icon: Circle, className: 'text-amber-500 fill-amber-500/20' };
		}
		if (['completed', 'finished', 'done', 'success'].some((k) => s.includes(k))) {
			return { Icon: CheckCircle2, className: 'text-emerald-600' };
		}
		if (['failed', 'failure'].some((k) => s.includes(k))) {
			return { Icon: XCircle, className: 'text-red-500' };
		}
		if (['abandoned', 'on-hold', 'paused'].some((k) => s.includes(k))) {
			return { Icon: Clock, className: 'text-slate-400' };
		}
		return { Icon: Circle, className: 'text-slate-300' };
	}

	// NPC/Faction affinity icons
	const rank = getAffinityRank(s);

	if (rank === 3) {
		// Enemy
		return { Icon: Sword, className: 'text-red-500 fill-red-500/10' };
	}
	if (rank === 1) {
		// Ally
		return { Icon: Shield, className: 'text-emerald-500 fill-emerald-500/10' };
	}
	// Neutral / Unknown
	return { Icon: Circle, className: 'text-gray-400' };
};

export const getStatusInfo = (entity) => {
	const statusRaw = entity.status || getAttributeValue(entity.attributes, ['status']);
	const affinityRaw = getAttributeValue(entity.attributes, ['affinity']);

	const displayStatus = affinityRaw && affinityRaw !== 'unknown' ? affinityRaw : statusRaw;
	const statusLower = displayStatus?.toLowerCase();

	return {
		raw: statusRaw,
		display: displayStatus,
		icon: getStatusIcon(displayStatus, entity.type),
		rank: getAffinityRank(displayStatus),
		isDead: statusLower === 'dead',
		isFailed: statusLower === 'failed',
		isCompleted: ['completed', 'finished', 'done', 'success'].some((k) => statusLower?.includes(k)),
	};
};

--- END OF utils\status\statusHelpers.js ---

--- FILE: utils\text\markdownHelpers.js ---
/**
 * Markdown-specific Utilities
 * Header extraction, ToC generation, etc.
 */

import { generateId } from './textProcessing';

/**
 * Extract headers from markdown text
 * @param {string} markdown - Markdown text
 * @returns {Array<{depth: number, text: string, id: string}>}
 */
export const extractHeaders = (markdown) => {
	if (!markdown) return [];

	const regex = /^(#{1,3})\s+(.+)$/gm;
	const headers = [];
	let match;

	while ((match = regex.exec(markdown)) !== null) {
		headers.push({
			depth: match[1].length, // 1, 2, or 3
			text: match[2].trim(),
			id: generateId(match[2]),
		});
	}

	return headers;
};

/**
 * Generate Table of Contents from markdown
 * @param {string} markdown - Markdown text
 * @param {number} maxDepth - Maximum heading depth (default 3)
 * @returns {Array<{depth: number, text: string, id: string}>}
 */
export const generateToC = (markdown, maxDepth = 3) => {
	const headers = extractHeaders(markdown);
	return headers.filter((h) => h.depth <= maxDepth);
};

/**
 * Convert markdown to plain text (strips formatting)
 * @param {string} markdown - Markdown text
 * @returns {string}
 */
export const markdownToText = (markdown) => {
	if (!markdown) return '';

	return markdown
		.replace(/#{1,6}\s+/g, '') // Headers
		.replace(/\*\*(.+?)\*\*/g, '$1') // Bold
		.replace(/\*(.+?)\*/g, '$1') // Italic
		.replace(/\[(.+?)\]\(.+?\)/g, '$1') // Links
		.replace(/`(.+?)`/g, '$1') // Code
		.replace(/^>\s+/gm, '') // Blockquotes
		.replace(/^[-*+]\s+/gm, '') // Lists
		.replace(/^\d+\.\s+/gm, '') // Ordered lists
		.trim();
};

/**
 * Extract excerpt from markdown (first paragraph)
 * @param {string} markdown - Markdown text
 * @param {number} maxLength - Maximum length (default 200)
 * @returns {string}
 */
export const extractExcerpt = (markdown, maxLength = 200) => {
	if (!markdown) return '';

	// Remove headers
	const withoutHeaders = markdown.replace(/^#{1,6}\s+.+$/gm, '');

	// Get first paragraph
	const paragraphs = withoutHeaders
		.split(/\n\n+/)
		.map((p) => p.trim())
		.filter(Boolean);

	if (paragraphs.length === 0) return '';

	const firstPara = markdownToText(paragraphs[0]);

	if (firstPara.length <= maxLength) return firstPara;
	return firstPara.slice(0, maxLength).trim() + '...';
};

/**
 * Count words in markdown (excluding formatting)
 * @param {string} markdown - Markdown text
 * @returns {number}
 */
export const countMarkdownWords = (markdown) => {
	const plainText = markdownToText(markdown);
	if (!plainText) return 0;
	return plainText.trim().split(/\s+/).length;
};

/**
 * Parse markdown frontmatter (YAML at start of document)
 * @param {string} markdown - Markdown with frontmatter
 * @returns {{frontmatter: Object, content: string}}
 */
export const parseFrontmatter = (markdown) => {
	if (!markdown) return { frontmatter: {}, content: '' };

	const frontmatterRegex = /^---\n([\s\S]*?)\n---\n([\s\S]*)$/;
	const match = markdown.match(frontmatterRegex);

	if (!match) {
		return { frontmatter: {}, content: markdown };
	}

	// Simple YAML parser (key: value pairs only)
	const frontmatterText = match[1];
	const frontmatter = {};

	frontmatterText.split('\n').forEach((line) => {
		const colonIndex = line.indexOf(':');
		if (colonIndex > 0) {
			const key = line.slice(0, colonIndex).trim();
			const value = line.slice(colonIndex + 1).trim();
			frontmatter[key] = value;
		}
	});

	return {
		frontmatter,
		content: match[2],
	};
};

/**
 * Add IDs to headers in markdown (for anchor links)
 * @param {string} markdown - Original markdown
 * @returns {string} Markdown with header IDs
 */
export const addHeaderIds = (markdown) => {
	if (!markdown) return '';

	return markdown.replace(/^(#{1,6})\s+(.+)$/gm, (match, hashes, text) => {
		const id = generateId(text);
		return `${hashes} ${text} {#${id}}`;
	});
};

--- END OF utils\text\markdownHelpers.js ---

--- FILE: utils\text\textProcessing.js ---
/**
 * Text Processing Utilities
 * String manipulation, sanitization, and formatting
 */

/**
 * Truncate text to a maximum length with ellipsis
 * @param {string} text - Text to truncate
 * @param {number} maxLength - Maximum length
 * @returns {string}
 */
export const truncate = (text, maxLength = 100) => {
	if (!text || text.length <= maxLength) return text;
	return text.slice(0, maxLength).trim() + '...';
};

/**
 * Sanitize text for safe display
 * @param {string} text - Text to sanitize
 * @returns {string}
 */
export const sanitizeText = (text) => {
	if (!text) return '';
	return String(text).trim();
};

/**
 * Convert text to URL-safe slug
 * @param {string} text - Text to convert
 * @returns {string}
 */
export const slugify = (text) => {
	if (!text) return '';

	return text
		.toString()
		.toLowerCase()
		.trim()
		.replace(/\s+/g, '-') // Replace spaces with -
		.replace(/[^\w-]+/g, '') // Remove non-word chars
		.replace(/--+/g, '-') // Replace multiple - with single -
		.replace(/^-+/, '') // Trim - from start
		.replace(/-+$/, ''); // Trim - from end
};

/**
 * Generate a unique ID from text (for headings, anchors)
 * @param {string} text - Text to convert
 * @returns {string}
 */
export const generateId = (text) => {
	if (!text) return '';

	return text
		.toString()
		.toLowerCase()
		.trim()
		.replace(/\s+/g, '-')
		.replace(/[^\w-]+/g, '')
		.replace(/--+/g, '-');
};

/**
 * Extract plain text from children (for React components)
 * @param {*} children - React children
 * @returns {string}
 */
export const extractText = (children) => {
	if (typeof children === 'string') return children;
	if (Array.isArray(children)) return children.map(extractText).join('');
	if (children?.props?.children) return extractText(children.props.children);
	return '';
};

/**
 * Capitalize first letter of string
 * @param {string} text - Text to capitalize
 * @returns {string}
 */
export const capitalize = (text) => {
	if (!text) return '';
	return text.charAt(0).toUpperCase() + text.slice(1);
};

/**
 * Convert snake_case or kebab-case to Title Case
 * @param {string} text - Text to convert
 * @returns {string}
 */
export const toTitleCase = (text) => {
	if (!text) return '';

	return text
		.replace(/[_-]/g, ' ')
		.split(' ')
		.map((word) => capitalize(word))
		.join(' ');
};

/**
 * Count words in text
 * @param {string} text - Text to count
 * @returns {number}
 */
export const wordCount = (text) => {
	if (!text) return 0;
	return text.trim().split(/\s+/).length;
};

/**
 * Estimate reading time in minutes
 * @param {string} text - Text to analyze
 * @param {number} wordsPerMinute - Reading speed (default 200)
 * @returns {number}
 */
export const estimateReadingTime = (text, wordsPerMinute = 200) => {
	const words = wordCount(text);
	return Math.ceil(words / wordsPerMinute);
};

/**
 * Escape special regex characters
 * @param {string} str - String to escape
 * @returns {string}
 */
export const escapeRegex = (str) => {
	return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};

/**
 * Strip markdown formatting (basic)
 * @param {string} text - Markdown text
 * @returns {string} Plain text
 */
export const stripMarkdown = (text) => {
	if (!text) return '';

	return text
		.replace(/#{1,6}\s+/g, '') // Headers
		.replace(/\*\*(.+?)\*\*/g, '$1') // Bold
		.replace(/\*(.+?)\*/g, '$1') // Italic
		.replace(/\[(.+?)\]\(.+?\)/g, '$1') // Links
		.replace(/`(.+?)`/g, '$1') // Code
		.replace(/^>\s+/gm, '') // Blockquotes
		.trim();
};

/**
 * Check if text contains markdown formatting
 * @param {string} text - Text to check
 * @returns {boolean}
 */
export const hasMarkdown = (text) => {
	if (!text) return false;

	const markdownPatterns = [
		/#{1,6}\s+/, // Headers
		/\*\*.*?\*\*/, // Bold
		/\*.*?\*/, // Italic
		/\[.*?\]\(.*?\)/, // Links
		/`.*?`/, // Code
		/^>\s+/m, // Blockquotes
		/^[-*+]\s+/m, // Lists
		/^\d+\.\s+/m, // Ordered lists
	];

	return markdownPatterns.some((pattern) => pattern.test(text));
};

--- END OF utils\text\textProcessing.js ---

--- FILE: utils\theme\colorHelpers.js ---
/**
 * Color and Theme Utilities
 * Color manipulation, hex/rgb conversion, opacity
 */

/**
 * Convert hex color to RGB
 * @param {string} hex - Hex color (e.g., "#ff0000" or "ff0000")
 * @returns {{r: number, g: number, b: number}|null}
 */
export const hexToRgb = (hex) => {
	if (!hex) return null;

	// Remove # if present
	const cleanHex = hex.replace('#', '');

	// Validate hex
	if (!/^[0-9A-F]{6}$/i.test(cleanHex)) return null;

	return {
		r: parseInt(cleanHex.slice(0, 2), 16),
		g: parseInt(cleanHex.slice(2, 4), 16),
		b: parseInt(cleanHex.slice(4, 6), 16),
	};
};

/**
 * Convert RGB to hex
 * @param {number} r - Red (0-255)
 * @param {number} g - Green (0-255)
 * @param {number} b - Blue (0-255)
 * @returns {string} Hex color
 */
export const rgbToHex = (r, g, b) => {
	const toHex = (n) => {
		const hex = Math.max(0, Math.min(255, Math.round(n))).toString(16);
		return hex.length === 1 ? '0' + hex : hex;
	};

	return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
};

/**
 * Add opacity to hex color
 * @param {string} hex - Hex color
 * @param {number} opacity - Opacity (0-1)
 * @returns {string} rgba() string
 */
export const hexWithOpacity = (hex, opacity) => {
	const rgb = hexToRgb(hex);
	if (!rgb) return hex;

	return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
};

/**
 * Lighten a hex color by percentage
 * @param {string} hex - Hex color
 * @param {number} percent - Percentage to lighten (0-100)
 * @returns {string} New hex color
 */
export const lightenColor = (hex, percent) => {
	const rgb = hexToRgb(hex);
	if (!rgb) return hex;

	const amount = (percent / 100) * 255;

	return rgbToHex(rgb.r + amount, rgb.g + amount, rgb.b + amount);
};

/**
 * Darken a hex color by percentage
 * @param {string} hex - Hex color
 * @param {number} percent - Percentage to darken (0-100)
 * @returns {string} New hex color
 */
export const darkenColor = (hex, percent) => {
	const rgb = hexToRgb(hex);
	if (!rgb) return hex;

	const amount = (percent / 100) * 255;

	return rgbToHex(rgb.r - amount, rgb.g - amount, rgb.b - amount);
};

/**
 * Get contrasting text color (black or white) for background
 * @param {string} hex - Background hex color
 * @returns {string} '#000000' or '#ffffff'
 */
export const getContrastColor = (hex) => {
	const rgb = hexToRgb(hex);
	if (!rgb) return '#000000';

	// Calculate relative luminance
	const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;

	return luminance > 0.5 ? '#000000' : '#ffffff';
};

/**
 * Check if a color is light or dark
 * @param {string} hex - Hex color
 * @returns {'light'|'dark'}
 */
export const getColorBrightness = (hex) => {
	return getContrastColor(hex) === '#000000' ? 'light' : 'dark';
};

/**
 * Generate color palette from base color
 * @param {string} hex - Base hex color
 * @returns {Object} Palette with shades
 */
export const generatePalette = (hex) => {
	return {
		50: lightenColor(hex, 45),
		100: lightenColor(hex, 40),
		200: lightenColor(hex, 30),
		300: lightenColor(hex, 20),
		400: lightenColor(hex, 10),
		500: hex,
		600: darkenColor(hex, 10),
		700: darkenColor(hex, 20),
		800: darkenColor(hex, 30),
		900: darkenColor(hex, 40),
	};
};

/**
 * Parse CSS color value (hex, rgb, rgba)
 * @param {string} color - CSS color string
 * @returns {{r: number, g: number, b: number, a: number}|null}
 */
export const parseColor = (color) => {
	if (!color) return null;

	// Hex
	if (color.startsWith('#')) {
		const rgb = hexToRgb(color);
		return rgb ? { ...rgb, a: 1 } : null;
	}

	// RGB/RGBA
	const rgbaMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
	if (rgbaMatch) {
		return {
			r: parseInt(rgbaMatch[1]),
			g: parseInt(rgbaMatch[2]),
			b: parseInt(rgbaMatch[3]),
			a: rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1,
		};
	}

	return null;
};

--- END OF utils\theme\colorHelpers.js ---

--- FILE: utils\theme\cssVariables.js ---
/**
 * CSS Variable Utilities
 * Read and write CSS custom properties
 */

/**
 * Get CSS variable value from document root
 * @param {string} name - Variable name (with or without --)
 * @returns {string} Variable value
 */
export const getCSSVariable = (name) => {
	const varName = name.startsWith('--') ? name : `--${name}`;
	return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
};

/**
 * Set CSS variable on document root
 * @param {string} name - Variable name (with or without --)
 * @param {string} value - Variable value
 */
export const setCSSVariable = (name, value) => {
	const varName = name.startsWith('--') ? name : `--${name}`;
	document.documentElement.style.setProperty(varName, value);
};

/**
 * Get all theme CSS variables
 * @returns {Object} Theme variables
 */
export const getThemeVariables = () => {
	return {
		background: getCSSVariable('--background'),
		foreground: getCSSVariable('--foreground'),
		muted: getCSSVariable('--muted'),
		mutedForeground: getCSSVariable('--muted-foreground'),
		border: getCSSVariable('--border'),
		accent: getCSSVariable('--accent'),
		accentForeground: getCSSVariable('--accent-foreground'),
	};
};

/**
 * Apply theme variables
 * @param {Object} theme - Theme variable object
 */
export const applyTheme = (theme) => {
	Object.entries(theme).forEach(([key, value]) => {
		// Convert camelCase to kebab-case
		const cssKey = key.replace(/([A-Z])/g, '-$1').toLowerCase();
		setCSSVariable(cssKey, value);
	});
};

/**
 * Get current theme mode (light/dark/dnd)
 * @returns {string} Theme mode
 */
export const getCurrentTheme = () => {
	return document.documentElement.getAttribute('data-theme') || 'light';
};

/**
 * Set theme mode
 * @param {string} theme - Theme name (light/dark/dnd)
 */
export const setTheme = (theme) => {
	if (theme === 'light') {
		document.documentElement.removeAttribute('data-theme');
	} else {
		document.documentElement.setAttribute('data-theme', theme);
	}
	localStorage.setItem('app-theme', theme);
};

/**
 * Get stored theme preference
 * @returns {string} Stored theme or 'light'
 */
export const getStoredTheme = () => {
	return localStorage.getItem('app-theme') || 'light';
};

/**
 * Check if system prefers dark mode
 * @returns {boolean}
 */
export const prefersDarkMode = () => {
	return window.matchMedia('(prefers-color-scheme: dark)').matches;
};

/**
 * Get optimal theme based on preference and system
 * @returns {string} Theme name
 */
export const getOptimalTheme = () => {
	const stored = getStoredTheme();
	if (stored !== 'auto') return stored;

	return prefersDarkMode() ? 'dark' : 'light';
};

--- END OF utils\theme\cssVariables.js ---

