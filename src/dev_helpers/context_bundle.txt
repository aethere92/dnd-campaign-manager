================================================================
PROJECT CONTEXT BUNDLE: D&D CAMPAIGN MANAGER
================================================================
INSTRUCTIONS FOR AI:
- This is the entire source code for a React/Vite app.
- Maintain architectural consistency at all costs.
- Reuse existing hooks, UI components, and Supabase patterns.
- Do not suggest new libraries or 'from-scratch' rewrites.
================================================================

### PROJECT MAP (FILE STRUCTURE)
./
  fix-dark-mode.sh
  main.jsx
  app/
    App.jsx
    AppRoutes.jsx
    components/
      RouteLoading.jsx
    styles/
      global.css
  domain/
    entity/
      api/
        entityService.js
      components/
        EntityBadge.jsx
        EntityIcon.jsx
        EntityLink.jsx
        EntityStatusIcon.jsx
      config/
        entityColors.js
        entityConfig.js
        entityIcons.js
        entityStyles.js
        entityTypes.js
      utils/
        attributeParser.js
        entityUtils.js
        statusUtils.js
  features/
    admin/
      api/
        adminService.js
      components/
        AdminForm.jsx
        AdminFormStyles.js
        EncounterManager.jsx
        EntitySearch.jsx
        EventTagger.jsx
        ImageLibraryModal.jsx
        MarkdownEditor.jsx
        QuestObjectiveManager.jsx
        RelationshipManager.jsx
        SessionEventManager.jsx
        SmartImageInput.jsx
        TacticalMapManager.jsx
      config/
        adminStrategies.js
        imageLibrary.js
        imageManifest.json
      layouts/
        AdminLayout.jsx
      pages/
        BulkReplaceTool.jsx
        EntityEditorPage.jsx
        EntityListPage.jsx
        SplitPaneManager.jsx
    atlas/
      MapPage.jsx
      useMapData.js
      components/
        AtlasSidebar.jsx
        MapCanvas.jsx
        MapTools.jsx
        useMapCanvasViewModel.js
        __MapLayerControl.jsx
        layers/
          MapAreas.jsx
          MapMarkers.jsx
          MapOverlays.jsx
          MapRecaps.jsx
      config/
        mapConfig.js
      data/
      utils/
        mapNavigation.js
        markerUtils.js
    campaign/
      CampaignContext.jsx
      useCampaignPersistence.js
      useCampaignSelection.js
      api/
        campaignService.js
      components/
        CampaignCard.jsx
        CampaignSelect.jsx
    dashboard/
      DashboardPage.jsx
      api/
        dashboardService.js
      components/
        ActiveQuestsWidget.jsx
        CampaignHero.jsx
        LatestSessionCard.jsx
        QuickInsights.jsx
        RecentEncountersWidget.jsx
        RecentSessionsList.jsx
        SessionRecapCard.jsx
    graph/
      GraphPage.jsx
      useGraphView.js
      api/
        graphService.js
      components/
        CytoscapeCanvas.jsx
        GraphLegend.jsx
      config/
        graphStyles.js
      utils/
        graphMapper.js
    navigation/
      MainLayout.jsx
      useNavigation.js
      components/
        Sidebar.jsx
        SidebarFooter.jsx
        SidebarHeader.jsx
        SidebarNav.jsx
      config/
        navConfig.js
    search/
      GlobalSearch.jsx
      SearchContext.jsx
      useGlobalSearch.js
      api/
        searchService.js
      components/
        SearchFooter.jsx
        SearchModal.jsx
        SearchResultItem.jsx
        SearchResults.jsx
        SearchTrigger.jsx
      utils/
        searchMapper.js
    smart-text/
      SmartMarkdown.jsx
      useEntityIndex.js
      useSmartText.js
      components/
        EntityEmbed.jsx
        SmartEntityLink.jsx
    smart-tooltip/
      TooltipContainer.jsx
      TooltipContext.jsx
      useSmartPosition.js
      useTooltipState.js
      components/
        TooltipCard.jsx
    table-of-contents/
      TableOfContents.jsx
      components/
        TocItem.jsx
        TocMobileDrawer.jsx
      hooks/
        useTocObserver.js
        useTocScroll.js
    timeline/
      TimelinePage.jsx
      useTimelineView.js
      api/
        timelineService.js
      components/
        TimelineEvent.jsx
        TimelineSession.jsx
      utils/
        eventStyles.js
    wiki/
      useEntityView.js
      useWikiNavigation.js
      WikiLayout.jsx
      api/
        wikiService.js
      components/
        EncounterTimeline.jsx
        EntityBody.jsx
        EntityHeader.jsx
        EntityHistory.jsx
        EntityMiniMap.jsx
        EntitySidebar.jsx
        QuestObjectives.jsx
        SessionMentions.jsx
        WikiEntryView.jsx
        landing/
          EntityGridCard.jsx
          EntityTableGroup.jsx
          Swimlane.jsx
        navigation/
          SidebarEmptyState.jsx
          WikiSidebar.jsx
          WikiSidebarHeader.jsx
          WikiSidebarList.jsx
          sidebar/
            CollapsibleGroup.jsx
            EntityListItem.jsx
            PriorityIcon.jsx
            SidebarTreeItem.jsx
            StatusIcon.jsx
      config/
        groupingConfig.js
        viewStrategies.js
      hooks/
        useEntityContent.js
        useEntityFetching.js
        useEntityGrouping.js
        useEntityHeader.js
        useEntitySidebar.js
      layouts/
        SessionLayout.jsx
        StandardLayout.jsx
      pages/
        WikiDetailPage.jsx
        WikiLandingPage.jsx
      utils/
        attributeMapper.js
        eventMapper.js
        relationshipMapper.js
        wikiEntryMapper.js
        wikiUtils.js
  shared/
    api/
      supabaseClient.js
    components/
      ErrorBoundary.jsx
      layout/
        CollapsibleSection.jsx
        SplitView.jsx
        TabContainer.jsx
      markdown/
        MarkdownRenderer.jsx
        MarkdownWithToC.jsx
      ui/
        Breadcrumbs.jsx
        Button.jsx
        Card.jsx
        DevAdminButton.jsx
        Drawer.jsx
        EmptyState.jsx
        LoadingSpinner.jsx
        SectionDivider.jsx
    hooks/
      useBreadcrumbs.js
      useTheme.js
    utils/
      imageUtils.js
      markdownUtils.js
      textUtils.js
      theme/
        colorUtils.js
        cssUtils.js

================================================================
### SOURCE CODE
================================================================

--- FILE: fix-dark-mode.sh ---
#!/bin/bash

# Dark Mode Fix Script
# This script performs find-and-replace operations to convert hardcoded colors to theme-aware tokens
# Run this from your project root directory

echo "ðŸŽ¨ Starting Dark Mode Fix Script..."
echo "===================================="

# Function to replace in files
replace_in_files() {
    local search="$1"
    local replace="$2"
    local description="$3"
    
    echo "ðŸ“ $description"
    
    # Use find and sed to replace in all .jsx files
    find features/ -name "*.jsx" -type f -exec sed -i.bak "s/$search/$replace/g" {} \;
    
    # Clean up backup files
    find features/ -name "*.bak" -type f -delete
}

echo ""
echo "ðŸ” Phase 1: Text Colors"
echo "----------------------"

# Foreground colors (dark text)
replace_in_files "text-stone-900" "text-foreground" "Converting text-stone-900 â†’ text-foreground"
replace_in_files "text-stone-800" "text-foreground" "Converting text-stone-800 â†’ text-foreground"
replace_in_files "text-stone-700" "text-card-foreground" "Converting text-stone-700 â†’ text-card-foreground"
replace_in_files "text-gray-900" "text-foreground" "Converting text-gray-900 â†’ text-foreground"
replace_in_files "text-slate-900" "text-foreground" "Converting text-slate-900 â†’ text-foreground"

# Muted text colors
replace_in_files "text-stone-600" "text-muted-foreground" "Converting text-stone-600 â†’ text-muted-foreground"
replace_in_files "text-stone-500" "text-muted-foreground" "Converting text-stone-500 â†’ text-muted-foreground"
replace_in_files "text-stone-400" "text-muted-foreground" "Converting text-stone-400 â†’ text-muted-foreground"
replace_in_files "text-gray-500" "text-muted-foreground" "Converting text-gray-500 â†’ text-muted-foreground"
replace_in_files "text-slate-500" "text-muted-foreground" "Converting text-slate-500 â†’ text-muted-foreground"

echo ""
echo "ðŸŽ¨ Phase 2: Background Colors"
echo "-----------------------------"

# Card backgrounds
replace_in_files "bg-stone-50" "bg-muted" "Converting bg-stone-50 â†’ bg-muted"
replace_in_files "bg-gray-50" "bg-muted" "Converting bg-gray-50 â†’ bg-muted"
replace_in_files "bg-slate-50" "bg-muted" "Converting bg-slate-50 â†’ bg-muted"
replace_in_files "bg-stone-100" "bg-muted" "Converting bg-stone-100 â†’ bg-muted"

# Subtle backgrounds
replace_in_files "bg-stone-200\\/60" "bg-muted\\/80" "Converting bg-stone-200/60 â†’ bg-muted/80"
replace_in_files "bg-stone-200\\/50" "bg-muted\\/60" "Converting bg-stone-200/50 â†’ bg-muted/60"

echo ""
echo "ðŸ”² Phase 3: Border Colors"
echo "-------------------------"

replace_in_files "border-stone-300" "border-border" "Converting border-stone-300 â†’ border-border"
replace_in_files "border-stone-200" "border-border" "Converting border-stone-200 â†’ border-border"
replace_in_files "border-gray-200" "border-border" "Converting border-gray-200 â†’ border-border"
replace_in_files "border-slate-200" "border-border" "Converting border-slate-200 â†’ border-border"

replace_in_files "border-stone-200\\/60" "border-border\\/60" "Converting border-stone-200/60 â†’ border-border/60"
replace_in_files "border-stone-200\\/40" "border-border\\/40" "Converting border-stone-200/40 â†’ border-border/40"

echo ""
echo "ðŸ“Š Phase 4: Divide Colors"
echo "-------------------------"

replace_in_files "divide-stone-200" "divide-border" "Converting divide-stone-200 â†’ divide-border"
replace_in_files "divide-gray-200" "divide-border" "Converting divide-gray-200 â†’ divide-border"

echo ""
echo "ðŸ’ Phase 5: Ring Colors"
echo "-----------------------"

replace_in_files "ring-stone-200" "ring-border" "Converting ring-stone-200 â†’ ring-border"
replace_in_files "ring-gray-200" "ring-border" "Converting ring-gray-200 â†’ ring-border"

echo ""
echo "âœ¨ Phase 6: Special Cases"
echo "-------------------------"

# Specific component fixes
echo "ðŸ“ Fixing EntityHeader gradient..."
find features/wiki/components -name "EntityHeader.jsx" -type f -exec sed -i.bak \
    "s/from-\\\[var(--background)\\\] from-0% via-\\\[var(--background)\\\]\\/60 via-15% to-transparent/from-background via-background\\/60 to-transparent/g" {} \;

echo "ðŸ“ Fixing prose in EntityBody..."
find features/wiki/components -name "EntityBody.jsx" -type f -exec sed -i.bak \
    "s/prose-slate//g" {} \;

echo "ðŸ“ Fixing sidebar colors..."
find features/wiki/components -name "EntitySidebar.jsx" -type f -exec sed -i.bak \
    "s/text-stone-400/text-muted-foreground/g" {} \;

find features/wiki/components/navigation/sidebar -name "*.jsx" -type f -exec sed -i.bak \
    "s/text-stone-500/text-muted-foreground/g" {} \;

# Clean up all backup files
find features/ -name "*.bak" -type f -delete

echo ""
echo "âœ… Dark Mode Fix Complete!"
echo "=========================="
echo ""
echo "ðŸ“‹ Summary:"
echo "  - Replaced hardcoded text colors with semantic tokens"
echo "  - Updated background colors to theme-aware classes"
echo "  - Fixed border and divide colors"
echo "  - Applied special fixes to key components"
echo ""
echo "ðŸ” Next Steps:"
echo "  1. Review the changes in your components"
echo "  2. Test light, dark, and D&D themes"
echo "  3. Check for any remaining hardcoded colors"
echo "  4. Run your linter and fix any issues"
echo ""
echo "ðŸ’¡ Tips:"
echo "  - Use 'text-foreground' for primary text"
echo "  - Use 'text-muted-foreground' for secondary text"
echo "  - Use 'bg-muted' for subtle backgrounds"
echo "  - Use 'border-border' for all borders"
echo ""
--- END OF fix-dark-mode.sh ---

--- FILE: main.jsx ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import { HashRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import App from '@/app/App';
import '@/app/styles/global.css';
import 'leaflet/dist/leaflet.css';

const validateEnv = () => {
	const required = ['VITE_SUPABASE_URL', 'VITE_SUPABASE_ANON_KEY'];
	const missing = required.filter((key) => !import.meta.env[key]);
	if (missing.length > 0) {
		console.error('Missing required environment variables:', missing);
	}
};
validateEnv();

// CHANGED: Aggressive Caching Configuration
const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			// Data is considered fresh for 1 hour
			staleTime: 1000 * 60 * 60,
			// Keep unused data in memory for 24 hours
			cacheTime: 1000 * 60 * 60 * 24,
			refetchOnWindowFocus: false,
			refetchOnMount: false, // Don't refetch just because component remounted
			retry: 1,
		},
	},
});

ReactDOM.createRoot(document.getElementById('root')).render(
	<React.StrictMode>
		<QueryClientProvider client={queryClient}>
			<HashRouter>
				<App />
			</HashRouter>
		</QueryClientProvider>
	</React.StrictMode>
);

--- END OF main.jsx ---

--- FILE: app\App.jsx ---
import { useEffect } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { TooltipProvider } from '@/features/smart-tooltip/TooltipContext';
import { CampaignProvider, useCampaign } from '@/features/campaign/CampaignContext';
import ErrorBoundary from '@/shared/components/ErrorBoundary';
import { AppRoutes } from './AppRoutes';

function AppContent() {
	const { campaignId } = useCampaign();
	const queryClient = useQueryClient();

	// 1. Set global texture
	useEffect(() => {
		const texturePath = `${import.meta.env.BASE_URL}images/background_texture.png`;
		document.documentElement.style.setProperty('--bg-texture', `url('${texturePath}')`);
	}, []);

	// 2. Set Default App Title
	useEffect(() => {
		document.title = 'D&D Campaign Manager';
	}, []);

	// 3. Clear cache when campaign changes
	useEffect(() => {
		if (campaignId) {
			queryClient.invalidateQueries({
				predicate: (query) => {
					const key = query.queryKey[0];
					return ['entities', 'entry', 'timeline', 'graph', 'entityIndex', 'globalSearch'].includes(key);
				},
			});
		}
	}, [campaignId, queryClient]);

	return (
		<TooltipProvider>
			<AppRoutes />
		</TooltipProvider>
	);
}

export default function App() {
	return (
		<ErrorBoundary>
			<CampaignProvider>
				<AppContent />
			</CampaignProvider>
		</ErrorBoundary>
	);
}

--- END OF app\App.jsx ---

--- FILE: app\AppRoutes.jsx ---
import { Routes, Route, Navigate } from 'react-router-dom';
import { Suspense, lazy } from 'react';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { RouteLoading } from './components/RouteLoading';

const CampaignSelect = lazy(() => import('@/features/campaign/components/CampaignSelect'));
const MainLayout = lazy(() => import('@/features/navigation/MainLayout'));
const DashboardPage = lazy(() => import('@/features/dashboard/DashboardPage'));
const MapPage = lazy(() => import('@/features/atlas/MapPage'));
const TimelinePage = lazy(() => import('@/features/timeline/TimelinePage'));
const GraphPage = lazy(() => import('@/features/graph/GraphPage'));
const WikiLayout = lazy(() => import('@/features/wiki/WikiLayout'));
const WikiDetailPage = lazy(() => import('@/features/wiki/pages/WikiDetailPage'));
const WikiLandingPage = lazy(() => import('@/features/wiki/pages/WikiLandingPage'));

// Admin Features
const AdminLayout = lazy(() => import('@/features/admin/layouts/AdminLayout'));
const SplitPaneManager = lazy(() => import('@/features/admin/pages/SplitPaneManager'));
const BulkReplaceTool = lazy(() => import('@/features/admin/pages/BulkReplaceTool'));

export const AppRoutes = () => {
	const { campaignId } = useCampaign();
	const isDev = import.meta.env.DEV;

	return (
		<Suspense fallback={<RouteLoading text='Loading Application...' />}>
			<Routes>
				{/* Admin Console */}
				{isDev && (
					<Route path='/dm' element={<AdminLayout />}>
						<Route index element={<Navigate to='/dm/manage/campaign' replace />} />
						<Route path='manage/:type/:id?' element={<SplitPaneManager />} />
						<Route path='tools/replace' element={<BulkReplaceTool />} />
					</Route>
				)}

				{/* Campaign Selection */}
				<Route path='/select-campaign' element={<CampaignSelect />} />

				{/* Main App */}
				{campaignId ? (
					<Route path='/' element={<MainLayout />}>
						<Route index element={<DashboardPage />} />

						<Route path='atlas/:mapId' element={<MapPage />} />
						<Route path='atlas' element={<Navigate to='/atlas/world_map' replace />} />
						<Route path='timeline' element={<TimelinePage />} />
						<Route path='relationships' element={<GraphPage />} />

						<Route path='wiki/:type' element={<WikiLayout />}>
							<Route index element={<WikiLandingPage />} />
							<Route path=':entityId' element={<WikiDetailPage />} />
						</Route>

						<Route path='*' element={<Navigate to='/' replace />} />
					</Route>
				) : (
					<Route path='*' element={<Navigate to='/select-campaign' replace />} />
				)}
			</Routes>
		</Suspense>
	);
};

--- END OF app\AppRoutes.jsx ---

--- FILE: app\components\RouteLoading.jsx ---
import LoadingSpinner from '@/shared/components/ui/LoadingSpinner';

export const RouteLoading = ({ text }) => (
	<div className='flex items-center justify-center h-full min-h-screen bg-muted'>
		<LoadingSpinner size='lg' text={text} />
	</div>
);

--- END OF app\components\RouteLoading.jsx ---

--- FILE: app\styles\global.css ---
@import 'tailwindcss';
@plugin "@tailwindcss/typography";

@theme {
	--font-sans: 'Inter', sans-serif;
	--font-serif: 'Inter', serif;
	--font-display: 'Crimson Text', serif;

	/* Semantic Color Mapping */
	--color-background: var(--background);
	--color-foreground: var(--foreground);
	--color-card: var(--card);
	--color-card-foreground: var(--card-foreground);
	--color-popover: var(--popover);
	--color-popover-foreground: var(--popover-foreground);
	--color-primary: var(--primary);
	--color-primary-foreground: var(--primary-foreground);
	--color-secondary: var(--secondary);
	--color-secondary-foreground: var(--secondary-foreground);
	--color-muted: var(--muted);
	--color-muted-foreground: var(--muted-foreground);
	--color-accent: var(--accent);
	--color-accent-foreground: var(--accent-foreground);
	--color-destructive: var(--destructive);
	--color-destructive-foreground: var(--destructive-foreground);
	--color-border: var(--border);
	--color-input: var(--input);
	--color-ring: var(--ring);
}

@layer base {
	* {
		@apply border-border;
	}
	html,
	body,
	#root {
		height: 100%;
		height: 100dvh;
		overflow: hidden;
		overscroll-behavior: none;
		-webkit-tap-highlight-color: transparent;
	}
	body {
		@apply bg-background text-foreground antialiased font-sans;
	}
	/* Heading Defaults */
	h1,
	h2,
	h3,
	h4,
	h5,
	h6 {
		@apply font-serif font-bold text-foreground;
	}
}

/* --- THEME DEFINITIONS --- */

/* LIGHT MODE */
:root {
	--background: #ffffff;
	--foreground: #09090b;
	--card: #ffffff;
	--card-foreground: #09090b;
	--popover: #ffffff;
	--popover-foreground: #09090b;
	--primary: #d97706;
	--primary-foreground: #ffffff;
	--secondary: #f4f4f5;
	--secondary-foreground: #18181b;
	--muted: #f4f4f5;
	--muted-foreground: #71717a;
	--accent: #f4f4f5;
	--accent-foreground: #18181b;
	--destructive: #ef4444;
	--destructive-foreground: #fafafa;
	--border: #e4e4e7;
	--input: #e4e4e7;
	--ring: #d97706;
	--radius: 0.5rem;
}

/* DARK MODE (Zinc) */
[data-theme='dark'] {
	--background: rgb(17 17 17);
	--foreground: #eee;
	--card: #18181b;
	--card-foreground: #fafafa;
	--popover: #18181b;
	--popover-foreground: #fafafa;
	--primary: #f59e0b;
	--primary-foreground: #09090b;
	--secondary: #27272a;
	--secondary-foreground: #fafafa;
	--muted: #1c1c1f;
	--muted-foreground: #a1a1aa;
	--accent: #27272a;
	--accent-foreground: #fafafa;
	--destructive: #ef4444;
	--destructive-foreground: #fafafa;
	--border: #27272a;
	--input: #27272a;
	--ring: #f59e0b;
}

/* D&D MODE (Parchment) */
[data-theme='dnd'] {
	--background: #fdfbf7;
	--foreground: #2c1a11;
	--card: #fdfbf7;
	--card-foreground: #1b1b1b;
	--popover: #fdfbf7;
	--popover-foreground: #1b1b1b;
	--primary: #d97706; /* Amber-600 */
	--primary-foreground: #ffffff;
	--secondary: #f2efe9;
	--secondary-foreground: #1b1b1b;
	--muted: #f2efe9;
	--muted-foreground: #5f5a52;
	--accent: #f2efe9;
	--accent-foreground: #1b1b1b;
	--destructive: #991b1b;
	--destructive-foreground: #ffffff;
	--border: #cecece;
	--input: #c9c2b8;
	--ring: #8b1e1e;

	--entity-session: #5f5a52;
	--entity-character: #c10007; /* Deep blood red */
	--entity-npc: #bb4d00; /* Burnt Sienna */
	--entity-location: #007a55; /* Deep Forest/Moss green */
	--entity-quest: #1447e6; /* Deep Navy ink */
	--entity-faction: #8200db; /* Royal Plum ink */
	--entity-encounter: #ca3500; /* Iron Oxide */

	text-rendering: optimizeLegibility;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
}

[data-theme='dnd'] .prose,
[data-theme='dnd'] body {
	text-shadow: 0 0 0.15px rgba(44, 26, 17, 0.1);
}

/* D&D Mode Texture */
[data-theme='dnd'] .bg-background {
	background-color: var(--background);
	background-image: var(--bg-texture, none);
	background-repeat: repeat;
}

[data-theme='dnd'] .bg-muted {
	background-color: var(--muted);
	border-right-color: #c9c2b8;
}

/* --- TYPOGRAPHY (Prose) --- */
.prose {
	--tw-prose-body: var(--foreground);
	--tw-prose-headings: var(--foreground);
	--tw-prose-lead: var(--muted-foreground);
	--tw-prose-links: var(--primary);
	--tw-prose-bold: var(--foreground);
	--tw-prose-counters: var(--muted-foreground);
	--tw-prose-bullets: var(--primary);
	--tw-prose-hr: var(--border);
	--tw-prose-quotes: var(--foreground);
	--tw-prose-quote-borders: var(--primary);
	--tw-prose-captions: var(--muted-foreground);
	--tw-prose-code: var(--foreground);
	--tw-prose-pre-code: var(--foreground);
	--tw-prose-pre-bg: var(--muted);
	--tw-prose-th-borders: var(--border);
	--tw-prose-td-borders: var(--border);

	font-family: var(--font-sans);
	max-width: none;
}

/* Prose Dark Mode Overrides */
[data-theme='dark'] .prose {
	--tw-prose-body: var(--foreground);
	--tw-prose-headings: var(--foreground);
	--tw-prose-lead: var(--muted-foreground);
	--tw-prose-links: var(--primary);
	--tw-prose-bold: var(--foreground);
	--tw-prose-counters: var(--muted-foreground);
	--tw-prose-bullets: var(--primary);
	--tw-prose-hr: var(--border);
	--tw-prose-quotes: var(--muted-foreground);
	--tw-prose-quote-borders: var(--primary);
	--tw-prose-captions: var(--muted-foreground);
	--tw-prose-code: var(--accent-foreground);
	--tw-prose-pre-code: var(--accent-foreground);
	--tw-prose-pre-bg: var(--card);
	--tw-prose-th-borders: var(--border);
	--tw-prose-td-borders: var(--border);
}

/* D&D Mode Prose Styling */
[data-theme='dnd'] .prose h1,
[data-theme='dnd'] .prose h2,
[data-theme='dnd'] .prose h3 {
	font-family: var(--font-serif);
	color: var(--foreground);
	border-bottom-color: var(--border);
}

/* --- SCROLLBAR --- */
.custom-scrollbar::-webkit-scrollbar {
	width: 6px;
	height: 6px;
}
.custom-scrollbar::-webkit-scrollbar-track {
	background: transparent;
}
.custom-scrollbar::-webkit-scrollbar-thumb {
	background: var(--border);
	border-radius: 99px;
}
.custom-scrollbar::-webkit-scrollbar-thumb:hover {
	background: var(--muted-foreground);
}

/* --- SAFE AREA INSETS --- */
.pt-safe {
	padding-top: env(safe-area-inset-top, 20px);
}
.pb-safe {
	padding-bottom: env(safe-area-inset-bottom, 20px);
}
.pl-safe {
	padding-left: env(safe-area-inset-left, 0px);
}
.pr-safe {
	padding-right: env(safe-area-inset-right, 0px);
}

/* --- COMPREHENSIVE COMPATIBILITY OVERRIDES --- */

/* Background Colors */
.bg-white {
	background-color: var(--card) !important;
}
.bg-gray-50,
.bg-slate-50,
.bg-stone-50,
.bg-zinc-50 {
	background-color: var(--muted) !important;
}
.bg-gray-100,
.bg-slate-100,
.bg-stone-100,
.bg-zinc-100 {
	background-color: var(--muted) !important;
}
.bg-gray-200,
.bg-slate-200,
.bg-stone-200,
.bg-zinc-200 {
	background-color: var(--border) !important;
}

/* Text Colors - Foreground */
.text-gray-900,
.text-slate-900,
.text-stone-900,
.text-zinc-900 {
	color: var(--foreground) !important;
}
.text-gray-800,
.text-slate-800,
.text-stone-800,
.text-zinc-800 {
	color: var(--foreground) !important;
}
.text-gray-700,
.text-slate-700,
.text-stone-700,
.text-zinc-700 {
	color: var(--card-foreground) !important;
}

/* Text Colors - Muted */
.text-gray-600,
.text-slate-600,
.text-stone-600,
.text-zinc-600 {
	color: var(--muted-foreground) !important;
}
.text-gray-500,
.text-slate-500,
.text-stone-500,
.text-zinc-500 {
	color: var(--muted-foreground) !important;
}
.text-gray-400,
.text-slate-400,
.text-stone-400,
.text-zinc-400 {
	color: var(--muted-foreground) !important;
}

/* Border Colors */
.border-gray-200,
.border-slate-200,
.border-stone-200,
.border-zinc-200 {
	border-color: var(--border) !important;
}
.border-gray-300,
.border-slate-300,
.border-stone-300,
.border-zinc-300 {
	border-color: var(--border) !important;
}

/* Divide Colors */
.divide-gray-200,
.divide-slate-200,
.divide-stone-200,
.divide-zinc-200 {
	border-color: var(--border) !important;
}

/* Ring Colors */
.ring-gray-200,
.ring-slate-200,
.ring-stone-200,
.ring-zinc-200 {
	--tw-ring-color: var(--border) !important;
}

/* Opacity Variants */
.bg-black\/5 {
	background-color: color-mix(in srgb, var(--foreground) 5%, transparent) !important;
}
.bg-black\/10 {
	background-color: color-mix(in srgb, var(--foreground) 10%, transparent) !important;
}
.bg-white\/5 {
	background-color: color-mix(in srgb, var(--background) 5%, transparent) !important;
}
.bg-white\/10 {
	background-color: color-mix(in srgb, var(--background) 10%, transparent) !important;
}

/* Hover States */
.hover\:bg-black\/5:hover {
	background-color: color-mix(in srgb, var(--foreground) 5%, transparent) !important;
}
.hover\:bg-black\/10:hover {
	background-color: color-mix(in srgb, var(--foreground) 10%, transparent) !important;
}

/* Special fallback for header background */
.header-bg-fallback {
	background: linear-gradient(to bottom, color-mix(in srgb, var(--primary) 10%, var(--muted)), var(--background));
}

/* Leaflet Map Fixes for Dark Mode AND D&D Mode */
.leaflet-container {
	/* background-color: var(--background) !important; */
	font-family: var(--font-sans) !important;
}

/* Ensure popups use theme colors */
.leaflet-popup-content-wrapper {
	background-color: var(--card) !important;
	color: var(--card-foreground) !important;
	border-radius: 0.5rem !important; /* rounded-lg */
	box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1) !important; /* shadow-lg */
}

.leaflet-popup-tip {
	background-color: var(--card) !important;
}

/* Custom Clean Popup - Removes padding so our internal card fits perfectly */
.custom-popup-clean .leaflet-popup-content {
	margin: 0 !important;
	width: 260px !important;
	line-height: 1.5 !important;
}

.custom-popup-clean .leaflet-popup-content-wrapper {
	padding: 0 !important;
	overflow: hidden;
}

/* Marker Popup Cards */
.marker-popup-card {
	@apply bg-card border-0; /* Remove border since wrapper has shadow */
}

.marker-popup-header {
	@apply bg-muted px-3 py-2 border-b border-border;
}

.marker-popup-category {
	@apply text-xs font-bold uppercase tracking-wider text-muted-foreground;
}

.marker-popup-title {
	@apply font-serif font-bold text-foreground text-sm;
}

.marker-popup-body {
	@apply p-3 text-sm text-muted-foreground;
}

/* FIX: Status Badge Semantic Colors */
.badge-alive {
	@apply border-emerald-600/50 bg-emerald-500/20 text-emerald-700;
}
.badge-dead {
	@apply border-red-600/50 bg-red-500/20 text-red-700;
}

/* Dark Mode Overrides */
[data-theme='dark'] .badge-alive {
	@apply text-emerald-400;
}
[data-theme='dark'] .badge-dead {
	@apply text-red-400;
}

/* Custom Clean Popup - Zero padding for custom cards */
.custom-popup-clean .leaflet-popup-content-wrapper {
	padding: 0 !important;
	overflow: hidden !important;
	background: transparent !important; /* Let the card handle bg */
	border: none !important;
	box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1) !important;
}

.custom-popup-clean .leaflet-popup-content {
	margin: 0 !important;
	width: 300px !important; /* Fixed width for consistency */
	line-height: 1.5 !important;
}

/* Ensure the tip matches the theme card color */
.custom-popup-clean .leaflet-popup-tip {
	background-color: var(--card) !important;
}

--- END OF app\styles\global.css ---

--- FILE: domain\entity\api\entityService.js ---
import { supabase } from '@/shared/api/supabaseClient';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';
import { getCampaigns } from '@/features/campaign/api/campaignService';

// --- HELPER: Extract Session Meta ---
const extractSessionMeta = (session, attributes = []) => {
	let attrs = attributes;
	if (Array.isArray(attrs)) {
		attrs = attrs.reduce((acc, curr) => {
			acc[curr.name] = curr.value;
			return acc;
		}, {});
	}
	attrs = attrs || {};

	const sessionNumber = getAttributeValue(attrs, ['session_number', 'Session', 'session']) || 999;
	const sessionDate = getAttributeValue(attrs, ['session_date', 'Date', 'date']) || '';

	return {
		...session,
		session_number: Number(sessionNumber),
		session_date: sessionDate,
		attributes: attrs,
	};
};

// --- API METHODS ---

export const getSessions = async (campaignId) => {
	const { data: sessions, error } = await supabase
		.from('sessions')
		.select('id, title, narrative')
		.eq('campaign_id', campaignId);

	if (error) throw error;
	if (!sessions.length) return [];

	const sessionIds = sessions.map((s) => s.id);
	const { data: attributes } = await supabase
		.from('attributes')
		.select('entity_id, name, value')
		.in('entity_id', sessionIds);

	const attrMap = new Map();
	(attributes || []).forEach((attr) => {
		if (!attrMap.has(attr.entity_id)) attrMap.set(attr.entity_id, []);
		attrMap.get(attr.entity_id).push(attr);
	});

	const processed = sessions.map((s) => {
		const sAttrs = attrMap.get(s.id) || [];
		const meta = extractSessionMeta(s, sAttrs);

		return {
			id: meta.id,
			name: meta.title,
			type: 'session',
			session_number: meta.session_number,
			session_date: meta.session_date,
			summary: getAttributeValue(meta.attributes, 'Summary') || meta.narrative,
			narrative: meta.narrative,
			attributes: meta.attributes,
		};
	});

	return processed.sort((a, b) => a.session_number - b.session_number);
};

// Generic fetcher
const getCompleteEntities = async (campaignId, type) => {
	const { data, error } = await supabase
		.from('entity_complete_view')
		.select('id, name, type, description, attributes, relationships')
		.eq('campaign_id', campaignId)
		.eq('type', type)
		.order('name');

	if (error) throw error;
	return data;
};

const entityStrategies = {
	session: getSessions,
	quest: getCompleteEntities,
	default: getCompleteEntities,
	campaign: async () => getCampaigns(),
};

export const getEntities = async (campaignId, type) => {
	const strategy = entityStrategies[type] || entityStrategies.default;
	return strategy(campaignId, type);
};

export const getGraphData = async (campaignId) => {
	const { data, error } = await supabase
		.from('entity_complete_view')
		.select('id, name, type, relationships, attributes')
		.eq('campaign_id', campaignId);

	if (error) {
		console.error('Graph Fetch Error:', error);
		return [];
	}
	return data || [];
};

export const getEntityIndex = async (campaignId) => {
	const { data, error } = await supabase
		.from('entity_complete_view')
		.select('id, name, type, attributes, relationships, description')
		.eq('campaign_id', campaignId);

	if (error) return [];
	return data.sort((a, b) => b.name.length - a.name.length);
};

export const getWikiEntry = async (id, type) => {
	if (type === 'session') {
		const { data, error } = await supabase
			.from('sessions')
			.select(`*, events:session_events (*)`)
			.eq('id', id)
			.single();
		if (error) throw error;

		const { data: attributes } = await supabase.from('attributes').select('name, value').eq('entity_id', id);

		const eventIds = (data.events || []).map((e) => e.id);
		let eventRelMap = new Map();

		if (eventIds.length > 0) {
			const { data: rels } = await supabase
				.from('entity_relationships')
				.select(`from_entity_id, target:entities!to_entity_id ( id, name, type )`)
				.in('from_entity_id', eventIds);

			(rels || []).forEach((rel) => {
				if (!eventRelMap.has(rel.from_entity_id)) eventRelMap.set(rel.from_entity_id, []);
				eventRelMap.get(rel.from_entity_id).push({
					entity_id: rel.target.id,
					entity_name: rel.target.name,
					entity_type: rel.target.type,
					type: 'mention',
				});
			});
		}

		const { data: directRels } = await supabase
			.from('entity_relationships')
			.select(`target:entities!to_entity_id ( id, name, type ), relationship_type`)
			.eq('from_entity_id', id);

		const sessionRelationships = (directRels || []).map((rel) => ({
			entity_id: rel.target.id,
			entity_name: rel.target.name,
			entity_type: rel.target.type,
			type: rel.relationship_type,
		}));

		return {
			data,
			type: 'session',
			additional: { attributes, eventRelMap, sessionRelationships },
		};
	}

	// --- STANDARD ENTITY FETCH ---
	const { data, error: entityError } = await supabase.from('entity_complete_view').select('*').eq('id', id).single();
	if (entityError) throw entityError;

	const additional = {};

	// FETCH QUEST OBJECTIVES WITH SESSION DATA
	if (type === 'quest') {
		const { data: objectives, error: objError } = await supabase
			.from('quest_objectives')
			.select('*, session:sessions(id, title)') // Basic join for title
			.eq('quest_id', id)
			.order('order_index', { ascending: true });

		if (objError) console.error('Error fetching objectives:', objError);

		if (objectives && objectives.length > 0) {
			// 2. Fetch Session Numbers (stored as attributes)
			const sessionIds = objectives.map((o) => o.completed_session_id).filter(Boolean);

			if (sessionIds.length > 0) {
				const { data: attrs } = await supabase
					.from('attributes')
					.select('entity_id, value')
					.in('entity_id', sessionIds)
					.or('name.eq.session_number,name.eq.Session');

				const sessionNumMap = new Map();
				(attrs || []).forEach((a) => sessionNumMap.set(a.entity_id, a.value));

				// 3. Attach number to the session object inside the objective
				objectives.forEach((obj) => {
					if (obj.session) {
						obj.session.session_number = sessionNumMap.get(obj.session.id);
					}
				});
			}
		}

		additional.objectives = objectives || [];
	}

	// 2. ENCOUNTER ACTIONS (UPDATED)
	if (type === 'encounter') {
		// Step A: Fetch Actions with basic Actor/Target info
		const { data: actions, error: actError } = await supabase
			.from('encounter_actions')
			.select(
				`
                *,
                actor:entities!actor_entity_id (id, name, type),
                target:entities!target_entity_id (id, name, type)
            `
			)
			.eq('encounter_id', id)
			.order('round_number', { ascending: true })
			.order('action_order', { ascending: true });

		if (actError) console.error('Error fetching encounter actions:', actError);

		if (actions && actions.length > 0) {
			// Step B: Get ALL unique Entity IDs (Actors AND Targets)
			const entityIds = new Set();
			actions.forEach((a) => {
				if (a.actor?.id) entityIds.add(a.actor.id);
				if (a.target?.id) entityIds.add(a.target.id);
			});

			// Step C: Fetch attributes for these entities
			let entityAttrs = [];
			if (entityIds.size > 0) {
				const { data: attrs } = await supabase
					.from('attributes')
					.select('entity_id, name, value')
					.in('entity_id', Array.from(entityIds));
				entityAttrs = attrs || [];
			}

			// Step D: Map attributes
			const attrMap = new Map();
			entityAttrs.forEach((attr) => {
				if (!attrMap.has(attr.entity_id)) attrMap.set(attr.entity_id, []);
				attrMap.get(attr.entity_id).push(attr);
			});

			// Step E: Attach to action objects
			actions.forEach((action) => {
				if (action.actor?.id) {
					action.actor.attributes = attrMap.get(action.actor.id) || [];
				}
				if (action.target?.id) {
					action.target.attributes = attrMap.get(action.target.id) || [];
				}
			});
		}

		additional.encounterActions = actions || [];
	}

	// RESOLVE SESSION NUMBERS FOR EVENTS
	let events = data.events;
	if (events && typeof events === 'object' && !Array.isArray(events)) {
		events = Object.values(events).flat();
	}

	if (events && Array.isArray(events) && events.length > 0) {
		const sessionIds = [...new Set(events.map((e) => e.session_id).filter(Boolean))];
		if (sessionIds.length > 0) {
			const { data: sessions } = await supabase.from('sessions').select('id').in('id', sessionIds);

			const { data: attrs } = await supabase
				.from('attributes')
				.select('entity_id, name, value')
				.in('entity_id', sessionIds)
				.or('name.eq.session_number,name.eq.Session');

			const sessionMap = new Map();
			(sessions || []).forEach((s) => {
				const sAttr = (attrs || []).find((a) => a.entity_id === s.id);
				const num = sAttr ? parseInt(sAttr.value) : null;
				sessionMap.set(s.id, num);
			});

			additional.sessionMap = sessionMap;
		}
	}

	return { data, type, additional };
};

export const getTooltipData = async (id, type) => {
	if (type === 'session') {
		const { data } = await supabase.from('sessions').select('title, narrative').eq('id', id).single();
		const { data: attributes } = await supabase.from('attributes').select('name, value').eq('entity_id', id);
		return {
			name: data.title,
			type: 'session',
			description: data.narrative,
			attributes,
		};
	}

	const { data, error } = await supabase
		.from('entity_complete_view')
		.select('name, type, description, attributes')
		.eq('id', id)
		.single();
	if (error) throw error;
	return data;
};

--- END OF domain\entity\api\entityService.js ---

--- FILE: domain\entity\components\EntityBadge.jsx ---
import { clsx } from 'clsx';
import { getEntityLabel } from '@/domain/entity/config/entityTypes';
import { getEntityStyles } from '@/domain/entity/config/entityStyles';

/**
 * EntityBadge Component
 * Displays a colored type badge for an entity
 *
 * @param {string} type - Entity type
 * @param {string} label - Optional custom label (defaults to type label)
 * @param {string} size - Badge size: 'sm', 'md', 'lg' (default 'md')
 * @param {string} variant - Style variant: 'solid', 'outline', 'subtle' (default 'solid')
 * @param {string} className - Additional CSS classes
 */
export default function EntityBadge({ type, label = null, size = 'md', variant = 'solid', className = '', ...props }) {
	const styles = getEntityStyles(type);
	const displayLabel = label || getEntityLabel(type);

	const sizeClasses = {
		sm: 'text-[9px] px-1.5 py-0.5',
		md: 'text-[10px] px-2 py-0.5',
		lg: 'text-xs px-2.5 py-1',
	};

	const variantClasses = {
		solid: clsx(styles.bg, styles.text, styles.border, 'border'),
		outline: clsx('bg-transparent', styles.text, styles.border, 'border'),
		subtle: clsx(styles.bg, styles.text, 'border-transparent border'),
	};

	return (
		<span
			className={clsx(
				'inline-flex items-center font-bold uppercase tracking-wider rounded shrink-0',
				sizeClasses[size],
				variantClasses[variant],
				className
			)}
			{...props}>
			{displayLabel}
		</span>
	);
}

--- END OF domain\entity\components\EntityBadge.jsx ---

--- FILE: domain\entity\components\EntityIcon.jsx ---
import { clsx } from 'clsx';
import { getEntityIcon } from '@/domain/entity/config/entityIcons';
import { getEntityStyles } from '@/domain/entity/config/entityStyles';

/**
 * EntityIcon Component
 * Renders an entity icon with optional custom image override
 *
 * @param {string} type - Entity type
 * @param {string} customIconUrl - Optional custom icon URL
 * @param {number} size - Icon size in pixels (default 16)
 * @param {string} className - Additional CSS classes
 * @param {boolean} showBackground - Show colored background (default false)
 * @param {boolean} inline - Use span instead of div for inline contexts (default false)
 */
export default function EntityIcon({
	type,
	customIconUrl = null,
	size = 16,
	className = '',
	showBackground = false,
	inline = false,
	...props
}) {
	const Icon = getEntityIcon(type);
	const styles = getEntityStyles(type);

	// Choose container element (span for inline, div for block)
	const Container = inline ? 'span' : 'div';

	// If custom icon provided, render image
	if (customIconUrl) {
		return (
			<Container
				className={clsx(
					'inline-flex items-center justify-center overflow-hidden',
					showBackground && clsx('rounded-lg border', styles.bg, styles.border),
					className
				)}
				style={{ width: size, height: size }}
				{...props}>
				<img
					src={customIconUrl}
					alt=''
					className='w-full h-full object-cover'
					onError={(e) => {
						// Fallback to icon if image fails
						e.target.style.display = 'none';
						e.target.parentElement.classList.add('fallback-icon');
					}}
				/>
			</Container>
		);
	}

	// Default icon rendering
	if (showBackground) {
		return (
			<Container
				className={clsx(
					'inline-flex items-center justify-center rounded-lg border p-1.5',
					styles.bg,
					styles.border,
					styles.text,
					className
				)}
				{...props}>
				<Icon size={size} strokeWidth={2} />
			</Container>
		);
	}

	return <Icon size={size} className={clsx(styles.text, className)} strokeWidth={2} {...props} />;
}

--- END OF domain\entity\components\EntityIcon.jsx ---

--- FILE: domain\entity\components\EntityLink.jsx ---
import { useNavigate } from 'react-router-dom';
import { useRef, useCallback } from 'react'; // ADDED
import { clsx } from 'clsx';
import { useTooltip } from '@/features/smart-tooltip/TooltipContext';
import { getEntityStyles } from '@/domain/entity/config/entityStyles';
import EntityIcon from './EntityIcon';

export default function EntityLink({
	id,
	type,
	children,
	customIconUrl = null,
	showIcon = true,
	className = '',
	inline = false,
	...props
}) {
	const navigate = useNavigate();
	const { openTooltip, closeTooltip } = useTooltip();
	const styles = getEntityStyles(type);

	// --- IMPROVEMENT #4: Long Press Logic ---
	const pressTimer = useRef(null);
	const isLongPress = useRef(false);

	const handleTouchStart = (e) => {
		isLongPress.current = false;
		pressTimer.current = setTimeout(() => {
			isLongPress.current = true;
			// Open Tooltip on long press position
			openTooltip(e, id, type, true);
		}, 500); // 500ms threshold
	};

	const handleTouchEnd = (e) => {
		if (pressTimer.current) {
			clearTimeout(pressTimer.current);
		}
		// If it wasn't a long press, treat as click (Navigate)
		if (!isLongPress.current) {
			navigate(`/wiki/${type}/${id}`);
			closeTooltip();
		}
		// Prevent ghost clicks if it was a long press
		if (isLongPress.current && e.cancelable) {
			e.preventDefault();
		}
	};

	const handleTouchMove = () => {
		// Cancel everything if user scrolls
		if (pressTimer.current) {
			clearTimeout(pressTimer.current);
			isLongPress.current = true; // Treat as "handled" so we don't navigate
		}
	};
	// ----------------------------------------

	const handleMouseEnter = (e) => {
		// Desktop only
		if (window.matchMedia('(hover: hover)').matches) {
			openTooltip(e, id, type);
		}
	};

	const handleClick = (e) => {
		e.preventDefault();
		// Desktop click handling (Touch handled via TouchEnd)
		if (window.matchMedia('(hover: hover)').matches) {
			navigate(`/wiki/${type}/${id}`);
			closeTooltip();
		}
	};

	const commonProps = {
		href: `/wiki/${type}/${id}`,
		onClick: handleClick,
		onMouseEnter: handleMouseEnter,
		onMouseLeave: closeTooltip,
		// Mobile Events
		onTouchStart: handleTouchStart,
		onTouchEnd: handleTouchEnd,
		onTouchMove: handleTouchMove,
		...props,
	};

	if (inline) {
		return (
			<a
				className={clsx(
					'inline-flex items-center gap-1.5 font-semibold no-underline transition-colors',
					'border-b border-dashed border-transparent hover:border-current cursor-pointer align-middle',
					styles.text,
					styles.hover,
					className
				)}
				{...commonProps}>
				{showIcon && (
					<EntityIcon
						type={type}
						customIconUrl={customIconUrl}
						size={14}
						inline={true}
						className='self-center rounded-full'
					/>
				)}
				{children}
			</a>
		);
	}

	return (
		<a
			className={clsx(
				'flex items-center gap-2 px-3 py-2 rounded-lg transition-all cursor-pointer',
				'hover:shadow-sm',
				styles.bg,
				styles.hover,
				styles.border,
				'border',
				className
			)}
			{...commonProps}>
			{showIcon && <EntityIcon type={type} customIconUrl={customIconUrl} size={18} inline={false} />}
			<span className={clsx('font-semibold text-sm', styles.text)}>{children}</span>
		</a>
	);
}

--- END OF domain\entity\components\EntityLink.jsx ---

--- FILE: domain\entity\components\EntityStatusIcon.jsx ---
import { clsx } from 'clsx';
import { getStatusIcon } from '@/domain/entity/utils/statusUtils';

/**
 * EntityStatusIcon Component
 * Smart status indicator based on entity type and status/affinity
 *
 * @param {Object} entity - Entity object with type and status/affinity
 * @param {number} size - Icon size (default 12)
 * @param {string} className - Additional CSS classes
 */
export default function EntityStatusIcon({ entity, size = 12, className = '', ...props }) {
	if (!entity) return null;

	// Determine which status to show (affinity takes priority for NPCs/factions)
	const statusValue = entity.affinity || entity.status;
	if (!statusValue || statusValue === 'unknown') return null;

	const { Icon, className: statusClass } = getStatusIcon(statusValue, entity.type);

	return <Icon size={size} className={clsx(statusClass, className)} strokeWidth={2.5} {...props} />;
}

/**
 * EntityStatusBadge Component
 * Status indicator with text label
 *
 * @param {Object} entity - Entity object
 * @param {string} className - Additional CSS classes
 */
export function EntityStatusBadge({ entity, className = '', ...props }) {
	if (!entity) return null;

	const statusValue = entity.affinity || entity.status;
	if (!statusValue || statusValue === 'unknown') return null;

	const { Icon, className: statusClass } = getStatusIcon(statusValue, entity.type);

	return (
		<span
			className={clsx('inline-flex items-center gap-1.5 text-xs font-semibold px-2 py-1 rounded-md border', className)}
			{...props}>
			<Icon size={12} className={statusClass} strokeWidth={2.5} />
			<span className='capitalize'>{statusValue}</span>
		</span>
	);
}

--- END OF domain\entity\components\EntityStatusIcon.jsx ---

--- FILE: domain\entity\config\entityColors.js ---
/**
 * Entity Color Palettes
 * Hex colors for each entity type
 */

import { ENTITY_TYPES } from './entityTypes';

/**
 * Primary color for each entity type (hex)
 */
export const ENTITY_COLORS = {
	[ENTITY_TYPES.SESSION]: '#64748b', // slate-500
	[ENTITY_TYPES.CHARACTER]: '#ef4444', // red-500
	[ENTITY_TYPES.NPC]: '#d97706', // amber-600
	[ENTITY_TYPES.LOCATION]: '#10b981', // emerald-500
	[ENTITY_TYPES.QUEST]: '#3b82f6', // blue-500
	[ENTITY_TYPES.FACTION]: '#a855f7', // purple-500
	[ENTITY_TYPES.ENCOUNTER]: '#f97316', // orange-500
	[ENTITY_TYPES.DEFAULT]: '#6b7280', // gray-500
};

/**
 * Get primary color for entity type
 * @param {string} type - Entity type
 * @returns {string} Hex color
 */
export const getEntityColor = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	return ENTITY_COLORS[normalized] || ENTITY_COLORS[ENTITY_TYPES.DEFAULT];
};

/**
 * Extended color palette for each type (for future use)
 * Includes lighter/darker shades
 */
export const ENTITY_COLOR_PALETTES = {
	[ENTITY_TYPES.SESSION]: {
		50: '#f8fafc',
		100: '#f1f5f9',
		500: '#64748b',
		700: '#334155',
		900: '#0f172a',
	},
	[ENTITY_TYPES.CHARACTER]: {
		50: '#fef2f2',
		100: '#fee2e2',
		500: '#ef4444',
		700: '#b91c1c',
		900: '#7f1d1d',
	},
	[ENTITY_TYPES.NPC]: {
		50: '#fffbeb',
		100: '#fef3c7',
		500: '#d97706',
		700: '#a16207',
		900: '#78350f',
	},
	[ENTITY_TYPES.LOCATION]: {
		50: '#ecfdf5',
		100: '#d1fae5',
		500: '#10b981',
		700: '#047857',
		900: '#064e3b',
	},
	[ENTITY_TYPES.QUEST]: {
		50: '#eff6ff',
		100: '#dbeafe',
		500: '#3b82f6',
		700: '#1d4ed8',
		900: '#1e3a8a',
	},
	[ENTITY_TYPES.FACTION]: {
		50: '#faf5ff',
		100: '#f3e8ff',
		500: '#a855f7',
		700: '#7e22ce',
		900: '#581c87',
	},
	[ENTITY_TYPES.ENCOUNTER]: {
		50: '#fff7ed',
		100: '#ffedd5',
		500: '#f97316',
		700: '#c2410c',
		900: '#7c2d12',
	},
	[ENTITY_TYPES.DEFAULT]: {
		50: '#f9fafb',
		100: '#f3f4f6',
		500: '#6b7280',
		700: '#374151',
		900: '#111827',
	},
};

/**
 * Get color palette for entity type
 * @param {string} type - Entity type
 * @returns {Object} Color palette
 */
export const getEntityPalette = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	return ENTITY_COLOR_PALETTES[normalized] || ENTITY_COLOR_PALETTES[ENTITY_TYPES.DEFAULT];
};

--- END OF domain\entity\config\entityColors.js ---

--- FILE: domain\entity\config\entityConfig.js ---
/**
 * Entity Configuration Orchestrator
 * Combines all entity config modules into a unified API
 * This replaces the old monolithic entityConfig.jsx
 */

import { ENTITY_TYPES, getEntityLabel } from './entityTypes';
import { getEntityIcon } from './entityIcons';
import { getEntityColor, getEntityPalette } from './entityColors';
import { getEntityStyles, getEntityPreset, buildEntityClassName } from './entityStyles';

/**
 * Get complete configuration for an entity type
 * @param {string} type - Entity type
 * @returns {Object} Complete entity config
 */
export const getEntityConfig = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;

	return {
		type: normalized,
		label: getEntityLabel(normalized),
		labelPlural: getEntityLabel(normalized, true),
		icon: getEntityIcon(normalized),
		color: getEntityColor(normalized),
		palette: getEntityPalette(normalized),
		tailwind: getEntityStyles(normalized),
	};
};

/**
 * LEGACY EXPORT: Full config map for backwards compatibility
 * TODO: Gradually migrate consumers to use getEntityConfig() instead
 */
export const ENTITY_CONFIG = Object.values(ENTITY_TYPES).reduce((acc, type) => {
	acc[type] = getEntityConfig(type);
	return acc;
}, {});

// Re-export everything for convenience
export { ENTITY_TYPES, getEntityLabel } from './entityTypes';
export { getEntityIcon } from './entityIcons';
export { getEntityColor, getEntityPalette } from './entityColors';
export { getEntityStyles, getEntityPreset, buildEntityClassName } from './entityStyles';

--- END OF domain\entity\config\entityConfig.js ---

--- FILE: domain\entity\config\entityIcons.js ---
import {
	User,
	MapPin,
	Scroll,
	Sword,
	Flag,
	Crown,
	BookOpen,
	Calendar,
	Trees,
	Castle,
	Ship,
	Landmark,
	Globe,
	Home,
	Mountain,
} from 'lucide-react';
import { ENTITY_TYPES } from './entityTypes';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

export const ENTITY_ICONS = {
	[ENTITY_TYPES.SESSION]: Calendar,
	[ENTITY_TYPES.CHARACTER]: User,
	[ENTITY_TYPES.NPC]: Crown,
	[ENTITY_TYPES.LOCATION]: MapPin,
	[ENTITY_TYPES.QUEST]: Scroll,
	[ENTITY_TYPES.FACTION]: Flag,
	[ENTITY_TYPES.ENCOUNTER]: Sword,
	[ENTITY_TYPES.DEFAULT]: BookOpen,
};

// Location specific mappings
const LOCATION_TYPE_ICONS = {
	building: Home,
	ship: Ship,
	landmark: Landmark,
	dungeon: Mountain,
	cave: Mountain,
	region: MapPin,
	city: Castle,
	forest: Trees,
	realm: Globe,
};

export const getEntityIcon = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	return ENTITY_ICONS[normalized] || ENTITY_ICONS[ENTITY_TYPES.DEFAULT];
};

/**
 * Advanced resolution that looks at attributes for finer detail
 */
export const resolveEntityIcon = (entity) => {
	const type = entity.type?.toLowerCase();

	if (type === 'location') {
		const locType = getAttributeValue(entity.attributes, 'type')?.toLowerCase();
		return LOCATION_TYPE_ICONS[locType] || ENTITY_ICONS.location;
	}

	return getEntityIcon(type);
};

--- END OF domain\entity\config\entityIcons.js ---

--- FILE: domain\entity\config\entityStyles.js ---
import { ENTITY_TYPES } from './entityTypes';

/**
 * Tailwind class maps
 * CHANGED: Replaced 'slate' with 'muted-foreground' or 'foreground' to respect the active theme.
 */
const ENTITY_TAILWIND_CLASSES = {
	[ENTITY_TYPES.SESSION]: {
		text: 'text-[var(--entity-session,theme(colors.slate.500))] font-medium',
		bg: 'bg-muted/50',
		border: 'border-border',
		hover: 'hover:bg-muted',
	},
	[ENTITY_TYPES.CHARACTER]: {
		text: 'text-[var(--entity-character,theme(colors.red.500))]',
		bg: 'bg-red-500/10',
		border: 'border-red-500/20',
		hover: 'hover:bg-red-500/10',
	},
	[ENTITY_TYPES.NPC]: {
		text: 'text-[var(--entity-npc,theme(colors.amber.500))]',
		bg: 'bg-amber-500/10',
		border: 'border-amber-500/20',
		hover: 'hover:bg-amber-500/10',
	},
	[ENTITY_TYPES.LOCATION]: {
		text: 'text-[var(--entity-location,theme(colors.emerald.500))]', // Will use moss green on D&D theme
		bg: 'bg-emerald-500/10',
		border: 'border-emerald-500/20',
		hover: 'hover:bg-emerald-500/10',
	},
	[ENTITY_TYPES.QUEST]: {
		text: 'text-[var(--entity-quest,theme(colors.blue.500))]',
		bg: 'bg-blue-500/10',
		border: 'border-blue-500/20',
		hover: 'hover:bg-blue-500/10',
	},
	[ENTITY_TYPES.FACTION]: {
		text: 'text-[var(--entity-faction,theme(colors.purple.500))]',
		bg: 'bg-purple-500/10',
		border: 'border-purple-500/20',
		hover: 'hover:bg-purple-500/10',
	},
	[ENTITY_TYPES.ENCOUNTER]: {
		text: 'text-[var(--entity-encounter,theme(colors.orange.500))]',
		bg: 'bg-orange-500/10',
		border: 'border-orange-500/20',
		hover: 'hover:bg-orange-500/10',
	},
	[ENTITY_TYPES.DEFAULT]: {
		text: 'text-muted-foreground',
		bg: 'bg-muted',
		border: 'border-border',
		hover: 'hover:bg-muted/80',
	},
};

export const getEntityStyles = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	return ENTITY_TAILWIND_CLASSES[normalized] || ENTITY_TAILWIND_CLASSES[ENTITY_TYPES.DEFAULT];
};

export const buildEntityClassName = (type, variants = [], additional = '') => {
	const styles = getEntityStyles(type);
	const variantList = Array.isArray(variants) ? variants : [variants];
	const classes = variantList
		.map((variant) => styles[variant])
		.filter(Boolean)
		.join(' ');
	return additional ? `${classes} ${additional}` : classes;
};

// Priority Badges - Using semantic opacity for better dark/light compatibility
export const getPriorityStyles = (priority) => {
	const p = priority?.toLowerCase() || '';
	if (p.includes('high') || p.includes('urgent') || p.includes('critical')) {
		return 'border-orange-500/30 text-orange-700 dark:text-orange-400 bg-orange-500/10';
	}
	if (p.includes('medium') || p.includes('normal')) {
		return 'border-blue-500/30 text-blue-700 dark:text-blue-400 bg-blue-500/10';
	}
	if (p.includes('low')) {
		return 'border-border text-muted-foreground bg-muted/50';
	}
	return 'border-border text-muted-foreground bg-muted/30';
};

export const ENTITY_CLASS_PRESETS = {
	iconBadge: (type) => {
		const styles = getEntityStyles(type);
		return `${styles.bg} ${styles.border} ${styles.text} rounded-lg p-2 border`;
	},
	typeBadge: (type) => {
		const styles = getEntityStyles(type);
		return `${styles.bg} ${styles.text} ${styles.border} text-xs font-bold uppercase tracking-wider px-2 py-0.5 rounded border`;
	},
	card: (type) => {
		const styles = getEntityStyles(type);
		// Force bg-card to ensure cards are readable on all themes
		return `bg-card border-border border rounded-lg p-4 ${styles.hover} transition-colors`;
	},
	link: (type) => {
		const styles = getEntityStyles(type);
		return `${styles.text} transition-colors font-semibold hover:underline`;
	},
};

export const getEntityPreset = (preset, type) => {
	const presetFn = ENTITY_CLASS_PRESETS[preset];
	return presetFn ? presetFn(type) : '';
};

--- END OF domain\entity\config\entityStyles.js ---

--- FILE: domain\entity\config\entityTypes.js ---
/**
 * Entity Type Definitions
 * Central source of truth for entity types
 */

/**
 * All valid entity types in the system
 */
export const ENTITY_TYPES = {
	SESSION: 'session',
	CHARACTER: 'character',
	NPC: 'npc',
	LOCATION: 'location',
	QUEST: 'quest',
	FACTION: 'faction',
	ENCOUNTER: 'encounter',
	DEFAULT: 'default',
};

/**
 * Entity type labels (for display)
 */
export const ENTITY_LABELS = {
	[ENTITY_TYPES.SESSION]: 'Session',
	[ENTITY_TYPES.CHARACTER]: 'Character',
	[ENTITY_TYPES.NPC]: 'NPC',
	[ENTITY_TYPES.LOCATION]: 'Location',
	[ENTITY_TYPES.QUEST]: 'Quest',
	[ENTITY_TYPES.FACTION]: 'Faction',
	[ENTITY_TYPES.ENCOUNTER]: 'Encounter',
	[ENTITY_TYPES.DEFAULT]: 'Entity',
};

/**
 * Pluralized entity labels (for navigation, headers)
 */
export const ENTITY_LABELS_PLURAL = {
	[ENTITY_TYPES.SESSION]: 'Sessions',
	[ENTITY_TYPES.CHARACTER]: 'Characters',
	[ENTITY_TYPES.NPC]: 'NPCs',
	[ENTITY_TYPES.LOCATION]: 'Locations',
	[ENTITY_TYPES.QUEST]: 'Quests',
	[ENTITY_TYPES.FACTION]: 'Factions',
	[ENTITY_TYPES.ENCOUNTER]: 'Encounters',
	[ENTITY_TYPES.DEFAULT]: 'Entities',
};

/**
 * Get label for entity type
 * @param {string} type - Entity type
 * @param {boolean} plural - Return plural form
 * @returns {string}
 */
export const getEntityLabel = (type, plural = false) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	const labels = plural ? ENTITY_LABELS_PLURAL : ENTITY_LABELS;
	return labels[normalized] || labels[ENTITY_TYPES.DEFAULT];
};

--- END OF domain\entity\config\entityTypes.js ---

--- FILE: domain\entity\utils\attributeParser.js ---
/**
 * Attribute Parsing Utilities
 * Safe parsing and extraction of entity attributes
 */

/**
 * Parse attributes safely from JSON string, Object, or DB Row Array
 * @param {string|Object|Array} attrs - Raw attributes
 * @returns {Object} Parsed attributes object { key: value }
 */
export const parseAttributes = (attrs) => {
	if (!attrs) return {};

	// 1. Handle JSON String
	if (typeof attrs === 'string') {
		try {
			return JSON.parse(attrs);
		} catch {
			console.warn('Failed to parse attributes string:', attrs);
			return {};
		}
	}

	// 2. Handle DB Row Array: [{ name: 'icon', value: '...' }, ...]
	// This is common when joining tables (e.g. encounter_actions -> actor -> attributes)
	if (Array.isArray(attrs)) {
		// Check if it looks like a Name/Value pair list
		if (attrs.length > 0 && 'name' in attrs[0] && 'value' in attrs[0]) {
			return attrs.reduce((acc, curr) => {
				if (curr.name) acc[curr.name] = curr.value;
				return acc;
			}, {});
		}
		// Otherwise return as-is (might be a simple list attribute value)
		return {};
	}

	// 3. Already an Object
	return attrs;
};

// ... (Keep getAttributeValue and rest of file exactly as is) ...
export const getAttributeValue = (attributes, keys) => {
	if (!attributes) return null;

	// Normalize keys to array
	const keyList = Array.isArray(keys) ? keys : [keys];

	for (const key of keyList) {
		// Try exact match
		let val = attributes[key];

		// Try lowercase match
		if (!val) {
			val = attributes[key.toLowerCase()];
		}

		// Try capitalized match
		if (!val) {
			val = attributes[key.charAt(0).toUpperCase() + key.slice(1)];
		}

		if (!val) continue;

		// Unwrap nested structures
		if (typeof val === 'string') return val;
		if (Array.isArray(val) && val[0]?.value) return val[0].value;
		if (Array.isArray(val) && val[0]) return String(val[0]);
		if (typeof val === 'object' && val.value) return val.value;

		// Fallback: stringify
		return String(val);
	}

	return null;
};

// ... (Keep rest of file) ...
export const parseAttributeValue = (val, key) => {
	if (val === null || val === undefined) return null;

	// 1. Already an array - clean it
	if (Array.isArray(val)) {
		return val.map((item) => (typeof item === 'object' && item.value ? item.value : item));
	}

	// 2. Check if this should be a list based on key name
	const listKeys = ['feature', 'features', 'traits', 'inventory', 'loot', 'spells'];
	if (typeof val === 'string' && listKeys.includes(key?.toLowerCase())) {
		return val
			.split(',')
			.map((s) => s.trim())
			.filter(Boolean);
	}

	// 3. Unwrap objects
	if (typeof val === 'object' && val.value) {
		return val.value;
	}

	// 4. Return as string
	return String(val);
};

export const parseAbilityScores = (val) => {
	if (!val || typeof val !== 'string') return [];

	return val.split(',').map((s) => {
		const parts = s.trim().split(' ');
		const name = parts[0];
		const score = parts.find((p) => /^\d+$/.test(p)) || '';
		const mod = parts.find((p) => p.includes('('))?.replace(/[()]/g, '') || '';

		return { name, score, mod };
	});
};

export const parseTagList = (val) => {
	if (!val) return [];
	if (Array.isArray(val)) return val.map(String);

	return String(val)
		.split(',')
		.map((s) => s.trim())
		.filter(Boolean);
};

export const isIgnoredAttribute = (key) => {
	const ignoredKeys = [
		'image',
		'portrait',
		'icon',
		'token',
		'session',
		'date',
		'summary',
		'background_image',
		'background',
		'is_active',
		'map_image',
		'map_markers',
	];

	return ignoredKeys.includes(key.toLowerCase());
};

export const isNarrativeAttribute = (key) => {
	const narrativeKeys = [
		'background',
		'personality',
		'history',
		'bio',
		'biography',
		'goals',
		'ideals',
		'bonds',
		'flaws',
		'notes',
		'gm notes',
		'description',
		'appearance',
		'tactics',
		'narrative',
	];

	return narrativeKeys.includes(key.toLowerCase());
};

export const isListAttribute = (key) => {
	const listKeys = ['feature', 'features', 'traits', 'inventory', 'loot', 'spells'];
	return listKeys.includes(key.toLowerCase());
};

export const getAttributeDisplayType = (key, value) => {
	const normalizedKey = key.toLowerCase();

	// Special widgets
	if (['abilities', 'stats'].includes(normalizedKey)) {
		return 'stat-grid';
	}

	if (['ability score', 'saving throw', 'saves', 'skills', 'languages', 'proficiencies'].includes(normalizedKey)) {
		return 'tags';
	}

	// Force list display
	if (isListAttribute(key) && Array.isArray(value)) {
		return 'list';
	}

	// Narrative text
	if (isNarrativeAttribute(key)) {
		return 'narrative';
	}

	// Long text becomes narrative
	if (typeof value === 'string' && value.length > 100) {
		return 'narrative';
	}

	// Default
	return 'text';
};

--- END OF domain\entity\utils\attributeParser.js ---

--- FILE: domain\entity\utils\entityUtils.js ---
/**
 * Entity Type Utilities
 * Pure functions for entity type checking and normalization
 */

/**
 * Normalize entity type string
 * @param {string} type - Raw type string
 * @returns {string} Normalized type
 */
export const normalizeEntityType = (type) => {
	if (!type) return 'default';
	const normalized = type.toLowerCase().trim();
	// Handle plurals
	return normalized === 'sessions' ? 'session' : normalized;
};

/**
 * Check if entity type is a specific value
 * @param {Object} entity - Entity object
 * @param {string} type - Type to check
 * @returns {boolean}
 */
export const isEntityType = (entity, type) => {
	return normalizeEntityType(entity?.type) === normalizeEntityType(type);
};

/**
 * Check if entity is a session
 */
export const isSession = (entity) => isEntityType(entity, 'session');

/**
 * Check if entity is a quest
 */
export const isQuest = (entity) => isEntityType(entity, 'quest');

/**
 * Check if entity is an NPC
 */
export const isNPC = (entity) => isEntityType(entity, 'npc');

/**
 * Check if entity is a location
 */
export const isLocation = (entity) => isEntityType(entity, 'location');

/**
 * Check if entity type should show status icons
 * @param {string} type - Entity type
 * @returns {boolean}
 */
export const shouldShowStatus = (type) => {
	const normalized = normalizeEntityType(type);
	return ['npc', 'faction', 'quest'].includes(normalized);
};

/**
 * Get entity display name
 * Handles different name fields across entity types
 * @param {Object} entity - Entity object
 * @returns {string}
 */
export const getEntityName = (entity) => {
	if (!entity) return 'Unknown';

	// Sessions use 'title'
	if (isSession(entity)) {
		return entity.title || entity.name || 'Untitled Session';
	}

	// Quests use 'title'
	if (isQuest(entity)) {
		return entity.title || entity.name || 'Untitled Quest';
	}

	// Everyone else uses 'name'
	return entity.name || 'Unnamed';
};

/**
 * Get entity description
 * Handles different description fields
 * @param {Object} entity - Entity object
 * @returns {string|null}
 */
export const getEntityDescription = (entity) => {
	if (!entity) return null;

	// Try description first
	if (entity.description) return entity.description;

	// Sessions might use summary
	if (isSession(entity)) {
		return entity?.summary || entity.narrative || null;
	}

	// Characters might use background
	if (isEntityType(entity, 'character')) {
		return entity.background || entity.short_description || null;
	}

	return null;
};

/**
 * Get entity icon initial (first letter)
 * @param {Object} entity - Entity object
 * @returns {string}
 */
export const getEntityInitial = (entity) => {
	const name = getEntityName(entity);
	return (name[0] || 'E').toUpperCase();
};

/**
 * Check if entity is marked as dead/inactive
 * @param {Object} entity - Entity object
 * @returns {boolean}
 */
export const isEntityDead = (entity) => {
	const status = entity.status?.toLowerCase();
	return status === 'dead' || status === 'deceased' || status === 'inactive';
};

/**
 * Check if entity/quest is completed
 * @param {Object} entity - Entity object
 * @returns {boolean}
 */
export const isEntityCompleted = (entity) => {
	const status = entity.status?.toLowerCase();
	return ['completed', 'finished', 'done', 'success'].some((k) => status?.includes(k));
};

/**
 * Check if entity/quest has failed
 * @param {Object} entity - Entity object
 * @returns {boolean}
 */
export const isEntityFailed = (entity) => {
	const status = entity.status?.toLowerCase();
	return ['failed', 'failure', 'abandoned'].some((k) => status?.includes(k));
};

/**
 * Determine the parent ID of an entity based on its relationships.
 * Prioritizes explicit parent relationships, then location containers.
 * @param {Object} entity - Entity object with relationships array
 * @returns {string|null} ID of the parent entity
 */
export const getParentId = (entity) => {
	const relationships = entity.relationships;
	if (!relationships || !Array.isArray(relationships)) return null;

	// 1. Check for explicit parent (Location hierarchy: Location -> Parent Location)
	const parentRel = relationships.find(
		(r) =>
			(r.type === 'parent_location' || r.type === 'parent') && (r.direction === 'outgoing' || r.direction === undefined)
	);
	if (parentRel) return parentRel.entity_id;

	// 2. Check for location link (NPC hierarchy: NPC -> Location)
	if (entity.type === 'npc' || entity.type === 'encounter') {
		// Get ALL relationships to locations
		const locationRels = relationships.filter((r) => r.entity_type === 'location');

		if (locationRels.length > 0) {
			// Priority 1: Look for specific semantic types
			const primary = locationRels.find((r) =>
				['location', 'located_in', 'base', 'home', 'residence', 'origin', 'occurred_at'].includes(r.type?.toLowerCase())
			);

			// Priority 2: Fallback to the first location found (e.g. generic 'related')
			return primary ? primary.entity_id : locationRels[0].entity_id;
		}
	}

	return null;
};

--- END OF domain\entity\utils\entityUtils.js ---

--- FILE: domain\entity\utils\statusUtils.js ---
import { Sword, Shield, Circle, HelpCircle, CheckCircle2, XCircle, Clock } from 'lucide-react';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

/**
 * Rank definitions for sorting.
 * Lower number = Higher priority in lists.
 */
const AFFINITY_RANKS = {
	// Rank 1: Allies
	ally: 1,
	allies: 1,
	friend: 1,
	friendly: 1,
	helpful: 1,
	allied: 1,
	alliance: 1,
	aligned: 1,
	// Rank 2: Neutral
	neutral: 2,
	indifferent: 2,
	unknown: 2, // 'Unknown' faction status often implies neutral
	// Rank 3: Enemies
	enemy: 3,
	enemies: 3,
	hostile: 3,
	rival: 3,
	villain: 3,
	threat: 3,
	// Rank 99: Fallback
	other: 99,
};

/**
 * Calculate a numeric rank for an entity based on status/affinity string.
 * Used for sorting: Allies -> Neutral -> Enemies -> Unknown
 *
 * @param {string} statusOrAffinity
 * @returns {number} 1, 2, 3, or 99
 */
export const getAffinityRank = (statusOrAffinity) => {
	const key = (statusOrAffinity || '').toLowerCase();

	// Check for exact matches or substring matches
	for (const [term, rank] of Object.entries(AFFINITY_RANKS)) {
		if (key.includes(term)) return rank;
	}

	return 99;
};

/**
 * Get status icon based on entity type and status
 */
export const getStatusIcon = (status, type) => {
	const s = status?.toLowerCase() || 'unknown';

	// Quest-specific icons
	if (type === 'quest') {
		if (['active', 'in progress', 'started'].some((k) => s.includes(k))) {
			return { Icon: Circle, className: 'text-amber-500 fill-amber-500/20' };
		}
		if (['completed', 'finished', 'done', 'success'].some((k) => s.includes(k))) {
			return { Icon: CheckCircle2, className: 'text-emerald-600' };
		}
		if (['failed', 'failure'].some((k) => s.includes(k))) {
			return { Icon: XCircle, className: 'text-red-500' };
		}
		if (['abandoned', 'on-hold', 'paused'].some((k) => s.includes(k))) {
			return { Icon: Clock, className: 'text-slate-400' };
		}
		return { Icon: Circle, className: 'text-slate-300' };
	}

	// NPC/Faction affinity icons
	const rank = getAffinityRank(s);

	if (rank === 3) {
		// Enemy
		return { Icon: Sword, className: 'text-red-500 fill-red-500/10' };
	}
	if (rank === 1) {
		// Ally
		return { Icon: Shield, className: 'text-emerald-500 fill-emerald-500/10' };
	}
	// Neutral / Unknown
	return { Icon: Circle, className: 'text-muted-foreground/70' };
};

export const getStatusInfo = (entity) => {
	const statusRaw = entity.status || getAttributeValue(entity.attributes, ['status']);
	const affinityRaw = getAttributeValue(entity.attributes, ['affinity']);

	const displayStatus = affinityRaw && affinityRaw !== 'unknown' ? affinityRaw : statusRaw;
	const statusLower = displayStatus?.toLowerCase();

	return {
		raw: statusRaw,
		display: displayStatus,
		icon: getStatusIcon(displayStatus, entity.type),
		rank: getAffinityRank(displayStatus),
		isDead: statusLower === 'dead',
		isFailed: statusLower === 'failed',
		isCompleted: ['completed', 'finished', 'done', 'success'].some((k) => statusLower?.includes(k)),
	};
};

--- END OF domain\entity\utils\statusUtils.js ---

--- FILE: features\admin\api\adminService.js ---
import { supabase } from '@/shared/api/supabaseClient';
import { getStrategy } from '@/features/admin/config/adminStrategies';

export const createEntity = async (type, data) => {
	const strategy = getStrategy(type);

	// 1. Prepare Core Payload
	const corePayload = {};

	// Only add parent campaign_id if it's NOT a campaign itself
	if (type !== 'campaign') {
		corePayload.campaign_id = data.campaign_id;
	}

	// Name/Desc Mapping
	if (strategy.colMapping) {
		if (data.name) corePayload[strategy.colMapping.name] = data.name;
		if (data.description) corePayload[strategy.colMapping.description] = data.description;
	}
	if (strategy.primaryTable === 'entities') corePayload.type = type;

	// FIX #4: Extract Special Columns from Attributes (e.g. Campaign ID, Map Data)
	// We look at the incoming attributesList or attributes object
	const rawAttributes =
		data.attributesList ||
		(data.attributes ? Object.entries(data.attributes).map(([k, v]) => ({ name: k, value: v })) : []);

	const attributesToInsert = [];

	rawAttributes.forEach((attr) => {
		// Does this attribute match a known column in the definitions?
		// Simple check: For campaigns, 'campaign_id' and 'map_data' are columns.
		const isSpecialColumn = strategy.defaultAttributes?.find((def) => def.key === attr.name && type === 'campaign');

		if (isSpecialColumn) {
			// It's a column! Add to core payload.
			corePayload[attr.name] = attr.value;
		} else {
			// It's a normal attribute. Keep for attributes table.
			attributesToInsert.push(attr);
		}
	});

	console.log('[Admin] Creating:', corePayload);

	// 2. Insert Core
	const { data: insertedRecord, error: insertError } = await supabase
		.from(strategy.primaryTable)
		.insert(corePayload)
		.select()
		.single();

	if (insertError) throw insertError;
	const newId = insertedRecord.id;

	// 3. Insert Remaining Attributes (if any)
	// Campaigns usually don't use the attributes table, so this might be empty, which is fine.
	if (attributesToInsert.length > 0 && strategy.primaryTable !== 'campaigns') {
		const rows = attributesToInsert.map((attr) => ({
			entity_id: newId,
			name: attr.name,
			value: attr.value,
			is_private: false,
		}));

		const { error: attrError } = await supabase.from('attributes').insert(rows);
		if (attrError) throw attrError;
	}

	return { id: newId, ...insertedRecord };
};

export const updateEntity = async (type, id, data) => {
	const strategy = getStrategy(type);

	// 1. Prepare Core Payload
	const corePayload = {};
	if (strategy.colMapping) {
		if (data.name) corePayload[strategy.colMapping.name] = data.name;
		if (data.description) corePayload[strategy.colMapping.description] = data.description;
	}

	// FIX: Extract Special Columns from Attributes
	const rawAttributes =
		data.attributesList ||
		(data.attributes ? Object.entries(data.attributes).map(([k, v]) => ({ name: k, value: v })) : []);

	const attributesToInsert = [];

	rawAttributes.forEach((attr) => {
		const isSpecialColumn = strategy.defaultAttributes?.find((def) => def.key === attr.name && type === 'campaign');

		if (isSpecialColumn) {
			corePayload[attr.name] = attr.value;
		} else {
			attributesToInsert.push(attr);
		}
	});

	// 2. Update Core
	const { error: updateError } = await supabase.from(strategy.primaryTable).update(corePayload).eq('id', id);

	if (updateError) throw updateError;

	// 3. Handle Attributes (Skip for campaigns usually)
	if (strategy.primaryTable !== 'campaigns') {
		// Delete old
		const { error: deleteError } = await supabase.from('attributes').delete().eq('entity_id', id);
		if (deleteError) throw deleteError;

		// Insert new
		if (attributesToInsert.length > 0) {
			const rows = attributesToInsert.map((attr) => ({
				entity_id: id,
				name: attr.name,
				value: attr.value,
				is_private: false,
			}));
			const { error: insertError } = await supabase.from('attributes').insert(rows);
			if (insertError) throw insertError;
		}
	}

	return { success: true };
};

export const fetchRawEntity = async (type, id) => {
	const strategy = getStrategy(type);

	// 1. Fetch Core Data
	const { data: coreData, error: coreError } = await supabase
		.from(strategy.primaryTable)
		.select('*')
		.eq('id', id)
		.single();

	if (coreError) throw coreError;

	// 2. Fetch Attributes (As List)
	const { data: attrData, error: attrError } = await supabase
		.from('attributes')
		.select('name, value')
		.eq('entity_id', id);

	if (attrError) throw attrError;

	// 3. Reverse Map Core Columns
	const formData = { ...coreData };
	if (strategy.colMapping) {
		Object.entries(strategy.colMapping).forEach(([formField, dbCol]) => {
			if (coreData[dbCol] !== undefined) {
				formData[formField] = coreData[dbCol];
			}
		});
	}

	// 4. FIX: Map Column-based attributes (Campaigns) into the Attribute List
	// If the strategy says 'campaign_id' is an attribute, but it exists on 'coreData',
	// we fake it as an attribute so the UI renders it.
	if (strategy.defaultAttributes) {
		strategy.defaultAttributes.forEach((defAttr) => {
			if (coreData[defAttr.key] !== undefined) {
				attrData.push({
					name: defAttr.key,
					value: coreData[defAttr.key],
				});
			}
		});
	}

	// RETURN RAW ATTRIBUTE LIST
	// We intentionally do NOT convert to an object here to preserve duplicates
	return { ...formData, attributesList: attrData };
};

/**
 * Fetch all relationships for a specific entity
 */
export const fetchRelationships = async (id) => {
	const { data, error } = await supabase
		.from('entity_relationships')
		.select(
			`
            id,
            relationship_type,
            description,
            is_bidirectional,
            is_hidden,
            target:entities!to_entity_id ( id, name, type )
        `
		)
		.eq('from_entity_id', id);

	if (error) throw error;
	return data;
};

/**
 * Add a new relationship
 * Note: Your DB trigger 'create_reverse_relationship' handles the reverse link automatically
 * if is_bidirectional is true.
 */
export const addRelationship = async (payload) => {
	// payload = { from_entity_id, to_entity_id, relationship_type, is_bidirectional }
	const { data, error } = await supabase.from('entity_relationships').insert(payload).select().single();

	if (error) throw error;
	return data;
};

/**
 * Delete a relationship
 */
export const deleteRelationship = async (relId) => {
	const { error } = await supabase.from('entity_relationships').delete().eq('id', relId);

	if (error) throw error;
	return true;
};

/**
 * Fetch child rows (e.g., session_events)
 */
export const fetchChildRows = async (table, foreignKeyCol, parentId, orderBy = 'id') => {
	const { data, error } = await supabase
		.from(table)
		.select('*')
		.eq(foreignKeyCol, parentId)
		.order(orderBy, { ascending: true });

	if (error) throw error;
	return data;
};

/**
 * Save a single event.
 * If no ID, it creates. If ID, it updates.
 */
export const upsertSessionEvent = async (eventData) => {
	// 1. Remove ID if it's a placeholder "new"
	const payload = { ...eventData };
	if (String(payload.id).startsWith('new')) {
		delete payload.id;
	}

	const { data, error } = await supabase.from('session_events').upsert(payload).select().single();

	if (error) throw error;
	return data;
};

/**
 * Delete a generic row
 */
export const deleteRow = async (table, id) => {
	const { error } = await supabase.from(table).delete().eq('id', id);
	if (error) throw error;
	return true;
};

/**
 * Save a single quest objective.
 */
export const upsertQuestObjective = async (objectiveData) => {
	// Remove temp ID
	const payload = { ...objectiveData };
	if (String(payload.id).startsWith('new')) {
		delete payload.id;
	}

	const { data, error } = await supabase.from('quest_objectives').upsert(payload).select().single();

	if (error) throw error;
	return data;
};

export const deleteEntity = async (type, id) => {
	const strategy = getStrategy(type);

	// 1. Delete Attributes
	const { error: attrError } = await supabase.from('attributes').delete().eq('entity_id', id);

	if (attrError) console.warn('Attribute delete warning:', attrError);

	// 2. Delete Primary Row (Cascades to 'entities' via DB trigger)
	const { error: mainError } = await supabase.from(strategy.primaryTable).delete().eq('id', id);

	if (mainError) throw mainError;
	return true;
};

export const updateRelationship = async (relId, updates) => {
	const { error } = await supabase.from('entity_relationships').update(updates).eq('id', relId);

	if (error) throw error;
	return true;
};

export const searchEntitiesByName = async (campaignId, query) => {
	const searchTerm = `%${query}%`;

	// 1. Search Entities (NPCs, Locations, Characters, Factions, Quests, Items)
	// We strictly search the 'name' column here.
	const { data: entities } = await supabase
		.from('entities')
		.select('id, name, type, description')
		.eq('campaign_id', campaignId)
		.ilike('name', searchTerm)
		.limit(15); // Higher limit

	// 2. Search Sessions (Sessions are often separate)
	const { data: sessions } = await supabase
		.from('sessions')
		.select('id, title, narrative')
		.eq('campaign_id', campaignId)
		.ilike('title', searchTerm)
		.limit(5);

	// Normalize Sessions to match Entity structure
	const normSessions = (sessions || []).map((s) => ({
		id: s.id,
		name: s.title,
		type: 'session',
		description: s.narrative,
	}));

	return [...(entities || []), ...normSessions];
};

export const getSessionList = async (campaignId) => {
	const { data, error } = await supabase
		.from('sessions')
		.select('id, title')
		.eq('campaign_id', campaignId)
		.order('title', { ascending: true }); // Assuming title starts with "01", "02", etc.

	if (error) throw error;
	return data;
};

/**
 * Fetch session events AND their relationships (mentions) efficiently.
 */
export const fetchSessionEventsWithRelationships = async (sessionId) => {
	// 1. Fetch Events
	const { data: events, error: eventError } = await supabase
		.from('session_events')
		.select('*')
		.eq('session_id', sessionId)
		.order('event_order', { ascending: true });

	if (eventError) throw eventError;
	if (!events || events.length === 0) return [];

	// 2. Fetch Relationships for ALL these events at once
	const eventIds = events.map((e) => e.id);
	const { data: rels, error: relError } = await supabase
		.from('entity_relationships')
		.select(
			`
            id,
            from_entity_id,
            target:entities!to_entity_id ( id, name, type )
        `
		)
		.in('from_entity_id', eventIds);

	if (relError) throw relError;

	// 3. Group Relationships by Event ID
	const relMap = {};
	rels.forEach((r) => {
		if (!relMap[r.from_entity_id]) relMap[r.from_entity_id] = [];
		relMap[r.from_entity_id].push(r);
	});

	// 4. Merge back into Event objects
	return events.map((e) => ({
		...e,
		relationships: relMap[e.id] || [],
	}));
};

/**
 * Fetch encounter actions with resolved actor/target names
 */
export const fetchEncounterActions = async (encounterId) => {
	const { data, error } = await supabase
		.from('encounter_actions')
		.select(
			`
			*,
			actor:entities!actor_entity_id(name, type),
			target:entities!target_entity_id(name, type)
		`
		)
		.eq('encounter_id', encounterId)
		.order('round_number', { ascending: true })
		.order('action_order', { ascending: true });

	if (error) throw error;
	return data;
};

/**
 * Upsert an encounter action (turn)
 */
export const upsertEncounterAction = async (actionData) => {
	const payload = { ...actionData };

	// 1. Remove temporary ID
	if (String(payload.id).startsWith('new')) {
		delete payload.id;
	}

	// 2. Remove joined objects (derived data from the fetch) to prevent column errors
	delete payload.actor;
	delete payload.target;

	// 3. Ensure numeric types
	if (payload.round_number) payload.round_number = parseInt(payload.round_number);
	if (payload.action_order) payload.action_order = parseInt(payload.action_order);

	// 4. Ensure optional UUIDs are null if empty string
	if (payload.actor_entity_id === '') payload.actor_entity_id = null;
	if (payload.target_entity_id === '') payload.target_entity_id = null;

	const { data, error } = await supabase.from('encounter_actions').upsert(payload).select().single();

	if (error) throw error;
	return data;
};

/**
 * Scans the entire campaign for a term and returns a list of proposed changes.
 * Includes: Entities, Sessions, Attributes, Events, and Objectives.
 */
export const getBulkReplacePreview = async (campaignId, findTerm, replaceTerm) => {
	if (!findTerm.trim()) return [];
	const term = findTerm.trim();
	const regex = new RegExp(term, 'gi');
	const matches = [];

	// 1. Scan Entities (Characters, NPCs, etc)
	const { data: ent } = await supabase
		.from('entities')
		.select('id, name, type, description')
		.eq('campaign_id', campaignId);
	ent?.forEach((row) => {
		['name', 'description'].forEach((field) => {
			if (row[field]?.toLowerCase().includes(term.toLowerCase())) {
				matches.push({
					table: 'entities',
					id: row.id,
					field,
					context: `${row.type}: ${row.name}`,
					original: row[field],
					proposal: row[field].replace(regex, replaceTerm),
				});
			}
		});
	});

	// 2. Scan Sessions
	const { data: sess } = await supabase.from('sessions').select('id, title, narrative').eq('campaign_id', campaignId);
	sess?.forEach((row) => {
		[
			['title', 'title'],
			['narrative', 'narrative'],
		].forEach(([field, label]) => {
			if (row[field]?.toLowerCase().includes(term.toLowerCase())) {
				matches.push({
					table: 'sessions',
					id: row.id,
					field,
					context: `Session: ${row.title}`,
					original: row[field],
					proposal: row[field].replace(regex, replaceTerm),
				});
			}
		});
	});

	// 3. Scan Attributes (linked via entity)
	const { data: attr } = await supabase
		.from('attributes')
		.select('id, name, value, entity:entities!inner(name, type, campaign_id)')
		.eq('entities.campaign_id', campaignId);
	attr?.forEach((row) => {
		if (row.value?.toLowerCase().includes(term.toLowerCase())) {
			matches.push({
				table: 'attributes',
				id: row.id,
				field: 'value',
				context: `${row.entity.type} Attribute: ${row.name}`,
				original: row.value,
				proposal: row.value.replace(regex, replaceTerm),
			});
		}
	});

	// 4. Scan Session Events (linked via session)
	const { data: evts } = await supabase
		.from('session_events')
		.select('id, title, description, session:sessions!inner(title, campaign_id)')
		.eq('sessions.campaign_id', campaignId);
	evts?.forEach((row) => {
		['title', 'description'].forEach((field) => {
			if (row[field]?.toLowerCase().includes(term.toLowerCase())) {
				matches.push({
					table: 'session_events',
					id: row.id,
					field,
					context: `Event in ${row.session.title}`,
					original: row[field],
					proposal: row[field].replace(regex, replaceTerm),
				});
			}
		});
	});

	// 5. Scan Quest Objectives (linked via quest/entity)
	const { data: objs } = await supabase
		.from('quest_objectives')
		.select('id, objective_name, description, objective_update, quest:entities!inner(name, campaign_id)')
		.eq('entities.campaign_id', campaignId);
	objs?.forEach((row) => {
		['objective_name', 'description', 'objective_update'].forEach((field) => {
			if (row[field]?.toLowerCase().includes(term.toLowerCase())) {
				matches.push({
					table: 'quest_objectives',
					id: row.id,
					field,
					context: `Objective in ${row.quest.name}`,
					original: row[field],
					proposal: row[field].replace(regex, replaceTerm),
				});
			}
		});
	});

	return matches;
};

/**
 * Takes a list of confirmed changes and executes updates.
 */
export const executeBulkReplace = async (changeList) => {
	const results = { count: 0 };
	// Process in sequence to avoid Supabase rate limits on heavy campaigns
	for (const change of changeList) {
		const { error } = await supabase
			.from(change.table)
			.update({ [change.field]: change.proposal })
			.eq('id', change.id);
		if (!error) results.count++;
	}
	return results;
};

--- END OF features\admin\api\adminService.js ---

--- FILE: features\admin\components\AdminForm.jsx ---
import React, { useEffect, useState } from 'react';
import { useForm, useFieldArray } from 'react-hook-form';
import { useQueryClient } from '@tanstack/react-query'; // CHANGED: Import
import { getStrategy } from '@/features/admin/config/adminStrategies';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { createEntity, fetchRawEntity, updateEntity } from '@/features/admin/api/adminService';
import Button from '@/shared/components/ui/Button';
import { Save, RotateCcw, ExternalLink, Plus, Trash2 } from 'lucide-react';
import { Link } from 'react-router-dom';
import { ADMIN_INPUT_CLASS, ADMIN_LABEL_CLASS, ADMIN_SECTION_CLASS, ADMIN_HEADER_CLASS } from './AdminFormStyles';

// Inputs
import MarkdownEditor from '@/features/admin/components/MarkdownEditor';
import SmartImageInput from '@/features/admin/components/SmartImageInput';

// Sub-Managers
import SessionEventManager from './SessionEventManager';
import QuestObjectiveManager from '@/features/admin/components/QuestObjectiveManager';
import RelationshipManager from '@/features/admin/components/RelationshipManager';
import EncounterActionManager from './EncounterManager';
import TacticalMapManager from './TacticalMapManager';

export default function AdminForm({ type, id }) {
	const strategy = getStrategy(type);
	const { campaignId } = useCampaign();
	const queryClient = useQueryClient(); // CHANGED: Hook
	const [isLoading, setIsLoading] = useState(false);
	const [isSaving, setIsSaving] = useState(false);

	// ... (useForm setup remains same) ...
	const {
		register,
		control,
		handleSubmit,
		reset,
		watch,
		setValue,
		formState: { errors },
	} = useForm({
		defaultValues: {
			attributes: {},
			customAttributes: [],
		},
	});
	const { fields, append, remove } = useFieldArray({ control, name: 'customAttributes' });

	// ... (useEffect loadEntity remains same) ...
	useEffect(() => {
		const loadEntity = async () => {
			setIsLoading(true);
			try {
				if (!id) {
					reset({ attributes: {}, customAttributes: [] });
					setIsLoading(false);
					return;
				}
				const rawData = await fetchRawEntity(type, id);
				// ... (Parsing logic remains same) ...
				const definedKeys = strategy.defaultAttributes.map((a) => a.key);
				const standardAttrs = {};
				const customAttrs = [];

				(rawData.attributesList || []).forEach((attr) => {
					const key = attr.name;
					const value = attr.value;
					if (definedKeys.includes(key)) {
						if (!standardAttrs[key]) standardAttrs[key] = value;
						else customAttrs.push({ key, value });
					} else {
						customAttrs.push({ key, value });
					}
				});

				reset({
					...rawData,
					attributes: standardAttrs,
					customAttributes: customAttrs,
				});
			} catch (err) {
				console.error(err);
				alert('Error loading entity.');
			} finally {
				setIsLoading(false);
			}
		};
		loadEntity();
	}, [type, id, reset, strategy]);

	const onSubmit = async (data) => {
		if (!campaignId && type !== 'campaign') {
			alert('No Campaign Selected! Select one from the home screen first.');
			return;
		}

		// ... (Payload construction remains same) ...
		const attributesList = [];
		Object.entries(data.attributes).forEach(([key, value]) => {
			if (value && String(value).trim() !== '') attributesList.push({ name: key, value });
		});
		data.customAttributes.forEach((item) => {
			if (item.key && item.key.trim() !== '') attributesList.push({ name: item.key, value: item.value });
		});

		const payload = {
			...data,
			attributesList,
		};
		delete payload.attributes;
		delete payload.customAttributes;

		setIsSaving(true);
		try {
			if (id) {
				await updateEntity(type, id, payload);
			} else {
				await createEntity(type, { ...payload, campaign_id: campaignId });
				if (!id) reset();
			}

			// CHANGED: Invalidate all relevant queries to force a refresh despite strict caching
			queryClient.invalidateQueries({
				predicate: (query) => {
					const key = query.queryKey[0];
					// Invalidate lists, wikis, dashboard, and graph
					return ['entities', 'entry', 'dashboard', 'graph', 'timeline', 'globalSearch', 'admin-list'].includes(key);
				},
			});
		} catch (error) {
			alert(`Error: ${error.message}`);
		} finally {
			setIsSaving(false);
		}
	};

	if (isLoading) return <div className='p-8 text-center text-muted-foreground text-sm'>Loading editor...</div>;

	const mapImageUrl = watch('attributes.map_image') || watch('attributes.map');
	const customAttrs = watch('customAttributes') || [];
	const standardMarkers = watch('attributes.map_markers');
	const customMarkers = customAttrs.find((a) => a.key === 'map_markers')?.value;
	const activeMarkersValue = standardMarkers || customMarkers || '[]';

	const handleMarkersChange = (jsonValue) => {
		// Check if map_markers exists in custom list, update it there
		const customIdx = customAttrs.findIndex((a) => a.key === 'map_markers');
		if (customIdx >= 0) {
			setValue(`customAttributes.${customIdx}.value`, jsonValue);
		} else {
			// Otherwise set in standard attributes
			setValue('attributes.map_markers', jsonValue);
		}
	};

	return (
		// ... (Return JSX remains exactly same) ...
		<form onSubmit={handleSubmit(onSubmit)} className='space-y-5 animate-in slide-in-from-bottom-2 duration-300 pb-20'>
			{/* Top Bar */}
			<div className='flex items-center justify-between bg-background border border-border p-3 rounded-lg shadow-sm sticky top-0 z-20 backdrop-blur-md bg-background/80'>
				<div className='flex items-center gap-2'>
					<span className={`w-2 h-2 rounded-full ${id ? 'bg-amber-500/100' : 'bg-emerald-500/100'}`} />
					<span className='text-xs font-bold uppercase tracking-wider text-muted-foreground'>
						{id ? 'Edit Mode' : 'Create Mode'}
					</span>
				</div>
				<div className='flex gap-2'>
					{id && (
						<Link
							to={`/wiki/${type}/${id}`}
							target='_blank'
							className='flex items-center gap-1 px-3 py-1.5 text-xs font-medium text-amber-700 bg-amber-500/10 hover:bg-amber-100 border border-amber-200 rounded-md transition-colors'>
							<ExternalLink size={14} /> View Live
						</Link>
					)}
					<Button type='button' variant='secondary' size='sm' icon={RotateCcw} onClick={() => reset()}>
						Reset
					</Button>
					<Button type='submit' variant='primary' size='sm' icon={Save} disabled={isSaving}>
						{isSaving ? 'Saving...' : 'Save Changes'}
					</Button>
				</div>
			</div>

			{/* Core Details */}
			<div className={ADMIN_SECTION_CLASS}>
				<h2 className={ADMIN_HEADER_CLASS}>Core Details</h2>
				<div className='grid grid-cols-1 gap-4'>
					<div>
						<label className={ADMIN_LABEL_CLASS}>Name / Title</label>
						<input
							type='text'
							{...register('name', { required: true })}
							className={ADMIN_INPUT_CLASS}
							placeholder='Entity Name...'
						/>
						{errors.name && <span className='text-xs text-red-500 mt-1'>Required</span>}
					</div>

					{strategy.hasNarrative && (
						<div>
							<MarkdownEditor
								label='Description / Narrative'
								rows={8}
								value={watch('description') || ''}
								onChange={(e) => setValue('description', e.target.value)}
								placeholder='Write description using Markdown...'
							/>
						</div>
					)}
				</div>
			</div>

			{mapImageUrl && (
				<TacticalMapManager imageUrl={mapImageUrl} value={activeMarkersValue} onChange={handleMarkersChange} />
			)}

			{/* Attributes */}
			<div className={ADMIN_SECTION_CLASS}>
				<h2 className={ADMIN_HEADER_CLASS}>{strategy.label} Attributes</h2>
				<div className='grid grid-cols-1 md:grid-cols-2 gap-4'>
					{strategy.defaultAttributes.map((attr) => (
						<div key={attr.key}>
							<label className={ADMIN_LABEL_CLASS}>{attr.label}</label>
							{attr.type === 'image' ? (
								<SmartImageInput
									value={watch(`attributes.${attr.key}`)}
									onChange={(e) => setValue(`attributes.${attr.key}`, e.target.value)}
									placeholder='images/...'
								/>
							) : attr.type === 'select' ? (
								<select {...register(`attributes.${attr.key}`)} className={ADMIN_INPUT_CLASS}>
									<option value=''>Select...</option>
									{attr.options.map((opt) => (
										<option key={opt} value={opt}>
											{opt}
										</option>
									))}
								</select>
							) : (
								<input
									type={attr.type === 'number' ? 'number' : 'text'}
									{...register(`attributes.${attr.key}`)}
									className={ADMIN_INPUT_CLASS}
								/>
							)}
						</div>
					))}
				</div>
			</div>

			{/* Custom Attributes */}
			<div className={ADMIN_SECTION_CLASS}>
				<div className={ADMIN_HEADER_CLASS}>
					<span>Custom Attributes</span>
					<Button
						type='button'
						onClick={() => append({ key: '', value: '' })}
						size='sm'
						variant='secondary'
						icon={Plus}>
						Add New
					</Button>
				</div>

				<div className='space-y-2'>
					{fields.map((field, index) => (
						<div key={field.id} className='flex gap-3 items-start animate-in fade-in'>
							<div className='w-1/3'>
								<input
									type='text'
									{...register(`customAttributes.${index}.key`)}
									placeholder='Key (e.g. SecretIdentity)'
									className={`${ADMIN_INPUT_CLASS} font-bold text-muted-foreground`}
								/>
							</div>
							<div className='flex-1'>
								<input
									type='text'
									{...register(`customAttributes.${index}.value`)}
									placeholder='Value'
									className={ADMIN_INPUT_CLASS}
								/>
							</div>
							<button
								type='button'
								onClick={() => remove(index)}
								className='p-2 text-muted-foreground/70 hover:text-red-500 hover:bg-red-500/10 rounded transition-colors'>
								<Trash2 size={16} />
							</button>
						</div>
					))}
					{fields.length === 0 && (
						<div className='text-sm text-muted-foreground italic py-2'>No custom attributes defined.</div>
					)}
				</div>
			</div>

			{/* Sub Managers */}
			{id && type === 'session' && <SessionEventManager sessionId={id} />}
			{id && type === 'quest' && <QuestObjectiveManager questId={id} />}
			{id && type === 'encounter' && <EncounterActionManager encounterId={id} />}
			{id && <RelationshipManager entityId={id} />}
		</form>
	);
}

--- END OF features\admin\components\AdminForm.jsx ---

--- FILE: features\admin\components\AdminFormStyles.js ---
export const ADMIN_INPUT_CLASS =
	'w-full px-3 py-2 bg-background border border-border rounded-md text-sm text-foreground focus:outline-none focus:ring-1 focus:ring-amber-500 placeholder:text-muted-foreground/40 transition-all shadow-sm';

export const ADMIN_LABEL_CLASS =
	'block text-[10px] font-bold text-muted-foreground uppercase tracking-[0.1em] mb-1.5 ml-0.5';

export const ADMIN_SECTION_CLASS = 'bg-background border border-border rounded-xl p-5 shadow-sm space-y-4 relative';

export const ADMIN_HEADER_CLASS =
	'text-base font-serif font-bold text-foreground border-b border-border/60 pb-2 mb-4 flex items-center justify-between tracking-tight';

--- END OF features\admin\components\AdminFormStyles.js ---

--- FILE: features\admin\components\EncounterManager.jsx ---
import React, { useEffect, useState } from 'react';
import { Plus, Trash2, Edit2, Save, X, Swords, Skull, Target, Zap, HeartHandshake } from 'lucide-react'; // Added HeartHandshake
import { fetchEncounterActions, upsertEncounterAction, deleteRow } from '@/features/admin/api/adminService';
import { ADMIN_SECTION_CLASS, ADMIN_HEADER_CLASS, ADMIN_INPUT_CLASS, ADMIN_LABEL_CLASS } from './AdminFormStyles';
import EntitySearch from './EntitySearch';
import Button from '@/shared/components/ui/Button';

export default function EncounterActionManager({ encounterId }) {
	const [actions, setActions] = useState([]);
	const [loading, setLoading] = useState(false);
	const [editingId, setEditingId] = useState(null);
	const [formData, setFormData] = useState({});

	useEffect(() => {
		if (encounterId) loadActions();
	}, [encounterId]);

	const loadActions = async () => {
		setLoading(true);
		try {
			const data = await fetchEncounterActions(encounterId);
			setActions(data);
		} catch (e) {
			console.error(e);
		} finally {
			setLoading(false);
		}
	};

	const handleAddNew = () => {
		const lastAction = actions[actions.length - 1];
		const nextRound = lastAction ? lastAction.round_number : 1;
		const nextOrder = lastAction ? lastAction.action_order + 1 : 1;

		const newAction = {
			id: `new-${Date.now()}`,
			encounter_id: encounterId,
			round_number: nextRound,
			action_order: nextOrder,
			actor_name: '',
			action_description: '',
			action_type: 'attack',
			result: '',
			effect: '',
			is_friendly: false, // Default to hostile
		};
		setActions([...actions, newAction]);
		handleEdit(newAction);
	};

	const handleEdit = (action) => {
		setEditingId(action.id);
		setFormData({ ...action });
	};

	const handleSave = async () => {
		try {
			await upsertEncounterAction(formData);
			setEditingId(null);
			loadActions();
		} catch (e) {
			alert('Error saving action: ' + e.message);
		}
	};

	const handleDelete = async (id) => {
		if (!confirm('Delete this turn?')) return;
		if (String(id).startsWith('new')) {
			setActions(actions.filter((a) => a.id !== id));
			return;
		}
		try {
			await deleteRow('encounter_actions', id);
			loadActions();
		} catch (e) {
			alert(e.message);
		}
	};

	const setActor = (entity) =>
		setFormData((prev) => ({ ...prev, actor_entity_id: entity.id, actor_name: entity.name }));
	const setTarget = (entity) =>
		setFormData((prev) => ({ ...prev, target_entity_id: entity.id, target_name: entity.name }));

	return (
		<div className={ADMIN_SECTION_CLASS}>
			<div className={`${ADMIN_HEADER_CLASS} flex items-center justify-between`}>
				<span className='flex items-center gap-2'>
					<Swords size={18} className='text-red-600' /> Combat Tracker
				</span>
				<Button onClick={handleAddNew} size='sm' variant='secondary' icon={Plus}>
					Add Turn
				</Button>
			</div>

			<div className='space-y-4'>
				{actions.map((action) => {
					const isFriendly = action.is_friendly;
					const theme = isFriendly
						? {
								border: 'border-emerald-200 hover:border-emerald-300',
								bg: 'bg-emerald-500/10/20',
								accentText: 'text-emerald-700',
								badge: 'bg-emerald-100 text-emerald-800 border-emerald-200',
						  }
						: {
								border: 'border-red-200 hover:border-red-300',
								bg: 'bg-background',
								accentText: 'text-red-700',
								badge: 'bg-red-500/10 text-red-700 border-red-100',
						  };

					return (
						<div key={action.id} className='group'>
							{editingId === action.id ? (
								/* --- EDIT MODE --- */
								<div className='bg-muted/30 border border-border rounded-lg p-4 space-y-3 animate-in fade-in shadow-sm'>
									{/* Row 1: Timing & Type */}
									<div className='flex gap-3 items-end'>
										<div className='w-16'>
											<label className={ADMIN_LABEL_CLASS}>Round</label>
											<input
												type='number'
												className={ADMIN_INPUT_CLASS}
												value={formData.round_number}
												onChange={(e) => setFormData({ ...formData, round_number: e.target.value })}
											/>
										</div>
										<div className='w-16'>
											<label className={ADMIN_LABEL_CLASS}>Order</label>
											<input
												type='number'
												className={ADMIN_INPUT_CLASS}
												value={formData.action_order}
												onChange={(e) => setFormData({ ...formData, action_order: e.target.value })}
											/>
										</div>
										<div className='flex-1'>
											<label className={ADMIN_LABEL_CLASS}>Action Type</label>
											<select
												className={ADMIN_INPUT_CLASS}
												value={formData.action_type || 'attack'}
												onChange={(e) => setFormData({ ...formData, action_type: e.target.value })}>
												<option value='attack'>Attack</option>
												<option value='action'>Action</option>
												<option value='bonus_action'>Bonus Action</option>
												<option value='spell'>Spell</option>
												<option value='move'>Movement</option>
												<option value='item'>Item Interaction</option>
												<option value='check'>Skill Check</option>
												<option value='save'>Saving Throw</option>
												<option value='legendary'>Legendary Action</option>
												<option value='lair'>Lair Action</option>
											</select>
										</div>
										<label className='flex items-center gap-2 cursor-pointer select-none border border-border rounded-md px-3 py-2 bg-background h-[38px] hover:border-emerald-300 transition-colors'>
											<input
												type='checkbox'
												checked={formData.is_friendly || false}
												onChange={(e) => setFormData({ ...formData, is_friendly: e.target.checked })}
												className='w-4 h-4 text-emerald-600 rounded focus:ring-emerald-500 cursor-pointer'
											/>
											<span className='text-xs font-bold text-foreground'>Friendly?</span>
										</label>
									</div>

									{/* Row 2: Actor & Target */}
									<div className='grid grid-cols-1 md:grid-cols-2 gap-4'>
										<div>
											<label className={ADMIN_LABEL_CLASS}>Actor (Who?)</label>
											{formData.actor_entity_id ? (
												<div className='flex gap-2 items-center'>
													<input
														className={`${ADMIN_INPUT_CLASS} bg-emerald-500/10 font-medium`}
														readOnly
														value={formData.actor_name || 'Linked Entity'}
													/>
													<Button
														size='sm'
														variant='ghost'
														onClick={() => setFormData({ ...formData, actor_entity_id: null, actor_name: '' })}>
														Change
													</Button>
												</div>
											) : (
												<div className='space-y-1'>
													<EntitySearch onSelect={setActor} />
													<input
														type='text'
														placeholder='Or type manual name...'
														className={ADMIN_INPUT_CLASS}
														value={formData.actor_name || ''}
														onChange={(e) => setFormData({ ...formData, actor_name: e.target.value })}
													/>
												</div>
											)}
										</div>

										<div>
											<label className={ADMIN_LABEL_CLASS}>Target (Whom?)</label>
											{formData.target_entity_id ? (
												<div className='flex gap-2 items-center'>
													<input
														className={`${ADMIN_INPUT_CLASS} bg-red-500/10 font-medium`}
														readOnly
														value={formData.target_name || 'Linked Entity'}
													/>
													<Button
														size='sm'
														variant='ghost'
														onClick={() => setFormData({ ...formData, target_entity_id: null, target_name: '' })}>
														Change
													</Button>
												</div>
											) : (
												<div className='space-y-1'>
													<EntitySearch onSelect={setTarget} />
													<input
														type='text'
														placeholder='Or type manual name...'
														className={ADMIN_INPUT_CLASS}
														value={formData.target_name || ''}
														onChange={(e) => setFormData({ ...formData, target_name: e.target.value })}
													/>
												</div>
											)}
										</div>
									</div>

									{/* Row 3: Description */}
									<div>
										<label className={ADMIN_LABEL_CLASS}>Description</label>
										<textarea
											rows={2}
											className={ADMIN_INPUT_CLASS}
											value={formData.action_description || ''}
											onChange={(e) => setFormData({ ...formData, action_description: e.target.value })}
											placeholder='Uses Multiattack...'
										/>
									</div>

									{/* Row 4: Result & Effect */}
									<div className='grid grid-cols-1 md:grid-cols-2 gap-4'>
										<div>
											<label className={ADMIN_LABEL_CLASS}>Result (Hit/Miss/Save)</label>
											<input
												type='text'
												className={ADMIN_INPUT_CLASS}
												value={formData.result || ''}
												onChange={(e) => setFormData({ ...formData, result: e.target.value })}
												placeholder='e.g., Hit (24), Crit, Failed Save'
											/>
										</div>
										<div>
											<label className={ADMIN_LABEL_CLASS}>Effect (Damage/Status)</label>
											<input
												type='text'
												className={ADMIN_INPUT_CLASS}
												value={formData.effect || ''}
												onChange={(e) => setFormData({ ...formData, effect: e.target.value })}
												placeholder='e.g., 23 slashing dmg, Prone'
											/>
										</div>
									</div>

									<div className='flex justify-end gap-3 pt-2'>
										<Button
											onClick={() => {
												setEditingId(null);
												loadActions();
											}}
											variant='ghost'
											size='sm'
											icon={X}>
											Cancel
										</Button>
										<Button onClick={handleSave} variant='primary' size='sm' icon={Save}>
											Save Turn
										</Button>
									</div>
								</div>
							) : (
								/* --- VIEW MODE --- */
								<div
									className={`flex items-start gap-3 p-3 border rounded-lg transition-colors ${theme.bg} ${theme.border}`}>
									<div className='flex flex-col items-center justify-center w-10 shrink-0'>
										<span className='text-[9px] font-bold uppercase text-muted-foreground'>Round</span>
										<span className={`text-lg font-serif font-bold ${theme.accentText}`}>{action.round_number}</span>
									</div>

									<div className='flex-1 min-w-0'>
										<div className='flex items-center gap-2 mb-1 flex-wrap'>
											<span className='text-sm font-bold text-foreground'>{action.actor_name || 'Unknown Actor'}</span>

											{/* Friendly/Hostile Icon Indicator */}
											{isFriendly ? (
												<HeartHandshake size={14} className='text-emerald-500' title='Friendly Action' />
											) : (
												<span className='text-[10px] uppercase tracking-wider text-muted-foreground'>used</span>
											)}

											<span className={`px-1.5 py-0.5 border rounded text-[10px] font-bold uppercase ${theme.badge}`}>
												{action.action_type}
											</span>
											{action.target_name && (
												<>
													<span className='text-[10px] text-muted-foreground'>on</span>
													<span className='text-sm font-medium text-foreground'>{action.target_name}</span>
												</>
											)}
										</div>

										<p className='text-xs text-muted-foreground mb-1'>{action.action_description}</p>

										<div className='flex items-center gap-2 mt-2'>
											{action.result && (
												<div className='flex items-center gap-1.5 text-xs font-semibold text-slate-700 bg-muted px-2 py-0.5 rounded border border-border'>
													<Target size={12} /> {action.result}
												</div>
											)}
											{action.effect && (
												<div className='flex items-center gap-1.5 text-xs font-semibold text-red-800 bg-red-500/10 px-2 py-0.5 rounded border border-red-100'>
													<Zap size={12} /> {action.effect}
												</div>
											)}
										</div>
									</div>

									<div className='flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity'>
										<button
											onClick={() => handleEdit(action)}
											className='p-2 text-muted-foreground hover:text-blue-600 hover:bg-blue-500/10 rounded-md transition-colors'>
											<Edit2 size={16} />
										</button>
										<button
											onClick={() => handleDelete(action.id)}
											className='p-2 text-muted-foreground hover:text-red-600 hover:bg-red-500/10 rounded-md transition-colors'>
											<Trash2 size={16} />
										</button>
									</div>
								</div>
							)}
						</div>
					);
				})}

				{actions.length === 0 && !loading && (
					<div className='text-center py-8 text-muted-foreground text-sm italic'>No combat turns recorded yet.</div>
				)}
			</div>
		</div>
	);
}

--- END OF features\admin\components\EncounterManager.jsx ---

--- FILE: features\admin\components\EntitySearch.jsx ---
import React, { useState, useEffect, useRef } from 'react';
import { searchEntitiesByName } from '@/features/admin/api/adminService'; // <--- NEW IMPORT
import { useCampaign } from '@/features/campaign/CampaignContext';
import { Search, X, Loader2 } from 'lucide-react';

export default function EntitySearch({ onSelect }) {
	const { campaignId } = useCampaign();
	const [query, setQuery] = useState('');
	const [results, setResults] = useState([]);
	const [isOpen, setIsOpen] = useState(false);
	const [isLoading, setIsLoading] = useState(false);
	const wrapperRef = useRef(null);

	// Close on click outside
	useEffect(() => {
		function handleClickOutside(event) {
			if (wrapperRef.current && !wrapperRef.current.contains(event.target)) {
				setIsOpen(false);
			}
		}
		document.addEventListener('mousedown', handleClickOutside);
		return () => document.removeEventListener('mousedown', handleClickOutside);
	}, [wrapperRef]);

	useEffect(() => {
		const doSearch = async () => {
			if (query.length < 2) {
				setResults([]);
				return;
			}
			setIsLoading(true);
			try {
				// <--- USE NEW SERVICE HERE
				const flat = await searchEntitiesByName(campaignId, query);

				// Client-side Sorting: Exact Match > Starts With > Includes
				flat.sort((a, b) => {
					const nameA = (a.name || '').toLowerCase();
					const nameB = (b.name || '').toLowerCase();
					const q = query.toLowerCase();

					// 1. Exact Match Priority
					if (nameA === q && nameB !== q) return -1;
					if (nameB === q && nameA !== q) return 1;

					// 2. Starts With Priority
					if (nameA.startsWith(q) && !nameB.startsWith(q)) return -1;
					if (nameB.startsWith(q) && !nameA.startsWith(q)) return 1;

					// 3. Shortest Name Priority (Less noise)
					return nameA.length - nameB.length;
				});

				setResults(flat);
				setIsOpen(true);
			} catch (error) {
				console.error('Search failed', error);
			} finally {
				setIsLoading(false);
			}
		};

		const timeout = setTimeout(doSearch, 300);
		return () => clearTimeout(timeout);
	}, [query, campaignId]);

	const handleSelect = (item) => {
		onSelect(item);
		setQuery('');
		setIsOpen(false);
	};

	return (
		<div className='relative w-full' ref={wrapperRef}>
			{/* Label removed inside component for cleaner Bulk UI */}

			<div className='relative'>
				<input
					autoFocus
					type='text'
					value={query}
					onChange={(e) => {
						setQuery(e.target.value);
						if (!isOpen) setIsOpen(true);
					}}
					placeholder='Search by name...'
					className='w-full pl-9 pr-8 py-2 bg-background border border-border rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-amber-500 shadow-sm transition-shadow'
				/>
				<Search className='absolute left-3 top-2.5 text-muted-foreground/60' size={14} />

				{query && (
					<button
						onClick={() => {
							setQuery('');
							setIsOpen(false);
						}}
						className='absolute right-2 top-2 text-muted-foreground hover:text-foreground p-0.5 rounded'>
						<X size={14} />
					</button>
				)}
			</div>

			{/* Dropdown Results */}
			{isOpen && (results.length > 0 || isLoading) && (
				<div className='absolute z-50 w-full mt-1 bg-card border border-border rounded-lg shadow-xl max-h-60 overflow-y-auto overflow-x-hidden animate-in fade-in zoom-in-95 duration-100'>
					{isLoading ? (
						<div className='p-3 text-center text-xs text-muted-foreground flex items-center justify-center gap-2'>
							<Loader2 size={14} className='animate-spin' /> Searching...
						</div>
					) : (
						results.map((item) => (
							<button
								key={item.id}
								type='button'
								onClick={() => handleSelect(item)}
								className='w-full text-left px-3 py-2 hover:bg-amber-500/10 border-b border-border/50 last:border-0 transition-colors group'>
								<div className='font-bold text-sm text-foreground group-hover:text-amber-800 truncate'>{item.name}</div>
								<div className='flex items-center gap-2'>
									<span className='text-[10px] font-bold uppercase tracking-wider text-muted-foreground bg-muted px-1.5 rounded group-hover:bg-amber-100/50'>
										{item.type}
									</span>
									{/* Description Snippet */}
									<span className='text-[10px] text-muted-foreground/60 truncate max-w-[200px]'>
										{item.description ? item.description.substring(0, 50) : ''}
									</span>
								</div>
							</button>
						))
					)}
				</div>
			)}

			{isOpen && !isLoading && results.length === 0 && query.length >= 2 && (
				<div className='absolute z-50 w-full mt-1 bg-card border border-border rounded-lg shadow-xl p-3 text-center text-xs text-muted-foreground'>
					No results for "{query}"
				</div>
			)}
		</div>
	);
}

--- END OF features\admin\components\EntitySearch.jsx ---

--- FILE: features\admin\components\EventTagger.jsx ---
import React, { useState, useEffect } from 'react';
import { X, Plus, Loader2 } from 'lucide-react';
import EntitySearch from './EntitySearch';
import { fetchRelationships, addRelationship, deleteRelationship } from '@/features/admin/api/adminService';

export default function EventTagger({ eventId }) {
	const [tags, setTags] = useState([]);
	const [loading, setLoading] = useState(false);
	const [isAdding, setIsAdding] = useState(false);

	// If it's a temporary event (unsaved), we can't tag yet
	const isTemp = String(eventId).startsWith('new-');

	useEffect(() => {
		if (!isTemp) loadTags();
	}, [eventId]);

	const loadTags = async () => {
		setLoading(true);
		try {
			const data = await fetchRelationships(eventId);
			setTags(data);
		} catch (e) {
			console.error(e);
		} finally {
			setLoading(false);
		}
	};

	const handleAdd = async (target) => {
		if (tags.find((t) => t.target?.id === target.id)) return;

		setIsAdding(true);
		try {
			await addRelationship({
				from_entity_id: eventId,
				to_entity_id: target.id,
				relationship_type: 'mention', // Standard type for events
				is_bidirectional: false,
			});
			loadTags();
		} catch (e) {
			alert(e.message);
		} finally {
			setIsAdding(false);
		}
	};

	const handleRemove = async (relId) => {
		try {
			await deleteRelationship(relId);
			setTags(tags.filter((t) => t.id !== relId));
		} catch (e) {
			alert(e.message);
		}
	};

	if (isTemp) {
		return <div className='text-xs text-amber-600 bg-amber-500/10 p-2 rounded'>Save this event to enable tagging.</div>;
	}

	return (
		<div className='space-y-2 mt-2 pt-2 border-t border-border/50'>
			<label className='text-[10px] font-bold uppercase text-muted-foreground'>Mentions / Related Entities</label>

			{/* Tag List */}
			<div className='flex flex-wrap gap-2 mb-2'>
				{tags.map((rel) => (
					<div
						key={rel.id}
						className='flex items-center gap-1 bg-card border border-border px-2 py-1 rounded-md text-xs shadow-sm'>
						<span className='font-medium text-foreground'>{rel.target?.name}</span>
						<span className='text-[9px] text-muted-foreground uppercase'>{rel.target?.type}</span>
						<button onClick={() => handleRemove(rel.id)} className='ml-1 text-muted-foreground/70 hover:text-red-500'>
							<X size={12} />
						</button>
					</div>
				))}
				{loading && <Loader2 size={14} className='animate-spin text-muted-foreground' />}
			</div>

			{/* Search Input */}
			<div className='max-w-xs'>
				<EntitySearch onSelect={handleAdd} />
			</div>
		</div>
	);
}

--- END OF features\admin\components\EventTagger.jsx ---

--- FILE: features\admin\components\ImageLibraryModal.jsx ---
import React, { useState } from 'react';
import { Search, Image as ImageIcon, FolderOpen, RefreshCw } from 'lucide-react';
import { Drawer } from '@/shared/components/ui/Drawer';
import { ADMIN_INPUT_CLASS } from './AdminFormStyles';
// IMPORT THE GENERATED FILE
import imageLibraryData from '../config/imageManifest.json';

export default function ImageLibraryModal({ isOpen, onClose, onSelect }) {
	const [searchTerm, setSearchTerm] = useState('');

	// Use the dynamic data from the script
	const filteredLibrary = imageLibraryData
		.map((cat) => ({
			...cat,
			files: cat.files.filter((f) => f.toLowerCase().includes(searchTerm.toLowerCase())),
		}))
		.filter((cat) => cat.files.length > 0);

	return (
		<Drawer isOpen={isOpen} onClose={onClose} title='Image Library' position='right'>
			<div className='p-4 space-y-6'>
				<div className='relative'>
					<Search className='absolute left-3 top-2.5 text-muted-foreground' size={14} />
					<input
						type='text'
						placeholder='Search for image or category...'
						className={ADMIN_INPUT_CLASS + ' pl-9'}
						value={searchTerm}
						onChange={(e) => setSearchTerm(e.target.value)}
						autoFocus
					/>
				</div>

				<div className='space-y-8 pb-20'>
					{filteredLibrary.map((group) => (
						<div key={group.category} className='space-y-3 animate-in fade-in slide-in-from-bottom-1 duration-300'>
							<h3 className='text-[9px] font-bold uppercase tracking-[0.2em] text-muted-foreground flex items-center gap-2'>
								<FolderOpen size={10} className='text-amber-600' />
								{group.category}
								<span className='text-[8px] font-normal lowercase tracking-normal bg-muted px-1.5 rounded-full'>
									{group.files.length} images
								</span>
							</h3>

							<div className='grid grid-cols-3 sm:grid-cols-4 gap-2'>
								{group.files.map((file) => {
									const fullPath = `${group.path}${file}`;
									const previewUrl = `${import.meta.env.BASE_URL}${fullPath}`;

									return (
										<button
											key={file}
											type='button'
											title={file}
											onClick={() => {
												onSelect(fullPath);
												onClose();
											}}
											className='group relative aspect-square rounded-md border border-border bg-card overflow-hidden hover:border-amber-500 hover:ring-2 hover:ring-amber-500/20 transition-all shadow-sm'>
											<img
												src={previewUrl}
												alt={file}
												className='w-full h-full object-cover group-hover:scale-110 transition-transform duration-500'
												loading='lazy'
											/>
											{/* Hover Overlay with filename */}
											<div className='absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity flex items-end p-1'>
												<p className='text-[7px] text-white truncate w-full text-center font-mono'>{file}</p>
											</div>
										</button>
									);
								})}
							</div>
						</div>
					))}

					{filteredLibrary.length === 0 && (
						<div className='text-center py-20 opacity-30 flex flex-col items-center'>
							<ImageIcon size={40} strokeWidth={1} />
							<p className='text-xs mt-2'>No matching images found.</p>
						</div>
					)}
				</div>
			</div>
		</Drawer>
	);
}

--- END OF features\admin\components\ImageLibraryModal.jsx ---

--- FILE: features\admin\components\MarkdownEditor.jsx ---
import React, { useState, useRef, useEffect } from 'react';
import { Eye, Edit3, Wand2, X, AtSign } from 'lucide-react';
import SmartMarkdown from '@/features/smart-text/SmartMarkdown';
import EntitySearch from './EntitySearch';
import { ADMIN_INPUT_CLASS, ADMIN_LABEL_CLASS } from './AdminFormStyles';

export default function MarkdownEditor({ label, value, onChange, placeholder, rows = 8 }) {
	const [mode, setMode] = useState('write');
	const [showSearch, setShowSearch] = useState(false);
	const textareaRef = useRef(null);

	const handleInputChange = (e) => {
		const newValue = e.target.value;
		const selectionStart = e.target.selectionStart;
		onChange(e);

		// Detect '@' trigger
		const charBefore = newValue.charAt(selectionStart - 1);
		if (charBefore === '@') {
			setShowSearch(true);
		}
	};

	const handleInsertEntity = (entity) => {
		const textarea = textareaRef.current;
		const textToInsert = `[:: ${entity.name} ::](#entity/${entity.id}/${entity.type})`;

		if (textarea) {
			const start = textarea.selectionStart;
			const end = textarea.selectionEnd;
			const currentText = value || '';

			let insertPos = start;
			let beforeText = currentText.substring(0, start);
			const afterText = currentText.substring(end);

			if (beforeText.endsWith('@')) {
				beforeText = beforeText.slice(0, -1);
				insertPos = start - 1;
			}

			const newValue = beforeText + textToInsert + afterText;
			onChange({ target: { value: newValue } });

			// Return focus and fix cursor position
			setTimeout(() => {
				textarea.focus();
				const newCursorPos = insertPos + textToInsert.length;
				textarea.setSelectionRange(newCursorPos, newCursorPos);
			}, 0);
		}
		setShowSearch(false);
	};

	return (
		<div className='relative flex flex-col'>
			<div className='flex items-end justify-between mb-1.5'>
				<label className={ADMIN_LABEL_CLASS}>{label}</label>
				<div className='flex bg-muted/50 rounded-md p-0.5 border border-border shadow-sm'>
					<button
						type='button'
						onClick={() => setShowSearch(!showSearch)}
						className={`px-2 py-1 text-[10px] font-bold uppercase rounded flex items-center gap-1.5 transition-all ${
							showSearch
								? 'bg-amber-100 text-amber-800 ring-1 ring-amber-200'
								: 'text-muted-foreground hover:text-foreground'
						}`}>
						<AtSign size={12} /> Mentions
					</button>
					<div className='w-px bg-border mx-1 my-1' />
					<button
						type='button'
						onClick={() => setMode('write')}
						className={`px-2 py-1 text-[10px] font-bold uppercase rounded transition-all ${
							mode === 'write'
								? 'bg-background text-foreground shadow-sm'
								: 'text-muted-foreground hover:text-foreground'
						}`}>
						Write
					</button>
					<button
						type='button'
						onClick={() => setMode('preview')}
						className={`px-2 py-1 text-[10px] font-bold uppercase rounded transition-all ${
							mode === 'preview'
								? 'bg-background text-foreground shadow-sm'
								: 'text-muted-foreground hover:text-foreground'
						}`}>
						Preview
					</button>
				</div>
			</div>

			<div className='relative'>
				{/* FLOATING MENTION MODAL - Now Absolute and Z-Indexed to prevent layout push */}
				{showSearch && (
					<div className='absolute inset-x-0 top-0 z-50 p-3 bg-background border border-amber-300 shadow-2xl rounded-lg animate-in fade-in zoom-in-95 duration-150'>
						<div className='flex justify-between items-center mb-2'>
							<span className='text-[10px] font-bold uppercase text-amber-600 tracking-widest flex items-center gap-1'>
								<Wand2 size={10} /> Link Entity
							</span>
							<button onClick={() => setShowSearch(false)} className='text-muted-foreground hover:text-red-500'>
								<X size={14} />
							</button>
						</div>
						<EntitySearch onSelect={handleInsertEntity} autoFocus />
					</div>
				)}

				{mode === 'write' ? (
					<textarea
						ref={textareaRef}
						rows={rows}
						className={`${ADMIN_INPUT_CLASS} font-mono text-xs leading-relaxed min-h-[150px] resize-y`}
						value={value}
						onChange={handleInputChange}
						placeholder={placeholder}
					/>
				) : (
					<div className='w-full px-4 py-3 bg-muted/10 border border-border rounded-md min-h-[150px] prose prose-sm max-w-none'>
						{value ? (
							<SmartMarkdown>{value}</SmartMarkdown>
						) : (
							<span className='text-muted-foreground italic text-xs'>Nothing to preview.</span>
						)}
					</div>
				)}
			</div>
		</div>
	);
}

--- END OF features\admin\components\MarkdownEditor.jsx ---

--- FILE: features\admin\components\QuestObjectiveManager.jsx ---
import React, { useEffect, useState } from 'react';
import { Plus, Trash2, Edit2, Save, X, Target, CheckCircle2, Circle, Calendar } from 'lucide-react';
import { fetchChildRows, upsertQuestObjective, deleteRow, getSessionList } from '@/features/admin/api/adminService'; // Import getSessionList
import { ADMIN_SECTION_CLASS, ADMIN_HEADER_CLASS, ADMIN_INPUT_CLASS, ADMIN_LABEL_CLASS } from './AdminFormStyles';
import { useCampaign } from '@/features/campaign/CampaignContext';
import Button from '@/shared/components/ui/Button';

export default function QuestObjectiveManager({ questId }) {
	const { campaignId } = useCampaign();
	const [objectives, setObjectives] = useState([]);
	const [sessions, setSessions] = useState([]); // Store session options
	const [loading, setLoading] = useState(false);
	const [editingId, setEditingId] = useState(null);
	const [formData, setFormData] = useState({});

	useEffect(() => {
		if (questId) {
			loadObjectives();
			loadSessions();
		}
	}, [questId]);

	const loadObjectives = async () => {
		setLoading(true);
		try {
			const data = await fetchChildRows('quest_objectives', 'quest_id', questId, 'order_index');
			setObjectives(data);
		} catch (e) {
			console.error(e);
		} finally {
			setLoading(false);
		}
	};

	const loadSessions = async () => {
		if (!campaignId) return;
		try {
			const data = await getSessionList(campaignId);
			setSessions(data);
		} catch (e) {
			console.error('Failed to load sessions', e);
		}
	};

	const handleAddNew = () => {
		const nextOrder = objectives.length > 0 ? Math.max(...objectives.map((o) => o.order_index || 0)) + 1 : 1;
		const newObj = {
			id: `new-${Date.now()}`,
			quest_id: questId,
			objective_name: '', // Title
			description: '',
			objective_update: '', // Resolution text
			status: 'pending',
			order_index: nextOrder,
			completed_session_id: null,
		};
		setObjectives([...objectives, newObj]);
		handleEdit(newObj);
	};

	const handleEdit = (obj) => {
		setEditingId(obj.id);
		setFormData({ ...obj });
	};

	const handleSave = async () => {
		try {
			await upsertQuestObjective(formData);
			setEditingId(null);
			loadObjectives();
		} catch (e) {
			alert(e.message);
		}
	};

	const handleDelete = async (id) => {
		if (!confirm('Delete?')) return;
		if (String(id).startsWith('new')) {
			setObjectives(objectives.filter((o) => o.id !== id));
			return;
		}
		try {
			await deleteRow('quest_objectives', id);
			loadObjectives();
		} catch (e) {
			alert(e.message);
		}
	};

	return (
		<div className={ADMIN_SECTION_CLASS}>
			<div className={`${ADMIN_HEADER_CLASS} flex justify-between`}>
				<span className='flex items-center gap-2'>
					<Target size={18} className='text-blue-600' /> Objectives
				</span>
				<Button onClick={handleAddNew} size='sm' variant='secondary' icon={Plus}>
					Add Objective
				</Button>
			</div>

			<div className='space-y-3'>
				{objectives.map((obj) => (
					<div key={obj.id} className='group'>
						{editingId === obj.id ? (
							/* --- EDIT MODE --- */
							<div className='bg-muted/30 border border-blue-300 rounded-lg p-4 space-y-4 animate-in fade-in'>
								{/* Row 1: Order, Title, Status */}
								<div className='flex gap-3'>
									<div className='w-16'>
										<label className={ADMIN_LABEL_CLASS}>#</label>
										<input
											type='number'
											className={ADMIN_INPUT_CLASS}
											value={formData.order_index}
											onChange={(e) => setFormData({ ...formData, order_index: parseInt(e.target.value) })}
										/>
									</div>
									<div className='flex-1'>
										<label className={ADMIN_LABEL_CLASS}>Title (Name)</label>
										<input
											type='text'
											className={`${ADMIN_INPUT_CLASS} font-bold`}
											autoFocus
											value={formData.objective_name || ''}
											onChange={(e) => setFormData({ ...formData, objective_name: e.target.value })}
											placeholder='Short summary...'
										/>
									</div>
									<div className='w-32'>
										<label className={ADMIN_LABEL_CLASS}>Status</label>
										<select
											className={ADMIN_INPUT_CLASS}
											value={formData.status}
											onChange={(e) => setFormData({ ...formData, status: e.target.value })}>
											<option value='pending'>Pending</option>
											<option value='completed'>Completed</option>
											<option value='failed'>Failed</option>
										</select>
									</div>
								</div>

								{/* Row 2: Description */}
								<div>
									<label className={ADMIN_LABEL_CLASS}>Description</label>
									<textarea
										rows={2}
										className={ADMIN_INPUT_CLASS}
										value={formData.description || ''}
										onChange={(e) => setFormData({ ...formData, description: e.target.value })}
										placeholder='What needs to be done?'
									/>
								</div>

								{/* Row 3: Updates & Session */}
								<div className='grid grid-cols-1 md:grid-cols-2 gap-4 border-t border-border/50 pt-3'>
									<div>
										<label className={ADMIN_LABEL_CLASS}>Resolution / Update Text</label>
										<textarea
											rows={2}
											className={ADMIN_INPUT_CLASS}
											value={formData.objective_update || ''}
											onChange={(e) => setFormData({ ...formData, objective_update: e.target.value })}
											placeholder='How was it resolved?'
										/>
									</div>
									<div>
										<label className={ADMIN_LABEL_CLASS}>Completed In Session</label>
										<select
											className={ADMIN_INPUT_CLASS}
											value={formData.completed_session_id || ''}
											onChange={(e) => setFormData({ ...formData, completed_session_id: e.target.value || null })}>
											<option value=''>-- None --</option>
											{sessions.map((s) => (
												<option key={s.id} value={s.id}>
													{s.title}
												</option>
											))}
										</select>
									</div>
								</div>

								<div className='flex justify-end gap-2 pt-2'>
									<Button
										onClick={() => {
											setEditingId(null);
											loadObjectives();
										}}
										variant='ghost'
										size='sm'
										icon={X}>
										Cancel
									</Button>
									<Button onClick={handleSave} variant='primary' size='sm' icon={Save}>
										Save Objective
									</Button>
								</div>
							</div>
						) : (
							/* --- VIEW MODE --- */
							<div
								className={`flex items-start gap-3 p-3 border rounded-lg transition-colors ${
									obj.status === 'completed'
										? 'bg-emerald-500/10/50 border-emerald-200'
										: 'bg-background border-border hover:border-blue-300'
								}`}>
								<span className='font-mono text-xs font-bold opacity-40 w-5 mt-1'>#{obj.order_index}</span>

								<div className='shrink-0 mt-0.5'>
									{obj.status === 'completed' ? (
										<CheckCircle2 size={18} className='text-emerald-600' />
									) : (
										<Circle size={18} className='text-muted-foreground' />
									)}
								</div>

								<div className='flex-1 min-w-0'>
									{obj.objective_name && (
										<div className='font-bold text-sm text-foreground mb-0.5'>{obj.objective_name}</div>
									)}
									<div
										className={`text-sm ${obj.status === 'completed' ? 'text-muted-foreground' : 'text-foreground'}`}>
										{obj.description}
									</div>

									{/* Resolution & Session Badges */}
									{(obj.objective_update || obj.completed_session_id) && (
										<div className='mt-2 flex flex-col gap-1'>
											{obj.objective_update && (
												<div className='text-xs text-emerald-700 bg-emerald-100/50 px-2 py-1 rounded border border-emerald-100 italic'>
													"{obj.objective_update}"
												</div>
											)}
											{obj.completed_session_id && (
												<div className='flex items-center gap-1 text-[10px] uppercase font-bold text-muted-foreground'>
													<Calendar size={10} />
													Session: {sessions.find((s) => s.id === obj.completed_session_id)?.title || 'Unknown'}
												</div>
											)}
										</div>
									)}
								</div>

								<div className='flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity'>
									<button
										onClick={() => handleEdit(obj)}
										className='p-2 text-muted-foreground hover:text-blue-600 hover:bg-blue-500/10 rounded-md transition-colors'
										title='Edit Event'>
										<Edit2 size={18} />
									</button>
									<button
										onClick={() => handleDelete(obj.id)}
										className='p-2 text-muted-foreground hover:text-red-600 hover:bg-red-500/10 rounded-md transition-colors'
										title='Delete Event'>
										<Trash2 size={18} />
									</button>
								</div>
							</div>
						)}
					</div>
				))}

				{objectives.length === 0 && !loading && (
					<div className='text-center py-6 text-muted-foreground text-sm italic'>No objectives defined yet.</div>
				)}
			</div>
		</div>
	);
}

--- END OF features\admin\components\QuestObjectiveManager.jsx ---

--- FILE: features\admin\components\RelationshipManager.jsx ---
import React, { useEffect, useState, useMemo } from 'react';
import {
	Trash2,
	Link as LinkIcon,
	ArrowRightLeft,
	ArrowRight,
	Save,
	X,
	Edit2,
	Layers,
	EyeOff,
	Shield,
	Sword,
	MapPin,
	Flag,
	User,
	Users,
	Briefcase,
	BookOpen,
	Gem,
	Calendar,
} from 'lucide-react';
import EntitySearch from '@/features/admin/components/EntitySearch';
import {
	fetchRelationships,
	addRelationship,
	deleteRelationship,
	updateRelationship,
} from '@/features/admin/api/adminService';
import { ADMIN_SECTION_CLASS, ADMIN_HEADER_CLASS, ADMIN_INPUT_CLASS } from './AdminFormStyles';
import Button from '@/shared/components/ui/Button';

// --- CONFIGURATION ---

// 1. Group Headers (By Entity Type)
const ENTITY_GROUPS = {
	character: { label: 'Characters', icon: Users, color: 'text-rose-600', bg: 'bg-rose-50' },
	npc: { label: 'NPCs', icon: User, color: 'text-amber-600', bg: 'bg-amber-500/10' },
	location: { label: 'Locations', icon: MapPin, color: 'text-emerald-600', bg: 'bg-emerald-500/10' },
	faction: { label: 'Factions', icon: Shield, color: 'text-purple-600', bg: 'bg-purple-500/10' },
	quest: { label: 'Quests', icon: Flag, color: 'text-blue-600', bg: 'bg-blue-500/10' },
	session: { label: 'Sessions', icon: BookOpen, color: 'text-slate-600', bg: 'bg-muted/30' },
	item: { label: 'Items', icon: Gem, color: 'text-indigo-600', bg: 'bg-indigo-50' },
	event: { label: 'Events', icon: Calendar, color: 'text-orange-600', bg: 'bg-orange-50' },
	default: { label: 'Other Entities', icon: LinkIcon, color: 'text-muted-foreground', bg: 'bg-muted/30' },
};

const GROUP_ORDER = ['character', 'npc', 'faction', 'location', 'quest', 'item', 'session', 'event'];

// 2. Item Styles (By Relationship Type) - Keeps the "Ally/Enemy" visual context
const REL_STYLES = {
	Ally: { color: 'text-emerald-700', bg: 'bg-emerald-100/50', border: 'border-emerald-400' },
	Friend: { color: 'text-emerald-700', bg: 'bg-emerald-100/50', border: 'border-emerald-400' },
	Enemy: { color: 'text-red-700', bg: 'bg-red-100/50', border: 'border-red-400' },
	Rival: { color: 'text-red-700', bg: 'bg-red-100/50', border: 'border-red-400' },
	Located_In: { color: 'text-amber-700', bg: 'bg-amber-100/50', border: 'border-amber-400' },
	Parent_Location: { color: 'text-amber-700', bg: 'bg-amber-100/50', border: 'border-amber-400' },
	Quest_Giver: { color: 'text-blue-700', bg: 'bg-blue-100/50', border: 'border-blue-400' },
	Participant: { color: 'text-blue-700', bg: 'bg-blue-100/50', border: 'border-blue-400' },
	Generic: { color: 'text-slate-600', bg: 'bg-muted', border: 'border-slate-300' },
};

export default function RelationshipManager({ entityId }) {
	const [relationships, setRelationships] = useState([]);
	const [loading, setLoading] = useState(false);

	// BULK ADD STATE
	const [pendingTargets, setPendingTargets] = useState([]);
	const [type, setType] = useState('Generic');
	const [isBidirectional, setIsBidirectional] = useState(false);
	const [isHidden, setIsHidden] = useState(false);
	const [isAdding, setIsAdding] = useState(false);

	// EDIT STATE
	const [editingId, setEditingId] = useState(null);
	const [editForm, setEditForm] = useState({});

	useEffect(() => {
		if (entityId) loadRelationships();
	}, [entityId]);

	const loadRelationships = async () => {
		setLoading(true);
		try {
			const data = await fetchRelationships(entityId);
			setRelationships(data);
		} catch (e) {
			console.error(e);
		} finally {
			setLoading(false);
		}
	};

	// --- GROUPING LOGIC (By Entity Type) ---
	const grouped = useMemo(() => {
		const groups = {};
		relationships.forEach((rel) => {
			// Group by Target Entity Type (e.g. 'npc', 'location')
			const entityType = rel.target?.type?.toLowerCase() || 'default';
			// Map to config key or fallback
			const groupKey = ENTITY_GROUPS[entityType] ? entityType : 'default';

			if (!groups[groupKey]) groups[groupKey] = [];
			groups[groupKey].push(rel);
		});
		return groups;
	}, [relationships]);

	// --- HANDLERS ---
	const handleSelectTarget = (item) => {
		if (pendingTargets.find((t) => t.id === item.id) || item.id === entityId) return;
		setPendingTargets([...pendingTargets, item]);
	};
	const removePending = (id) => setPendingTargets(pendingTargets.filter((t) => t.id !== id));

	const handleBulkAdd = async () => {
		if (pendingTargets.length === 0) return;
		setIsAdding(true);
		try {
			await Promise.all(
				pendingTargets.map((target) =>
					addRelationship({
						from_entity_id: entityId,
						to_entity_id: target.id,
						relationship_type: type,
						is_bidirectional: isBidirectional,
						is_hidden: isHidden,
					})
				)
			);
			setPendingTargets([]);
			setType('Generic');
			loadRelationships();
		} catch (e) {
			alert('Error: ' + e.message);
		} finally {
			setIsAdding(false);
		}
	};

	const handleUpdate = async () => {
		try {
			await updateRelationship(editingId, {
				relationship_type: editForm.relationship_type,
				is_bidirectional: editForm.is_bidirectional,
				is_hidden: editForm.is_hidden,
			});
			setEditingId(null);
			loadRelationships();
		} catch (e) {
			alert(e.message);
		}
	};

	const handleDelete = async (id) => {
		if (!confirm('Remove link?')) return;
		try {
			await deleteRelationship(id);
			loadRelationships();
		} catch (e) {
			alert(e.message);
		}
	};

	if (!entityId) return null;

	// Dropdown options
	const relationshipTypes = [
		'member_of',
		'leadership_relation',
		'part_of',
		'affiliated_with',
		'family_relation',
		'romantic_relation',
		'professional_relation',
		'located_in',
		'parent_location',
		'residence_relation',
		'workplace_relation',
		'ownership_relation',
		'quest_giver',
		'quest_objective',
		'quest_update',
		'quest_participant',
		'quest_location',
		'hostile_to',
		'knowledge_of',
		'encountered',
	];

	// Helper to get sort order including "Other" groups not in explicit list
	const sortedGroupKeys = [...GROUP_ORDER, ...Object.keys(grouped).filter((k) => !GROUP_ORDER.includes(k))];

	return (
		<div className={ADMIN_SECTION_CLASS}>
			<h2 className={`${ADMIN_HEADER_CLASS} flex items-center gap-2`}>
				<LinkIcon size={18} className='text-amber-600' /> Relationships
			</h2>

			{/* --- ADD NEW SECTION --- */}
			<div className='bg-muted/30 p-4 rounded-lg mb-6 border border-border shadow-sm'>
				<div className='flex items-center justify-between mb-3'>
					<h3 className='text-[10px] font-bold text-muted-foreground uppercase tracking-wider flex items-center gap-2'>
						<Layers size={12} /> Bulk Connect
					</h3>
					{pendingTargets.length > 0 && (
						<span className='text-xs text-amber-600 font-bold bg-amber-500/10 px-2 py-0.5 rounded-full border border-amber-100'>
							{pendingTargets.length} Ready
						</span>
					)}
				</div>

				<div className='space-y-4'>
					<div className='w-full'>
						<EntitySearch onSelect={handleSelectTarget} />
					</div>

					{pendingTargets.length > 0 && (
						<div className='flex flex-wrap gap-2 p-3 bg-background border border-border rounded-md'>
							{pendingTargets.map((t) => (
								<div
									key={t.id}
									className='flex items-center gap-2 bg-amber-500/10 text-amber-900 px-2 py-1 rounded border border-amber-200 text-xs font-medium'>
									<span className='uppercase text-[9px] text-amber-700/60 font-bold'>{t.type}</span>
									<span>{t.name}</span>
									<button onClick={() => removePending(t.id)} className='text-amber-500 hover:text-amber-800'>
										âœ•
									</button>
								</div>
							))}
						</div>
					)}

					<div className='flex flex-col md:flex-row gap-3 items-end pt-2 border-t border-border/50'>
						<div className='flex-1 w-full grid grid-cols-2 gap-4'>
							<div>
								<label className='block text-[10px] uppercase font-bold text-muted-foreground mb-1'>Type</label>
								<select value={type} onChange={(e) => setType(e.target.value)} className={ADMIN_INPUT_CLASS}>
									{relationshipTypes.map((t) => (
										<option key={t} value={t}>
											{t.replace('_', ' ')}
										</option>
									))}
								</select>
							</div>
							<div className='flex flex-col gap-2 pb-1'>
								<label className='flex items-center gap-2 cursor-pointer select-none'>
									<input
										type='checkbox'
										checked={isBidirectional}
										onChange={(e) => setIsBidirectional(e.target.checked)}
										className='w-4 h-4 text-amber-600 rounded focus:ring-amber-500'
									/>
									<span className='text-xs text-muted-foreground font-medium'>2-Way</span>
								</label>
								<label className='flex items-center gap-2 cursor-pointer select-none'>
									<input
										type='checkbox'
										checked={isHidden}
										onChange={(e) => setIsHidden(e.target.checked)}
										className='w-4 h-4 text-amber-600 rounded focus:ring-amber-500'
									/>
									<span className='text-xs text-muted-foreground font-medium flex items-center gap-1'>
										Hidden <EyeOff size={10} />
									</span>
								</label>
							</div>
						</div>
						<Button
							onClick={handleBulkAdd}
							disabled={pendingTargets.length === 0 || isAdding}
							size='sm'
							variant='primary'
							className='w-full md:w-auto min-w-[100px]'>
							{isAdding ? 'Saving...' : `Add ${pendingTargets.length > 0 ? `(${pendingTargets.length})` : ''}`}
						</Button>
					</div>
				</div>
			</div>

			{/* --- LIST SECTION (GROUPED BY ENTITY TYPE) --- */}
			<div className='space-y-6'>
				{relationships.length === 0 && (
					<div className='p-4 text-center text-xs text-muted-foreground italic border border-dashed border-border rounded-lg'>
						No relationships connected.
					</div>
				)}

				{sortedGroupKeys.map((groupKey) => {
					const items = grouped[groupKey];
					if (!items || items.length === 0) return null;

					const groupConfig = ENTITY_GROUPS[groupKey] || ENTITY_GROUPS.default;
					const GroupIcon = groupConfig.icon;

					return (
						<div key={groupKey} className='animate-in fade-in slide-in-from-bottom-2 duration-500'>
							{/* Group Header */}
							<h3
								className={`text-[11px] font-bold uppercase tracking-widest mb-3 border-b border-border/60 pb-1 flex items-center gap-2 ${groupConfig.color} opacity-90`}>
								<GroupIcon size={14} /> {groupConfig.label}
								<span className='ml-auto text-[9px] bg-muted/50 px-1.5 py-0.5 rounded-full text-muted-foreground'>
									{items.length}
								</span>
							</h3>

							<div className='grid grid-cols-1 gap-2'>
								{items.map((rel) => {
									// Item Style based on Relationship Type (Ally/Enemy)
									const style = REL_STYLES[rel.relationship_type] || REL_STYLES.Generic;

									return (
										<div
											key={rel.id}
											className={`group border rounded-lg transition-all bg-background hover:shadow-sm ${
												editingId === rel.id ? 'border-amber-400 ring-1 ring-amber-400' : 'border-border'
											}`}>
											{editingId === rel.id ? (
												/* EDIT MODE */
												<div className='grid grid-cols-[1fr_auto_auto_auto] gap-3 items-center p-2 bg-muted/20'>
													<div className='font-bold text-sm text-foreground truncate min-w-0'>{rel.target?.name}</div>

													<div className='w-36'>
														<select
															className={`${ADMIN_INPUT_CLASS} py-1 h-8 text-xs`}
															value={editForm.relationship_type}
															onChange={(e) => setEditForm({ ...editForm, relationship_type: e.target.value })}>
															{relationshipTypes.map((t) => (
																<option key={t} value={t}>
																	{t.replace('_', ' ')}
																</option>
															))}
														</select>
													</div>

													<div className='flex flex-col gap-1 px-2'>
														<label className='flex items-center gap-1 cursor-pointer'>
															<input
																type='checkbox'
																checked={editForm.is_bidirectional}
																onChange={(e) => setEditForm({ ...editForm, is_bidirectional: e.target.checked })}
															/>
															<span className='text-[10px] uppercase text-muted-foreground'>2-Way</span>
														</label>
														<label className='flex items-center gap-1 cursor-pointer'>
															<input
																type='checkbox'
																checked={editForm.is_hidden}
																onChange={(e) => setEditForm({ ...editForm, is_hidden: e.target.checked })}
															/>
															<span className='text-[10px] uppercase text-muted-foreground'>Hidden</span>
														</label>
													</div>

													<div className='flex gap-1'>
														<Button onClick={handleUpdate} size='sm' variant='primary' icon={Save} className='h-9 px-3'>
															Save
														</Button>
														<Button
															onClick={() => setEditingId(null)}
															size='sm'
															variant='ghost'
															icon={X}
															className='h-9 px-3'>
															Cancel
														</Button>
													</div>
												</div>
											) : (
												/* VIEW MODE */
												<div className={`flex items-center justify-between p-1 pl-0`}>
													<div className='flex items-center gap-3 min-w-0 pl-3'>
														<div className='flex items-center gap-2'>
															<span className='text-sm font-bold text-foreground truncate'>{rel.target?.name}</span>
															{rel.is_hidden && <EyeOff size={14} className='text-muted-foreground/70' title='Hidden' />}
															{rel.is_bidirectional && (
																<ArrowRightLeft size={12} className='text-muted-foreground/50' title='Bidirectional' />
															)}
														</div>
														<div className='flex items-center gap-1.5 mt-0.5'>
															{/* Relationship Type Badge */}
															<span
																className={`text-[10px] font-bold uppercase px-1.5 py-0 rounded-sm ${style.bg} ${style.color} border border-transparent`}>
																{rel.relationship_type.replace('_', ' ')}
															</span>
														</div>
													</div>
													<div className='flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity pr-2'>
														<button
															onClick={() => {
																setEditingId(rel.id);
																setEditForm({
																	relationship_type: rel.relationship_type,
																	is_bidirectional: rel.is_bidirectional,
																	is_hidden: rel.is_hidden,
																});
															}}
															className='p-2 text-muted-foreground hover:text-blue-600 hover:bg-blue-500/10 rounded-md transition-colors'>
															<Edit2 size={18} />
														</button>
														<button
															onClick={() => handleDelete(rel.id)}
															className='p-2 text-muted-foreground hover:text-red-600 hover:bg-red-500/10 rounded-md transition-colors'>
															<Trash2 size={18} />
														</button>
													</div>
												</div>
											)}
										</div>
									);
								})}
							</div>
						</div>
					);
				})}
			</div>
		</div>
	);
}

--- END OF features\admin\components\RelationshipManager.jsx ---

--- FILE: features\admin\components\SessionEventManager.jsx ---
import React, { useEffect, useState } from 'react';
import { Plus, Trash2, Edit2, Save, X, Calendar } from 'lucide-react';
import {
	fetchChildRows,
	upsertSessionEvent,
	deleteRow,
	fetchSessionEventsWithRelationships,
} from '@/features/admin/api/adminService';
import { ADMIN_SECTION_CLASS, ADMIN_HEADER_CLASS, ADMIN_INPUT_CLASS, ADMIN_LABEL_CLASS } from './AdminFormStyles';
import Button from '@/shared/components/ui/Button';
import EventTagger from './EventTagger';

const EVENT_TYPES = [
	'combat',
	'social',
	'quest_started',
	'quest_progressed',
	'travel',
	'location_discovered',
	'location_visited',
	'npc_encountered',
	'faction_discovered',
	'investigation',
	'backstory',
	'discovery',
	'vision',
	'shopping',
	'special_event',
];

export default function SessionEventManager({ sessionId }) {
	const [events, setEvents] = useState([]);
	const [loading, setLoading] = useState(false);
	const [editingId, setEditingId] = useState(null);
	const [formData, setFormData] = useState({});

	useEffect(() => {
		if (sessionId) loadEvents();
	}, [sessionId]);

	const loadEvents = async () => {
		setLoading(true);
		try {
			const data = await fetchSessionEventsWithRelationships(sessionId);
			setEvents(data);
		} catch (e) {
			console.error(e);
		} finally {
			setLoading(false);
		}
	};

	const handleAddNew = () => {
		const nextOrder = events.length > 0 ? Math.max(...events.map((e) => e.event_order || 0)) + 1 : 1;
		const newEvent = {
			id: `new-${Date.now()}`,
			session_id: sessionId,
			title: '',
			description: '',
			event_type: 'travel',
			event_order: nextOrder,
		};
		setEvents([...events, newEvent]);
		handleEdit(newEvent);
	};

	const handleEdit = (event) => {
		setEditingId(event.id);
		setFormData({ ...event });
	};

	const handleSave = async () => {
		try {
			const { relationships, ...payload } = formData;
			await upsertSessionEvent(payload);
			setEditingId(null);
			loadEvents();
		} catch (e) {
			alert('Error saving event: ' + e.message);
		}
	};

	const handleDelete = async (id) => {
		if (!confirm('Delete this event?')) return;
		if (String(id).startsWith('new')) {
			setEvents(events.filter((e) => e.id !== id));
			return;
		}
		try {
			await deleteRow('session_events', id);
			loadEvents();
		} catch (e) {
			alert(e.message);
		}
	};

	return (
		<div className={ADMIN_SECTION_CLASS}>
			<div className={`${ADMIN_HEADER_CLASS} flex items-center justify-between`}>
				<span className='flex items-center gap-2'>
					<Calendar size={18} className='text-amber-600' /> Session Timeline
				</span>
				<Button onClick={handleAddNew} size='sm' variant='secondary' icon={Plus}>
					Add Event
				</Button>
			</div>

			<div className='space-y-3'>
				{events.map((evt) => (
					<div key={evt.id} className='group'>
						{editingId === evt.id ? (
							/* --- EDIT MODE --- */
							<div className='bg-muted/30 border border-amber-300 rounded-lg p-4 space-y-4 animate-in fade-in'>
								<div className='flex gap-3'>
									<div className='w-16'>
										<label className={ADMIN_LABEL_CLASS}>Order</label>
										<input
											type='number'
											className={ADMIN_INPUT_CLASS}
											value={formData.event_order}
											onChange={(e) => setFormData({ ...formData, event_order: parseInt(e.target.value) })}
										/>
									</div>
									<div className='flex-1'>
										<label className={ADMIN_LABEL_CLASS}>Title</label>
										<input
											type='text'
											className={`${ADMIN_INPUT_CLASS} font-bold`}
											autoFocus
											value={formData.title}
											onChange={(e) => setFormData({ ...formData, title: e.target.value })}
										/>
									</div>
									<div className='w-1/3'>
										<label className={ADMIN_LABEL_CLASS}>Type</label>
										<select
											className={ADMIN_INPUT_CLASS}
											value={formData.event_type}
											onChange={(e) => setFormData({ ...formData, event_type: e.target.value })}>
											{EVENT_TYPES.map((t) => (
												<option key={t} value={t}>
													{t.replace(/_/g, ' ')}
												</option>
											))}
										</select>
									</div>
								</div>

								<div>
									<label className={ADMIN_LABEL_CLASS}>Description</label>
									<textarea
										rows={3}
										className={ADMIN_INPUT_CLASS}
										value={formData.description || ''}
										onChange={(e) => setFormData({ ...formData, description: e.target.value })}
									/>
								</div>

								<EventTagger eventId={evt.id} />

								<div className='flex justify-end gap-3 border-t border-border/50 pt-3'>
									<Button
										onClick={() => {
											setEditingId(null);
											loadEvents();
										}}
										variant='ghost'
										icon={X}>
										Cancel
									</Button>
									<Button onClick={handleSave} variant='primary' icon={Save}>
										Save Changes
									</Button>
								</div>
							</div>
						) : (
							/* --- VIEW MODE --- */
							<div className='flex items-start gap-3 p-3 bg-background border border-border rounded-lg hover:border-amber-300 transition-colors'>
								<div className='shrink-0 w-6 h-6 rounded-full bg-muted flex items-center justify-center text-xs font-bold text-muted-foreground border border-border'>
									{evt.event_order}
								</div>
								<div className='flex-1 min-w-0'>
									<div className='flex items-center gap-2 mb-1'>
										<span className='text-[10px] font-bold uppercase tracking-wider px-1.5 py-0.5 bg-muted text-muted-foreground rounded border border-border'>
											{evt.event_type ? evt.event_type.replace(/_/g, ' ') : 'Event'}
										</span>
										<h4 className='font-bold text-sm text-foreground'>{evt.title}</h4>
									</div>
									<p className='text-xs text-muted-foreground line-clamp-2'>{evt.description}</p>
									{evt.relationships && evt.relationships.length > 0 && (
										<div className='flex flex-wrap gap-1.5 mt-1'>
											{evt.relationships.map((rel) => (
												<div
													key={rel.id}
													className='inline-flex items-center gap-1.5 px-1.5 py-0.5 rounded bg-card border border-border text-[10px] text-muted-foreground shadow-sm select-none'>
													<span className='font-medium text-foreground'>{rel.target?.name}</span>
													<span className='text-[9px] opacity-60 uppercase'>{rel.target?.type}</span>
												</div>
											))}
										</div>
									)}
								</div>

								<div className='flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity'>
									<button
										onClick={() => handleEdit(evt)}
										className='p-2 text-muted-foreground hover:text-blue-600 hover:bg-blue-500/10 rounded-md transition-colors'>
										<Edit2 size={18} />
									</button>
									<button
										onClick={() => handleDelete(evt.id)}
										className='p-2 text-muted-foreground hover:text-red-600 hover:bg-red-500/10 rounded-md transition-colors'>
										<Trash2 size={18} />
									</button>
								</div>
							</div>
						)}
					</div>
				))}
			</div>
		</div>
	);
}

--- END OF features\admin\components\SessionEventManager.jsx ---

--- FILE: features\admin\components\SmartImageInput.jsx ---
import React, { useState } from 'react';
import { Image as ImageIcon, X, Link as LinkIcon, Search } from 'lucide-react';
import { ADMIN_INPUT_CLASS } from './AdminFormStyles';
import ImageLibraryModal from './ImageLibraryModal';

const resolvePreviewUrl = (url) => {
	if (!url) return null;
	const cleanPath = url.replace(/(\.\.\/)+/g, '').replace(/^\//, '');
	return `${import.meta.env.BASE_URL}${cleanPath}`;
};

export default function SmartImageInput({ value, onChange, placeholder, ...props }) {
	const [isPickerOpen, setIsPickerOpen] = useState(false);
	const previewUrl = resolvePreviewUrl(value);

	return (
		<div className='space-y-2'>
			<div className='flex gap-2 items-center'>
				<div className='relative flex-1 group'>
					<div className='absolute left-3 top-1/2 -translate-y-1/2 text-muted-foreground/50'>
						<LinkIcon size={14} />
					</div>
					<input
						type='text'
						className={`${ADMIN_INPUT_CLASS} pl-9 pr-20`} // Extra padding for buttons
						placeholder={placeholder || 'images/path/to/file.png'}
						value={value || ''}
						onChange={onChange}
						{...props}
					/>

					{/* Actions inside input */}
					<div className='absolute right-1 top-1/2 -translate-y-1/2 flex items-center gap-0.5'>
						{value && (
							<button
								type='button'
								onClick={() => onChange({ target: { value: '' } })}
								className='p-1.5 text-muted-foreground hover:text-red-500 transition-colors'
								title='Clear'>
								<X size={14} />
							</button>
						)}
						<button
							type='button'
							onClick={() => setIsPickerOpen(true)}
							className='p-1.5 text-amber-600 hover:text-amber-700 hover:bg-amber-500/10 rounded-md transition-all'
							title='Browse Library'>
							<Search size={14} strokeWidth={3} />
						</button>
					</div>
				</div>

				{/* Visual Preview */}
				<div className='shrink-0 w-10 h-10 rounded-lg border border-border bg-card flex items-center justify-center overflow-hidden shadow-sm'>
					{previewUrl ? (
						<img
							src={previewUrl}
							alt='Preview'
							className='w-full h-full object-cover'
							onError={(e) => {
								e.target.style.display = 'none';
							}}
						/>
					) : (
						<ImageIcon size={16} className='text-muted-foreground/20' />
					)}
				</div>
			</div>

			<ImageLibraryModal
				isOpen={isPickerOpen}
				onClose={() => setIsPickerOpen(false)}
				onSelect={(path) => onChange({ target: { value: path } })}
			/>
		</div>
	);
}

--- END OF features\admin\components\SmartImageInput.jsx ---

--- FILE: features\admin\components\TacticalMapManager.jsx ---
/* --- FILE: features/admin/components/TacticalMapManager.jsx --- */
import React, { useState, useEffect } from 'react';
import { MapContainer, ImageOverlay, Marker, useMap, useMapEvents } from 'react-leaflet';
import L from 'leaflet';
import { Map as MapIcon, Trash2, Plus, Target, Save } from 'lucide-react';
import { ADMIN_SECTION_CLASS, ADMIN_HEADER_CLASS, ADMIN_INPUT_CLASS, ADMIN_LABEL_CLASS } from './AdminFormStyles';
import { resolveMarkerIcon } from '@/features/atlas/utils/markerUtils';
import Button from '@/shared/components/ui/Button';

// Click handler component
const MapClickHandler = ({ onMapClick }) => {
	useMapEvents({
		click: (e) => onMapClick(e.latlng),
	});
	return null;
};

const MapController = ({ bounds }) => {
	const map = useMap();
	useEffect(() => {
		if (bounds) map.fitBounds(bounds);
	}, [map, bounds]);
	return null;
};

export default function TacticalMapManager({ imageUrl, value, onChange }) {
	const [markers, setMarkers] = useState([]);
	const [dimensions, setDimensions] = useState(null);
	const [selectedIdx, setSelectedIdx] = useState(null);

	// 1. Load existing markers from JSON string
	useEffect(() => {
		if (value) {
			try {
				const parsed = typeof value === 'string' ? JSON.parse(value) : value;
				setMarkers(Array.isArray(parsed) ? parsed : []);
			} catch (e) {
				setMarkers([]);
			}
		}
	}, [value]);

	// 2. Handle Image Dimensions
	useEffect(() => {
		if (!imageUrl) return;
		const img = new Image();
		img.src = imageUrl;
		img.onload = () => {
			const h = img.height;
			const w = img.width;
			setDimensions(L.latLngBounds([-h, 0], [0, w]));
		};
	}, [imageUrl]);

	const handleMapClick = (latlng) => {
		const newMarker = {
			lat: Math.round(latlng.lat),
			lng: Math.round(latlng.lng),
			label: 'New Marker',
			category: 'default',
		};
		const updated = [...markers, newMarker];
		setMarkers(updated);
		setSelectedIdx(updated.length - 1);
		onChange(JSON.stringify(updated));
	};

	const updateMarker = (idx, fields) => {
		const updated = [...markers];
		updated[idx] = { ...updated[idx], ...fields };
		setMarkers(updated);
		onChange(JSON.stringify(updated));
	};

	const removeMarker = (idx) => {
		const updated = markers.filter((_, i) => i !== idx);
		setMarkers(updated);
		setSelectedIdx(null);
		onChange(JSON.stringify(updated));
	};

	if (!imageUrl || !dimensions) return null;

	return (
		<div className={ADMIN_SECTION_CLASS}>
			<div className={ADMIN_HEADER_CLASS}>
				<span className='flex items-center gap-2'>
					<Target size={18} className='text-primary' /> Marker Editor
				</span>
				<span className='text-[10px] text-muted-foreground uppercase tracking-widest'>Click map to add</span>
			</div>

			<div className='grid grid-cols-1 lg:grid-cols-3 gap-6'>
				{/* Visual Map Area */}
				<div className='lg:col-span-2 h-[400px] rounded-lg border border-border overflow-hidden bg-muted relative z-0'>
					<MapContainer
						crs={L.CRS.Simple}
						bounds={dimensions}
						zoom={0}
						attributionControl={false}
						style={{ height: '100%', width: '100%', background: 'var(--background)' }}>
						<MapController bounds={dimensions} />
						<MapClickHandler onMapClick={handleMapClick} />
						<ImageOverlay url={imageUrl} bounds={dimensions} />

						{markers.map((m, i) => (
							<Marker
								key={i}
								position={[m.lat, m.lng]}
								icon={resolveMarkerIcon(m)}
								eventHandlers={{ click: () => setSelectedIdx(i) }}
							/>
						))}
					</MapContainer>
				</div>

				{/* Sidebar Editor */}
				<div className='space-y-4'>
					<div className='max-h-[400px] overflow-y-auto pr-2 space-y-3 custom-scrollbar'>
						{markers.length === 0 && (
							<div className='text-center py-10 text-xs text-muted-foreground italic border-2 border-dashed border-border rounded-lg'>
								No markers yet. Click the map to start.
							</div>
						)}
						{markers.map((m, i) => (
							<div
								key={i}
								className={`p-3 rounded-lg border transition-all ${
									selectedIdx === i ? 'border-accent bg-accent/5 ring-1 ring-accent' : 'border-border bg-background'
								}`}
								onClick={() => setSelectedIdx(i)}>
								<div className='flex justify-between items-start mb-2'>
									<span className='text-[10px] font-bold text-muted-foreground uppercase'>Marker #{i + 1}</span>
									<button onClick={() => removeMarker(i)} className='text-muted-foreground hover:text-red-600'>
										<Trash2 size={14} />
									</button>
								</div>
								<div className='space-y-2'>
									<input
										className={ADMIN_INPUT_CLASS}
										value={m.label}
										onChange={(e) => updateMarker(i, { label: e.target.value })}
										placeholder='Label...'
									/>
									<select
										className={ADMIN_INPUT_CLASS}
										value={m.category}
										onChange={(e) => updateMarker(i, { category: e.target.value })}>
										<option value='default'>Default Pin</option>
										<option value='combat'>Combat / Danger</option>
										<option value='city'>City / Settlement</option>
										<option value='npc'>NPC / Person</option>
										<option value='magic'>Magic / Mystery</option>
										<option value='quest'>Objective</option>
										<option value='location'>Location</option>
									</select>
									<div className='flex gap-2 text-[9px] font-mono text-muted-foreground'>
										<span>LAT: {m.lat}</span>
										<span>LNG: {m.lng}</span>
									</div>
								</div>
							</div>
						))}
					</div>
				</div>
			</div>
		</div>
	);
}

--- END OF features\admin\components\TacticalMapManager.jsx ---

--- FILE: features\admin\config\adminStrategies.js ---
export const ADMIN_STRATEGIES = {
	// 0. CAMPAIGN (Meta Entity)
	campaign: {
		label: 'Campaign',
		type: 'campaign',
		primaryTable: 'campaigns',
		colMapping: { name: 'name', description: 'description' },
		hasNarrative: true, // Use Markdown for description
		defaultAttributes: [
			{ key: 'campaign_id', label: 'Campaign ID (Integer)', type: 'number' }, // Required by your schema
			{ key: 'map_data', label: 'Map Data (JSON)', type: 'text' }, // Advanced: map config
		],
	},

	// 1. NPC
	npc: {
		label: 'NPC',
		type: 'npc',
		primaryTable: 'npcs',
		colMapping: { name: 'name', description: 'description' },
		hasNarrative: true,
		defaultAttributes: [
			{ key: 'race', label: 'Race/Ancestry', type: 'text' },
			{ key: 'class', label: 'Class/Occupation', type: 'text' },
			{ key: 'affinity', label: 'Affinity', type: 'select', options: ['Ally', 'Neutral', 'Enemy', 'Unknown'] },
			{ key: 'status', label: 'Status', type: 'text' },
			{ key: 'icon', label: 'Icon URL', type: 'image' },
		],
	},

	// 2. LOCATION
	location: {
		label: 'Location',
		type: 'location',
		primaryTable: 'locations',
		colMapping: { name: 'name', description: 'description' },
		hasNarrative: true,
		defaultAttributes: [
			{ key: 'type', label: 'Type', type: 'text' },
			{ key: 'background_image', label: 'Background Image', type: 'image' },
			{ key: 'map_image', label: 'Map Image', type: 'image' },
		],
	},

	// 3. SESSION
	session: {
		label: 'Session',
		type: 'session',
		primaryTable: 'sessions',
		colMapping: { name: 'title', description: 'narrative' },
		hasNarrative: true,
		defaultAttributes: [
			{ key: 'session_number', label: 'Session Number', type: 'number' },
			{ key: 'session_date', label: 'In-Game Date', type: 'text' },
		],
	},

	// 4. QUEST
	quest: {
		label: 'Quest',
		type: 'quest',
		primaryTable: 'quests',
		colMapping: { name: 'title', description: 'description' },
		hasNarrative: true,
		defaultAttributes: [
			{ key: 'status', label: 'Status', type: 'select', options: ['Active', 'Completed', 'Failed', 'Pending'] },
			{
				key: 'quest type',
				label: 'Quest Type',
				type: 'select',
				options: ['Main Quest', 'Side Quest', 'Personal Quest'],
			},
			{ key: 'priority', label: 'Priority', type: 'select', options: ['Critical', 'High', 'Medium', 'Low', 'Trivial'] },
		],
	},

	// 5. FACTION
	faction: {
		label: 'Faction',
		type: 'faction',
		primaryTable: 'factions',
		colMapping: { name: 'name', description: 'description' },
		hasNarrative: true,
		defaultAttributes: [
			{ key: 'leader', label: 'Leader', type: 'text' },
			{ key: 'affinity', label: 'Affinity', type: 'select', options: ['Ally', 'Neutral', 'Enemy'] },
			{ key: 'icon', label: 'Icon URL', type: 'image' },
		],
	},

	// 6. ITEM
	item: {
		label: 'Item',
		type: 'item',
		primaryTable: 'items',
		colMapping: { name: 'name', description: 'description' },
		defaultAttributes: [
			{
				key: 'type',
				label: 'Type',
				type: 'select',
				options: ['Weapon', 'Armor', 'Potion', 'Scroll', 'Wondrous Item', 'Key Item', 'Treasure'],
			},
			{
				key: 'rarity',
				label: 'Rarity',
				type: 'select',
				options: ['Common', 'Uncommon', 'Rare', 'Very Rare', 'Legendary', 'Artifact'],
			},
			{ key: 'value', label: 'Gold Value', type: 'text' },
			{ key: 'attunement', label: 'Attunement?', type: 'select', options: ['Yes', 'No'] },
			{ key: 'icon', label: 'Icon URL', type: 'image' },
		],
	},

	// 7. CHARACTER (The Party)
	character: {
		label: 'Character',
		type: 'character',
		primaryTable: 'characters',
		// 'background' is usually the column name for description in D&D schemas
		// If your table uses 'description', change 'background' to 'description'
		colMapping: { name: 'name', description: 'description' },
		hasNarrative: true,
		defaultAttributes: [
			{ key: 'race', label: 'Race', type: 'text' },
			{ key: 'class', label: 'Class', type: 'text' },
			{ key: 'level', label: 'Level', type: 'number' },
			{ key: 'speed', label: 'Speed', type: 'text' },
			{ key: 'hit points', label: 'Hit Points', type: 'text' },
			{ key: 'armor class', label: 'Armor Class', type: 'text' },
			{ key: 'icon', label: 'Icon URL', type: 'image' },
		],
	},

	// 8. ENCOUNTER
	encounter: {
		label: 'Encounter',
		type: 'encounter',
		primaryTable: 'encounters',
		colMapping: { name: 'name', description: 'description' },
		hasNarrative: true,
		defaultAttributes: [
			{
				key: 'status',
				label: 'Status',
				type: 'select',
				options: ['Planned', 'In Progress', 'Completed', 'Skipped'],
			},
			{ key: 'background_image', label: 'Background Image', type: 'image' },
			{ key: 'map_image', label: 'Map Image', type: 'image' },
		],
	},

	default: {
		label: 'Entity',
		primaryTable: 'entities',
		colMapping: { name: 'name', description: 'description' },
		defaultAttributes: [
			{ key: 'type', label: 'Type', type: 'text' },
			{ key: 'map_image', label: 'Tactical Map Image', type: 'image' }, // Added this
			{ key: 'background_image', label: 'Header Background', type: 'image' },
		],
	},
};

export const getStrategy = (type) => {
	return ADMIN_STRATEGIES[type] || ADMIN_STRATEGIES.default;
};

--- END OF features\admin\config\adminStrategies.js ---

--- FILE: features\admin\config\imageLibrary.js ---
export const IMAGE_LIBRARY = [
	{
		category: 'Icons',
		path: 'images/icons/',
		// Example list: In a real app, you can generate this JSON via a script
		// or just list your primary D&D icons here.
		files: ['npc.png', 'location.png', 'quest.png', 'faction.png', 'encounter.png', 'item.png'],
	},
	{
		category: 'Backgrounds',
		path: 'images/backgrounds/',
		files: ['forest.jpg', 'dungeon.jpg', 'city.jpg', 'tavern.jpg', 'map_parchment.jpg'],
	},
	{
		category: 'Tokens',
		path: 'images/tokens/',
		files: ['party_token.png', 'enemy_token.png'],
	},
];

--- END OF features\admin\config\imageLibrary.js ---

--- FILE: features\admin\config\imageManifest.json ---
[
  {
    "category": "Assets > Character_backgrounds > Campaign_002",
    "path": "images/assets/character_backgrounds/campaign_002/",
    "files": [
      "bonnie_bg.jpeg",
      "kaedin_bg.jpg",
      "olek_bg.jpg",
      "soshi_bg.jpeg"
    ]
  },
  {
    "category": "Assets > Character_thumbnails > Campaign_001",
    "path": "images/assets/character_thumbnails/campaign_001/",
    "files": [
      "aenwyn.jpeg",
      "aethere.jpeg",
      "alezander.jpeg",
      "nora.png",
      "samantha.jpeg",
      "smasherina.jpg"
    ]
  },
  {
    "category": "Assets > Character_thumbnails > Campaign_002",
    "path": "images/assets/character_thumbnails/campaign_002/",
    "files": [
      "bonnie.jpeg",
      "kaedin.jpeg",
      "norr.jpeg",
      "olek.jpeg",
      "soshi.jpeg"
    ]
  },
  {
    "category": "Assets > Encounter_backgrounds > Campaign_002",
    "path": "images/assets/encounter_backgrounds/campaign_002/",
    "files": [
      "demonic_ambush_bg.jpg",
      "hydra_encounter_bg.jpg",
      "thylacoleo_ambush_bg.jpg"
    ]
  },
  {
    "category": "Assets > Location_backgrounds > Campaign_002",
    "path": "images/assets/location_backgrounds/campaign_002/",
    "files": [
      "avarthel_grove_bg.jpg",
      "drellin_ferry_bg.jpg",
      "grackledorn_bg.jpg",
      "neverwinter_bg.jpg",
      "strategic_bridge.jpg",
      "underground_temple_complex.jpg",
      "wrath_keep_bg.jpg"
    ]
  },
  {
    "category": "Assets > Map_backgrounds",
    "path": "images/assets/map_backgrounds/",
    "files": [
      "brindol_map.jpg",
      "demonic_ambush_map.png",
      "drellin_ferry_map.png",
      "elsir_vale_map.png",
      "strategic_bridge_map.png",
      "vraath_courtyard_map.png",
      "witchwood_map.jpg"
    ]
  },
  {
    "category": "Assets > Map_backgrounds > Backups",
    "path": "images/assets/map_backgrounds/backups/",
    "files": [
      "drellin_ferry_map.jpg",
      "elsir_vale_map.jpg"
    ]
  },
  {
    "category": "Assets > Npc_backgrounds > Campaign_002",
    "path": "images/assets/npc_backgrounds/campaign_002/",
    "files": [
      "avarthel_bg.jpg",
      "soranna_bg.jpg",
      "yoghurt_bg.jpg"
    ]
  },
  {
    "category": "General",
    "path": "images/",
    "files": [
      "background_texture.png"
    ]
  },
  {
    "category": "Icons",
    "path": "images/icons/",
    "files": [
      "avian.png",
      "bonnie.png",
      "deity.png",
      "dwarf.png",
      "earth_genasi.png",
      "elemental.png",
      "encounter.png",
      "faction.png",
      "feline.png",
      "female.png",
      "gnome.png",
      "goblin.png",
      "hobgoblin.png",
      "kaedin.png",
      "location.png",
      "male.png",
      "monster.png",
      "norr.png",
      "ogre.png",
      "olek.png",
      "other.png",
      "party.png",
      "phoenix.png",
      "quest.png",
      "quickling.png",
      "rat.png",
      "session.png",
      "soshi.png",
      "tabaxi.png",
      "unknown.png"
    ]
  },
  {
    "category": "Overlays > Korinis_island",
    "path": "images/overlays/korinis_island/",
    "files": [
      "korinis_island_penal_colony_chapel.png",
      "korinis_island_penal_colony_merchants_cave.png",
      "korinis_island_penal_colony_mine_cave.png",
      "korinis_island_penal_colony_mine_cave_v2.png",
      "korinis_island_penal_colony_paladin_barracks.png",
      "korinis_island_penal_colony_spider_cave.png"
    ]
  }
]
--- END OF features\admin\config\imageManifest.json ---

--- FILE: features\admin\layouts\AdminLayout.jsx ---
import React from 'react';
import { Outlet, Link, useLocation, useNavigate } from 'react-router-dom';
import { clsx } from 'clsx';
import {
	Database,
	Users,
	MapPin,
	BookOpen,
	Scroll,
	ArrowLeft,
	Shield,
	Gem,
	LogOut,
	Play,
	Sword,
	Replace,
} from 'lucide-react';
import { useCampaign } from '@/features/campaign/CampaignContext';

const NavItem = ({ to, icon: Icon, label }) => {
	// ... (existing code) ...
	const location = useLocation();
	const isActive = location.pathname.includes(to);

	return (
		<Link
			to={to}
			className={clsx(
				'flex items-center gap-2 px-3 py-1.5 text-sm font-medium rounded-md transition-all duration-200',
				isActive
					? 'bg-amber-100 text-amber-900 shadow-sm ring-1 ring-amber-200'
					: 'text-muted-foreground hover:bg-muted/80 hover:text-foreground'
			)}>
			<Icon size={15} className={isActive ? 'text-amber-700' : 'opacity-70'} />
			{label}
		</Link>
	);
};

export default function AdminLayout() {
	const { campaignId, setCampaignId } = useCampaign();
	const navigate = useNavigate();

	// ... (existing handleSwitch logic) ...
	const handleSwitch = () => {
		if (confirm('Go to Campaign Selection screen?')) {
			setCampaignId(null);
			navigate('/select-campaign');
		}
	};

	return (
		<div className='flex h-screen bg-muted/30 text-foreground overflow-hidden font-sans'>
			{/* Sidebar */}
			<aside className='w-56 bg-background border-r border-border flex flex-col shrink-0'>
				{/* ... (existing sidebar content) ... */}
				<div className='p-4 border-b border-border bg-muted/20'>
					<div className='flex items-center gap-2 text-amber-700'>
						<div className='p-1.5 bg-amber-100 rounded-md'>
							<Database size={18} />
						</div>
						<h2 className='font-serif font-bold text-lg leading-none'>DM Console</h2>
					</div>
				</div>

				<nav className='flex-1 p-3 space-y-0.5 overflow-y-auto'>
					{/* ... (existing nav items) ... */}
					<div className='px-3 py-2 text-[10px] font-bold uppercase tracking-widest text-muted-foreground/60'>
						System
					</div>
					<NavItem to='/dm/manage/campaign' icon={Database} label='Campaigns' />
					<NavItem to='/dm/tools/replace' icon={Replace} label='Find & Replace' />

					<div className='mt-4 px-3 py-2 text-[10px] font-bold uppercase tracking-widest text-muted-foreground/60'>
						Entities
					</div>
					<NavItem to='/dm/manage/character' icon={Users} label='Characters' />
					<NavItem to='/dm/manage/npc' icon={Users} label='NPCs' />
					<NavItem to='/dm/manage/location' icon={MapPin} label='Locations' />
					<NavItem to='/dm/manage/faction' icon={Shield} label='Factions' />
					<NavItem to='/dm/manage/item' icon={Gem} label='Items' />
					<NavItem to='/dm/manage/encounter' icon={Sword} label='Encounters' />

					<div className='mt-4 px-3 py-2 text-[10px] font-bold uppercase tracking-widest text-muted-foreground/60'>
						Campaign
					</div>
					<NavItem to='/dm/manage/session' icon={BookOpen} label='Sessions' />
					<NavItem to='/dm/manage/quest' icon={Scroll} label='Quests' />
				</nav>

				<div className='p-3 border-t border-border space-y-1'>
					{/* ... (existing footer buttons) ... */}
					{campaignId && (
						<Link
							to='/'
							className='flex items-center gap-2 w-full px-3 py-2 text-xs font-bold uppercase tracking-wide text-emerald-700 hover:bg-emerald-500/10 rounded-md transition-colors'
							title={`Return to Campaign ID: ${campaignId}`}>
							<Play size={14} /> Enter Campaign
						</Link>
					)}

					<button
						onClick={handleSwitch}
						className='flex items-center gap-2 w-full px-3 py-2 text-xs font-bold uppercase tracking-wide text-muted-foreground hover:text-red-600 hover:bg-red-500/10 rounded-md transition-colors text-left'>
						<LogOut size={14} /> Campaign Select
					</button>
				</div>
			</aside>

			{/* Main Content */}
			<main className='flex-1 h-full overflow-y-auto bg-muted/10 custom-scrollbar'>
				<div className='mx-auto'>
					<Outlet />
				</div>
			</main>
		</div>
	);
}

--- END OF features\admin\layouts\AdminLayout.jsx ---

--- FILE: features\admin\pages\BulkReplaceTool.jsx ---
import React, { useState } from 'react';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { getBulkReplacePreview, executeBulkReplace } from '@/features/admin/api/adminService';
import {
	ADMIN_SECTION_CLASS,
	ADMIN_HEADER_CLASS,
	ADMIN_INPUT_CLASS,
	ADMIN_LABEL_CLASS,
} from '@/features/admin/components/AdminFormStyles';
import Button from '@/shared/components/ui/Button';
import { Replace, Eye, ArrowRight, CheckCircle2, AlertCircle, Loader2 } from 'lucide-react';
import { useQueryClient } from '@tanstack/react-query';

export default function BulkReplaceTool() {
	const { campaignId } = useCampaign();
	const queryClient = useQueryClient();
	const [find, setFind] = useState('');
	const [replace, setReplace] = useState('');
	const [preview, setPreview] = useState(null); // null, [], or items
	const [isProcessing, setIsProcessing] = useState(false);

	const handlePreview = async () => {
		setIsProcessing(true);
		const matches = await getBulkReplacePreview(campaignId, find, replace);
		setPreview(matches);
		setIsProcessing(false);
	};

	const handleConfirm = async () => {
		if (!confirm(`Apply all ${preview.length} changes?`)) return;
		setIsProcessing(true);
		await executeBulkReplace(preview);
		queryClient.invalidateQueries();
		alert('Archive successfully patched.');
		setPreview(null);
		setFind('');
		setReplace('');
		setIsProcessing(false);
	};

	return (
		<div className='max-w-4xl mx-auto p-6 space-y-6'>
			<div className={ADMIN_SECTION_CLASS}>
				<h2 className={ADMIN_HEADER_CLASS}>
					<span className='flex items-center gap-2'>
						<Replace size={18} className='text-amber-600' /> Archive Patch Tool
					</span>
				</h2>

				<div className='grid grid-cols-1 md:grid-cols-2 gap-4'>
					<div>
						<label className={ADMIN_LABEL_CLASS}>Search Term</label>
						<input
							className={ADMIN_INPUT_CLASS}
							value={find}
							onChange={(e) => setFind(e.target.value)}
							placeholder='Misspelled word...'
						/>
					</div>
					<div>
						<label className={ADMIN_LABEL_CLASS}>Replacement</label>
						<input
							className={ADMIN_INPUT_CLASS}
							value={replace}
							onChange={(e) => setReplace(e.target.value)}
							placeholder='Proper word...'
						/>
					</div>
				</div>

				<div className='pt-2'>
					<Button
						variant='primary'
						fullWidth
						icon={isProcessing ? Loader2 : Eye}
						disabled={isProcessing || !find.trim()}
						onClick={handlePreview}>
						{isProcessing ? 'Scanning...' : 'Scan for Matches'}
					</Button>
				</div>
			</div>

			{preview && (
				<div className={`${ADMIN_SECTION_CLASS} animate-in slide-in-from-bottom-4`}>
					<div className={ADMIN_HEADER_CLASS}>
						<span>Review Proposed Changes ({preview.length})</span>
						<Button size='sm' variant='danger' icon={Replace} onClick={handleConfirm} disabled={preview.length === 0}>
							Apply All Updates
						</Button>
					</div>

					{preview.length === 0 ? (
						<div className='text-center py-10 text-muted-foreground italic'>No matches found in the archives.</div>
					) : (
						<div className='border border-border rounded-lg overflow-hidden bg-background'>
							<table className='w-full text-[11px] text-left border-collapse'>
								<thead className='bg-muted text-muted-foreground font-bold uppercase tracking-wider'>
									<tr>
										<th className='p-3 border-b border-border'>Context / Source</th>
										<th className='p-3 border-b border-border'>Change Preview</th>
									</tr>
								</thead>
								<tbody className='divide-y divide-border'>
									{preview.map((item, idx) => (
										<tr key={idx} className='hover:bg-muted/30'>
											<td className='p-3 align-top font-bold text-muted-foreground w-1/3'>
												<div className='uppercase text-[9px] opacity-50 mb-1'>
													{item.table}.{item.field}
												</div>
												{item.context}
											</td>
											<td className='p-3 space-y-1'>
												<div className='text-red-600 line-through opacity-60 bg-red-500/10 p-1 rounded'>
													{item.original}
												</div>
												<div className='flex items-center gap-2 text-emerald-700 font-medium bg-emerald-500/10 p-1 rounded'>
													<ArrowRight size={10} /> {item.proposal}
												</div>
											</td>
										</tr>
									))}
								</tbody>
							</table>
						</div>
					)}
				</div>
			)}
		</div>
	);
}

--- END OF features\admin\pages\BulkReplaceTool.jsx ---

--- FILE: features\admin\pages\EntityEditorPage.jsx ---
import React from 'react';
import { useParams } from 'react-router-dom';
import AdminForm from '@/features/admin/components/AdminForm'; // Import the form

export default function EntityEditorPage() {
	const { type, id } = useParams();

	return (
		<div className='max-w-5xl mx-auto'>
			{/* Page Header */}
			<div className='mb-6'>
				<h1 className='text-2xl font-serif font-bold text-foreground capitalize'>
					{id ? `Edit ${type}` : `Create New ${type}`}
				</h1>
				<p className='text-sm text-muted-foreground'>
					{id ? `ID: ${id}` : 'Fill in the details below to create a new entry.'}
				</p>
			</div>

			{/* The Dynamic Form */}
			<AdminForm
				type={type}
				id={id}
				key={`${type}-${id || 'new'}`} // <--- This forces a complete rebuild when type changes
			/>
		</div>
	);
}

--- END OF features\admin\pages\EntityEditorPage.jsx ---

--- FILE: features\admin\pages\EntityListPage.jsx ---
import React, { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Link, useParams, useNavigate } from 'react-router-dom';
import { Edit, Plus, Search, Loader2, Copy, Trash2 } from 'lucide-react';
import { getEntities } from '@/domain/entity/api/entityService';
import { createEntity, fetchRawEntity, deleteEntity } from '@/features/admin/api/adminService';
import { useCampaign } from '@/features/campaign/CampaignContext';
import Button from '@/shared/components/ui/Button';
import EntityBadge from '@/domain/entity/components/EntityBadge';

export default function EntityListPage() {
	const { type } = useParams();
	const navigate = useNavigate();
	const { campaignId } = useCampaign();
	const [search, setSearch] = useState('');
	const [isCloning, setIsCloning] = useState(null);
	const [isDeleting, setIsDeleting] = useState(null);

	const normalizedType = type === 'sessions' ? 'session' : type;

	const { data, isLoading, refetch } = useQuery({
		queryKey: ['admin-list', campaignId, normalizedType],
		queryFn: () => getEntities(campaignId, normalizedType),
		enabled: !!campaignId,
	});

	const filtered = (data || []).filter((item) =>
		(item.name || item.title || '').toLowerCase().includes(search.toLowerCase())
	);

	// ... (Handlers handleDuplicate and handleDelete remain same) ...
	const handleDuplicate = async (originalId) => {
		if (!confirm('Create a copy of this entity?')) return;
		setIsCloning(originalId);
		try {
			const raw = await fetchRawEntity(normalizedType, originalId);
			const copyData = {
				...raw,
				name: raw.name ? `${raw.name} (Copy)` : undefined,
				title: raw.title ? `${raw.title} (Copy)` : undefined,
				campaign_id: campaignId,
			};
			const result = await createEntity(normalizedType, copyData);
			navigate(`/dm/editor/${normalizedType}/${result.id}`);
		} catch (e) {
			console.error('Duplication failed:', e);
			alert('Failed to duplicate: ' + e.message);
			setIsCloning(false);
		}
	};

	const handleDelete = async (id) => {
		if (!confirm(`Are you sure you want to delete this ${normalizedType}? This cannot be undone.`)) return;
		setIsDeleting(id);
		try {
			await deleteEntity(normalizedType, id);
			refetch();
		} catch (e) {
			alert('Delete failed: ' + e.message);
		} finally {
			setIsDeleting(null);
		}
	};

	return (
		<div className='space-y-4 animate-in fade-in duration-300'>
			{/* Header Toolbar */}
			<div className='flex flex-col sm:flex-row sm:items-center justify-between gap-4'>
				<h1 className='text-2xl font-serif font-bold text-foreground capitalize flex items-center gap-2'>
					{type}s
					<span className='text-sm font-sans font-normal text-muted-foreground bg-muted px-2 py-0.5 rounded-full border border-border'>
						{data?.length || 0}
					</span>
				</h1>
				<Link to={`/dm/editor/${normalizedType}`}>
					<Button variant='primary' icon={Plus} size='sm'>
						Create New
					</Button>
				</Link>
			</div>

			{/* Search Bar */}
			<div className='relative'>
				<Search className='absolute left-3 top-2.5 text-muted-foreground/60' size={16} />
				<input
					type='text'
					placeholder={`Filter ${type}s...`}
					value={search}
					onChange={(e) => setSearch(e.target.value)}
					className='w-full pl-9 pr-4 py-2 bg-background border border-border rounded-lg text-sm text-foreground focus:outline-none focus:ring-1 focus:ring-amber-500 shadow-sm placeholder:text-muted-foreground/50'
				/>
			</div>

			{/* Entity List */}
			<div className='bg-background border border-border rounded-lg shadow-sm overflow-hidden'>
				<div className='divide-y divide-border'>
					{isLoading ? (
						<div className='p-12 flex justify-center text-muted-foreground'>
							<Loader2 className='animate-spin text-amber-600' />
						</div>
					) : filtered.length === 0 ? (
						<div className='p-12 text-center text-muted-foreground text-sm italic bg-muted/10'>
							{search ? `No matches for "${search}"` : `No ${type}s found. Create one to get started.`}
						</div>
					) : (
						filtered.map((item) => (
							<div
								key={item.id}
								// CHANGED: Added virtual-list-item class for CSS native virtualization
								className='virtual-list-item group flex items-center justify-between p-3 hover:bg-muted/40 transition-colors'>
								{/* Left: Info */}
								<div className='flex items-center gap-3 min-w-0 flex-1'>
									<div className='min-w-0'>
										<div className='flex items-center gap-2'>
											<span className='font-medium text-sm text-foreground truncate'>{item.name || item.title}</span>
											{item.type !== normalizedType && <EntityBadge type={item.type} size='sm' variant='subtle' />}
										</div>
										<div className='text-[11px] text-muted-foreground truncate max-w-xl'>
											{item.summary || item.narrative || item.description || 'No description'}
										</div>
									</div>
								</div>

								{/* Right: Actions */}
								<div className='flex items-center gap-2 shrink-0 ml-4 opacity-100 sm:opacity-0 sm:group-hover:opacity-100 transition-opacity'>
									<EntityBadge
										type={item.type}
										size='sm'
										variant='outline'
										className='opacity-50 hidden sm:inline-flex'
									/>
									<button
										onClick={() => handleDuplicate(item.id)}
										disabled={isCloning === item.id}
										className='p-1.5 text-muted-foreground hover:text-amber-600 hover:bg-amber-500/10 rounded-md transition-colors focus:outline-none focus:ring-1 focus:ring-amber-500'
										title='Duplicate'>
										{isCloning === item.id ? (
											<Loader2 size={16} className='animate-spin text-amber-600' />
										) : (
											<Copy size={16} />
										)}
									</button>
									<Link to={`/dm/editor/${normalizedType}/${item.id}`}>
										<Button
											variant='ghost'
											size='sm'
											icon={Edit}
											className='h-8 px-2 text-muted-foreground hover:text-foreground'>
											Edit
										</Button>
									</Link>
									<button
										onClick={() => handleDelete(item.id)}
										disabled={isDeleting === item.id}
										className='p-1.5 text-muted-foreground hover:text-red-600 hover:bg-red-500/10 rounded-md transition-colors'
										title='Delete'>
										{isDeleting === item.id ? <Loader2 size={16} className='animate-spin' /> : <Trash2 size={16} />}
									</button>
								</div>
							</div>
						))
					)}
				</div>
			</div>
		</div>
	);
}

--- END OF features\admin\pages\EntityListPage.jsx ---

--- FILE: features\admin\pages\SplitPaneManager.jsx ---
import React, { useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { Plus, Search, Loader2, Copy, Trash2 } from 'lucide-react';
import { getEntities } from '@/domain/entity/api/entityService';
import { createEntity, fetchRawEntity, deleteEntity } from '@/features/admin/api/adminService';
import { useCampaign } from '@/features/campaign/CampaignContext';
import AdminForm from '@/features/admin/components/AdminForm';
import Button from '@/shared/components/ui/Button';

export default function SplitPaneManager() {
	const { type, id } = useParams();
	const navigate = useNavigate();
	const { campaignId } = useCampaign();
	const [search, setSearch] = useState('');

	// Action States
	const [isCloning, setIsCloning] = useState(null);
	const [isDeleting, setIsDeleting] = useState(null);

	const normalizedType = type === 'sessions' ? 'session' : type;

	// 1. Fetch List Data
	const {
		data: entities,
		isLoading,
		refetch,
	} = useQuery({
		queryKey: ['admin-list', campaignId, normalizedType],
		queryFn: () => getEntities(campaignId, normalizedType),
		enabled: normalizedType === 'campaign' || !!campaignId,
	});

	const filtered = (entities || []).filter((item) =>
		(item.name || item.title || '').toLowerCase().includes(search.toLowerCase())
	);

	// --- ACTIONS ---

	const handleDuplicate = async (originalId, e) => {
		e.stopPropagation(); // Prevent navigation
		if (!confirm('Create a copy?')) return;

		setIsCloning(originalId);
		try {
			const raw = await fetchRawEntity(normalizedType, originalId);
			// Fix: Check for attributesList vs attributes object structure from fetchRawEntity
			// fetchRawEntity returns { ..., attributes: {...} } OR { ..., attributesList: [...] } depending on version
			// The service handles formatting for createEntity, we just need to modify the name.

			const copyData = {
				...raw,
				name: raw.name ? `${raw.name} (Copy)` : undefined,
				title: raw.title ? `${raw.title} (Copy)` : undefined,
				campaign_id: campaignId,
			};

			// If ID exists in raw data, remove it so DB creates new one
			delete copyData.id;

			const result = await createEntity(normalizedType, copyData);
			refetch(); // Refresh list
			navigate(`/dm/manage/${normalizedType}/${result.id}`);
		} catch (e) {
			alert('Failed to duplicate: ' + e.message);
		} finally {
			setIsCloning(false);
		}
	};

	const handleDelete = async (itemId, e) => {
		e.stopPropagation(); // Prevent navigation
		if (!confirm('Delete this entry?')) return;

		setIsDeleting(itemId);
		try {
			await deleteEntity(normalizedType, itemId);
			refetch();
			// If we deleted the currently selected item, go back to "Create New"
			if (id === itemId) {
				navigate(`/dm/manage/${normalizedType}`);
			}
		} catch (e) {
			alert('Delete failed: ' + e.message);
		} finally {
			setIsDeleting(null);
		}
	};

	return (
		<div className='flex h-[100vh] overflow-hidden bg-muted/10'>
			{/* --- LEFT PANE: LIST --- */}
			<div className='w-80 flex flex-col border-r border-border bg-background shrink-0 shadow-sm z-10'>
				{/* Header & Search */}
				<div className='p-3 border-b border-border space-y-3 bg-muted/10'>
					<div className='flex items-center justify-between'>
						<h2 className='text-lg font-serif font-bold capitalize text-foreground flex items-center gap-2'>
							{type}s
							<span className='text-xs font-sans font-normal text-muted-foreground bg-muted px-2 py-0.5 rounded-full border border-border'>
								{entities?.length || 0}
							</span>
						</h2>
						<Button
							onClick={() => navigate(`/dm/manage/${normalizedType}`)}
							size='sm'
							variant='primary'
							icon={Plus}
							className='h-7 px-2 text-xs'>
							New
						</Button>
					</div>
					<div className='relative'>
						<Search className='absolute left-2.5 top-2 text-muted-foreground/60' size={14} />
						<input
							type='text'
							placeholder='Filter list...'
							value={search}
							onChange={(e) => setSearch(e.target.value)}
							className='w-full pl-8 pr-3 py-1.5 bg-background border border-border rounded-md text-xs focus:outline-none focus:ring-1 focus:ring-amber-500 shadow-sm'
						/>
					</div>
				</div>

				{/* Scrollable List */}
				<div className='flex-1 overflow-y-auto custom-scrollbar'>
					{isLoading ? (
						<div className='p-8 flex justify-center'>
							<Loader2 className='animate-spin text-amber-600' />
						</div>
					) : filtered.length === 0 ? (
						<div className='p-6 text-center text-xs text-muted-foreground italic'>No matches.</div>
					) : (
						<div className='divide-y divide-border/40'>
							{filtered.map((item) => {
								const isActive = id === item.id;
								return (
									<div
										key={item.id}
										onClick={() => navigate(`/dm/manage/${normalizedType}/${item.id}`)}
										className={`group relative flex items-center w-full text-left transition-all cursor-pointer ${
											isActive ? 'bg-amber-500/10/80' : 'bg-background hover:bg-muted/50'
										}`}>
										{/* Active Marker Strip */}
										<div
											className={`absolute left-0 top-0 bottom-0 w-1 ${isActive ? 'bg-amber-500/100' : 'bg-transparent'}`}
										/>

										{/* Main Content Area */}
										<div className='flex-1 py-3 pl-4 pr-2 min-w-0'>
											<div
												className={`font-bold text-sm truncate mb-0.5 ${
													isActive ? 'text-amber-900' : 'text-foreground'
												}`}>
												{item.name || item.title}
											</div>
											<div className='flex items-center justify-between'>
												<div className='text-[10px] text-muted-foreground truncate w-full'>
													{item.summary || item.narrative || item.description || 'No description'}
												</div>
												{/* Status Dot */}
												{item.status && (
													<div
														title={item.status}
														className={`w-1.5 h-1.5 rounded-full shrink-0 ${
															item.status.toLowerCase().includes('active')
																? 'bg-emerald-500/100'
																: item.status.toLowerCase().includes('dead')
																? 'bg-red-500/100'
																: 'bg-slate-300'
														}`}
													/>
												)}
											</div>
										</div>

										{/* Action Buttons (Visible on Hover) */}
										<div
											className={`flex flex-col gap-1 pr-1 pl-1 ${
												isActive ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'
											} transition-opacity`}>
											<button
												onClick={(e) => handleDuplicate(item.id, e)}
												className='p-1 text-muted-foreground hover:text-blue-600 hover:bg-blue-100 rounded'
												title='Duplicate'>
												{isCloning === item.id ? <Loader2 size={12} className='animate-spin' /> : <Copy size={12} />}
											</button>
											<button
												onClick={(e) => handleDelete(item.id, e)}
												className='p-1 text-muted-foreground hover:text-red-600 hover:bg-red-100 rounded'
												title='Delete'>
												{isDeleting === item.id ? <Loader2 size={12} className='animate-spin' /> : <Trash2 size={12} />}
											</button>
										</div>
									</div>
								);
							})}
						</div>
					)}
				</div>
			</div>

			{/* --- RIGHT PANE: EDITOR --- */}
			<div className='flex-1 overflow-y-auto bg-muted/10 p-4 md:p-8 custom-scrollbar'>
				<div className='max-w-4xl mx-auto'>
					<AdminForm key={`${normalizedType}-${id || 'new'}`} type={normalizedType} id={id} />
				</div>
			</div>
		</div>
	);
}

--- END OF features\admin\pages\SplitPaneManager.jsx ---

--- FILE: features\atlas\MapPage.jsx ---
import { useMapData } from './useMapData';
import { MapCanvas } from './components/MapCanvas';
import LoadingSpinner from '@/shared/components/ui/LoadingSpinner';

export default function MapView() {
	const { data, navigateToMap, isLoading, currentMapKey } = useMapData();

	if (isLoading) {
		return (
			<div className='h-full flex items-center justify-center bg-[#1a1412]'>
				<LoadingSpinner text='Unrolling the parchment...' className='text-amber-500' />
			</div>
		);
	}

	return <MapCanvas data={data} onNavigate={navigateToMap} currentMapKey={currentMapKey} />;
}

--- END OF features\atlas\MapPage.jsx ---

--- FILE: features\atlas\useMapData.js ---
import { useSearchParams } from 'react-router-dom';
import { useMemo } from 'react';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { getMapConfig } from './utils/mapNavigation';

export function useMapData() {
	const { campaignData } = useCampaign();
	const [searchParams, setSearchParams] = useSearchParams();

	const currentMapKey = searchParams.get('map') || 'world_map';

	const mapConfig = useMemo(() => {
		const sourceData = campaignData?.map_data || null;
		return getMapConfig(currentMapKey, sourceData);
	}, [currentMapKey, campaignData]);

	const viewData = useMemo(() => {
		if (!mapConfig) return null;

		const { metadata, annotations, paths, areas, overlays } = mapConfig;

		// --- MATH FIX ---
		const scaleFactor = Math.pow(2, metadata.sizes.maxZoom);
		const bounds = [
			[-metadata.sizes.imageHeight / scaleFactor, 0],
			[0, metadata.sizes.imageWidth / scaleFactor],
		];

		// --- MARKER FLATTENING ---
		const markers = [];
		if (annotations) {
			Object.entries(annotations).forEach(([categoryKey, category]) => {
				if (category.items) {
					category.items.forEach((item) => {
						markers.push({
							...item,
							category: category.name,
							categoryId: categoryKey,
							position: [Number(item.lat), Number(item.lng)],
						});
					});
				}
			});
		}

		// 3. Process Areas
		const mapAreas = [];
		if (areas) {
			Object.values(areas).forEach((category) => {
				category.items.forEach((area) => {
					mapAreas.push({
						...area,
						positions: area.points.map((p) => p.coordinates),
					});
				});
			});
		}

		return {
			config: metadata,
			bounds,
			markers,
			sessions: paths || [],
			areas: mapAreas,
			overlays: overlays || [],
		};
	}, [mapConfig]);

	const navigateToMap = (mapKey) => {
		setSearchParams({ map: mapKey });
	};

	return {
		data: viewData,
		currentMapKey,
		navigateToMap,
		isLoading: false, // FIX: Since we're using static data, never loading
	};
}

--- END OF features\atlas\useMapData.js ---

--- FILE: features\atlas\components\AtlasSidebar.jsx ---
import React, { useState } from 'react';
import { clsx } from 'clsx';
import {
	Search,
	PanelLeftClose,
	PanelLeftOpen,
	Map as MapIcon,
	ChevronRight,
	ChevronDown,
	Eye,
	EyeOff,
	Crosshair,
} from 'lucide-react';

/**
 * Sidebar Group Item
 */
const AtlasGroup = ({ group, visibility, onToggleVisibility, onNavigate }) => {
	const [isExpanded, setIsExpanded] = useState(true);
	const isGroupVisible = visibility[group.id];

	return (
		<div className='select-none'>
			{/* Header */}
			<div className='flex items-center gap-1 px-3 py-2 hover:bg-black/5 transition-colors group/header sticky top-0 bg-muted/95 backdrop-blur-sm z-10 border-b border-border/40'>
				{/* Expand Toggle */}
				<button
					onClick={() => setIsExpanded(!isExpanded)}
					className='p-0.5 text-muted-foreground/70 hover:text-foreground'>
					{isExpanded ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
				</button>

				{/* Title */}
				<span
					className={clsx(
						'flex-1 text-xs font-bold uppercase tracking-wider cursor-pointer truncate',
						isGroupVisible
							? 'text-foreground'
							: 'text-muted-foreground decoration-line-through decoration-muted-foreground/50'
					)}
					onClick={() => setIsExpanded(!isExpanded)}>
					{group.label}
				</span>

				{/* Layer Visibility Toggle (Global for Group) */}
				<button
					onClick={(e) => {
						e.stopPropagation();
						onToggleVisibility(group.id);
					}}
					className={clsx(
						'p-1.5 rounded-md transition-all',
						isGroupVisible ? 'text-primary hover:bg-primary/10' : 'text-muted-foreground/50 hover:text-foreground'
					)}
					title={isGroupVisible ? 'Hide Layer' : 'Show Layer'}>
					{isGroupVisible ? <Eye size={14} /> : <EyeOff size={14} />}
				</button>
			</div>

			{/* Marker List */}
			{isExpanded && (
				<div className='pl-2 pb-1 pt-0.5 space-y-0.5'>
					{group.items.map((marker, idx) => {
						const isItemVisible = visibility[marker.id];

						return (
							<div
								key={`${group.id}-${idx}`}
								className='flex items-center gap-1 pr-2 group/item hover:bg-black/5 rounded-md'>
								{/* Navigation Button */}
								<button
									onClick={() => onNavigate(marker.position)}
									className='flex-1 flex items-center text-left gap-2 px-2 py-1.5 min-w-0'>
									<span className='opacity-50 group-hover/item:opacity-100 transition-opacity shrink-0'>
										<Crosshair size={12} />
									</span>
									<span
										className={clsx(
											'text-sm font-medium truncate transition-colors',
											isItemVisible && isGroupVisible ? 'text-foreground' : 'text-muted-foreground opacity-70'
										)}>
										{marker.label}
									</span>
								</button>

								{/* Individual Visibility Toggle */}
								<button
									onClick={() => onToggleVisibility(marker.id)}
									className={clsx(
										'p-1 rounded opacity-0 group-hover/item:opacity-100 focus:opacity-100 transition-opacity',
										isItemVisible ? 'text-muted-foreground hover:text-foreground' : 'text-muted-foreground/50'
									)}
									title={isItemVisible ? 'Hide Item' : 'Show Item'}>
									{isItemVisible ? <Eye size={12} /> : <EyeOff size={12} />}
								</button>
							</div>
						);
					})}
					{group.items.length === 0 && (
						<div className='text-[10px] text-muted-foreground/50 pl-9 italic py-1'>No locations</div>
					)}
				</div>
			)}
		</div>
	);
};

export const AtlasSidebar = ({ groups, visibility, onToggleLayer, onFlyTo }) => {
	const [search, setSearch] = useState('');
	const [desktopCollapsed, setDesktopCollapsed] = useState(false);
	const [mobileOpen, setMobileOpen] = useState(false);

	// Filter logic
	const filteredGroups = groups
		.map((g) => ({
			...g,
			items: g.items.filter((m) => m.label.toLowerCase().includes(search.toLowerCase())),
		}))
		.filter((g) => g.items.length > 0 || search === '');

	return (
		<>
			{/* COLLAPSED STATE (Desktop) */}
			{desktopCollapsed && (
				<div className='hidden lg:flex flex-col h-full border-l border-border bg-muted w-12 shrink-0 z-10 transition-all duration-300'>
					<div className='p-3 border-b border-border/50 h-14 flex items-center justify-center'>
						<button
							onClick={() => setDesktopCollapsed(false)}
							className='p-1.5 text-muted-foreground hover:text-primary hover:bg-background rounded-md transition-colors'
							title='Expand Atlas Sidebar'>
							<PanelLeftClose size={20} />
						</button>
					</div>
					<div className='flex-1 flex items-center justify-center writing-vertical-lr text-xs font-bold text-muted-foreground/50 uppercase tracking-widest py-8 select-none'>
						Atlas Index
					</div>
				</div>
			)}

			{/* SIDEBAR */}
			<div
				className={clsx(
					'flex flex-col bg-muted border-l border-border transition-all duration-300',
					// FIX: Removed global 'h-full' here.

					// Desktop Width Logic
					desktopCollapsed ? 'w-0 overflow-hidden border-none' : 'w-full lg:w-80',

					// Position Logic
					'absolute top-0 left-0 lg:relative z-[1000] lg:z-0',

					// Height Logic:
					// Mobile Closed: h-auto (just header)
					// Mobile Open: h-full (full screen overlay)
					// Desktop: h-full
					!mobileOpen ? 'h-auto bottom-auto lg:h-full' : 'h-full'
				)}>
				{/* Header */}
				<div className='p-4 border-b border-border/50 bg-muted flex flex-col gap-3'>
					<div className='flex items-center justify-between'>
						<div className='flex items-center gap-2 text-foreground font-serif font-bold'>
							<MapIcon size={18} className='text-primary' />
							<span>Atlas Index</span>
						</div>

						<div className='flex gap-1'>
							{/* Desktop Collapse */}
							<button
								onClick={() => setDesktopCollapsed(true)}
								className='hidden lg:block p-1 text-muted-foreground hover:text-primary transition-colors'
								title='Collapse Sidebar'>
								<PanelLeftOpen size={16} />
							</button>

							{/* Mobile Toggle */}
							<button
								onClick={() => setMobileOpen(!mobileOpen)}
								className='lg:hidden p-1 text-muted-foreground hover:text-foreground transition-colors'
								aria-label={mobileOpen ? 'Collapse' : 'Expand'}>
								{mobileOpen ? <ChevronDown size={20} /> : <ChevronRight size={20} />}
							</button>
						</div>
					</div>

					{/* Search - Visible when open */}
					<div className={clsx('relative', !mobileOpen && 'hidden lg:block')}>
						<Search className='absolute left-2.5 top-2.5 text-muted-foreground/50' size={14} />
						<input
							type='text'
							placeholder='Search locations...'
							value={search}
							onChange={(e) => setSearch(e.target.value)}
							className='w-full bg-background border border-border rounded-md pl-8 pr-3 py-2 text-sm focus:ring-1 focus:ring-primary/50 focus:border-primary outline-none shadow-sm'
						/>
					</div>
				</div>

				{/* Scrollable Content */}
				<div className={clsx('flex-1 overflow-y-auto custom-scrollbar bg-muted/30', !mobileOpen && 'hidden lg:block')}>
					{filteredGroups.map((group) => (
						<AtlasGroup
							key={group.id}
							group={group}
							visibility={visibility}
							onToggleVisibility={onToggleLayer}
							onNavigate={onFlyTo}
						/>
					))}

					{filteredGroups.length === 0 && (
						<div className='p-6 text-center text-xs text-muted-foreground italic'>No locations found.</div>
					)}
				</div>
			</div>
		</>
	);
};

--- END OF features\atlas\components\AtlasSidebar.jsx ---

--- FILE: features\atlas\components\MapCanvas.jsx ---
import { useEffect, useState, useMemo, useRef } from 'react';
import { MapContainer, TileLayer, useMap } from 'react-leaflet';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';

import { MapMarkers } from './layers/MapMarkers';
import { MapRecaps } from './layers/MapRecaps';
import { MapAreas } from './layers/MapAreas';
import { MapOverlays } from './layers/MapOverlays';
import { MapTools } from './MapTools';
import { AtlasSidebar } from './AtlasSidebar';
import { useMapCanvasViewModel } from './useMapCanvasViewModel';

// Controller to handle FlyTo from sidebar
const MapController = ({ bounds, minZoom, config, flyToTarget }) => {
	const map = useMap();
	const prevConfigRef = useRef();

	// Handle initial bounds
	useEffect(() => {
		if (!bounds) return;
		const isNewMap = prevConfigRef.current !== config.path;
		prevConfigRef.current = config.path;

		map.setMaxBounds(L.latLngBounds(bounds).pad(0.1));
		if (minZoom !== undefined) map.setMinZoom(minZoom);

		map.fitBounds(bounds, {
			animate: !isNewMap,
			duration: isNewMap ? 0 : 0.5,
		});
	}, [map, bounds, minZoom, config.path]);

	// Handle Sidebar FlyTo
	useEffect(() => {
		if (flyToTarget) {
			map.flyTo(flyToTarget, config.sizes.maxZoom - 1, {
				animate: true,
				duration: 1.5,
			});
		}
	}, [map, flyToTarget]);

	return null;
};

export const MapCanvas = ({ data, onNavigate }) => {
	if (!data) return null;

	const { config, bounds, areas } = data;
	const vm = useMapCanvasViewModel(data);
	const wrapperRef = useRef(null);
	const [flyToTarget, setFlyToTarget] = useState(null);

	const tileUrl = `https://raw.githubusercontent.com/aethere92/dnd-campaign-map/main/${config.path}/{z}/{x}_{y}.png`;
	const minZoom = 0;

	return (
		<div className='flex h-full w-full relative overflow-hidden'>
			{/* MAP AREA - First in DOM (Left side in flex row) */}
			<div
				ref={wrapperRef}
				className='flex-1 relative h-full bg-background'
				style={{
					backgroundColor: 'var(--background)',
					backgroundImage:
						'radial-gradient(circle at center, var(--border) 1px, transparent 1px), radial-gradient(circle at center, var(--border) 1px, transparent 1px)',
					backgroundSize: '40px 40px, 20px 20px',
					backgroundPosition: '0 0, 20px 20px',
				}}>
				<MapContainer
					center={[0, 0]}
					zoom={minZoom}
					crs={L.CRS.Simple}
					minZoom={minZoom}
					maxZoom={config.sizes.maxZoom}
					scrollWheelZoom={true}
					attributionControl={false}
					zoomControl={false}
					style={{ height: '100%', width: '100%', background: 'transparent' }}>
					<MapController bounds={bounds} minZoom={minZoom} config={config} flyToTarget={flyToTarget} />

					<TileLayer key={tileUrl} url={tileUrl} noWrap={true} bounds={bounds} maxNativeZoom={config.sizes.maxZoom} />

					<MapOverlays overlays={vm.visibleOverlays} />
					{vm.showAreas && <MapAreas areas={areas} />}
					<MapRecaps sessions={vm.visibleSessions} />
					<MapMarkers markers={vm.visibleMarkers} onNavigate={onNavigate} />

					<MapTools bounds={bounds} containerRef={wrapperRef} />
				</MapContainer>
			</div>

			{/* ATLAS SIDEBAR - Second in DOM (Right side) */}
			<AtlasSidebar
				groups={vm.sidebarGroups}
				visibility={vm.visibility}
				onToggleLayer={vm.toggleLayer}
				onFlyTo={setFlyToTarget}
			/>
		</div>
	);
};

--- END OF features\atlas\components\MapCanvas.jsx ---

--- FILE: features\atlas\components\MapTools.jsx ---
import { useState, useEffect } from 'react';
import { useMap } from 'react-leaflet';
import { Maximize, Minimize, Crosshair } from 'lucide-react';
import { clsx } from 'clsx';

export const MapTools = ({ bounds, containerRef }) => {
	const map = useMap();
	const [isFullscreen, setIsFullscreen] = useState(false);

	// Sync state if user presses ESC or browser exit
	useEffect(() => {
		const onFullScreenChange = () => {
			setIsFullscreen(!!document.fullscreenElement);
		};
		document.addEventListener('fullscreenchange', onFullScreenChange);
		return () => document.removeEventListener('fullscreenchange', onFullScreenChange);
	}, []);

	const handleCenter = (e) => {
		e.stopPropagation();
		if (bounds) {
			map.fitBounds(bounds, { animate: true, duration: 1 });
		}
	};

	const toggleFullscreen = (e) => {
		e.stopPropagation();
		if (!containerRef?.current) return;

		if (!document.fullscreenElement) {
			containerRef.current.requestFullscreen().catch((err) => {
				console.error(`Error attempting to enable fullscreen: ${err.message}`);
			});
		} else {
			document.exitFullscreen();
		}
	};

	// Reusable Button Style
	const Btn = ({ onClick, icon: Icon, title, active }) => (
		<button
			onClick={onClick}
			title={title}
			className={clsx(
				'flex items-center justify-center w-8 h-8 transition-colors first:rounded-t-md last:rounded-b-md border-b last:border-b-0',
				// FIX: Semantic Theme Colors
				'bg-card border-border text-muted-foreground hover:bg-muted hover:text-primary',
				active && 'bg-primary/10 text-primary'
			)}>
			<Icon size={16} strokeWidth={2.5} />
		</button>
	);

	return (
		<div className='leaflet-top leaflet-left'>
			<div className='leaflet-control leaflet-bar !border-0 !shadow-xl !m-3 rounded-md overflow-hidden border border-border/50'>
				<Btn onClick={handleCenter} icon={Crosshair} title='Center Map' />
				<Btn
					onClick={toggleFullscreen}
					icon={isFullscreen ? Minimize : Maximize}
					title={isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen'}
					active={isFullscreen}
				/>
			</div>
		</div>
	);
};

--- END OF features\atlas\components\MapTools.jsx ---

--- FILE: features\atlas\components\useMapCanvasViewModel.js ---
import { useState, useEffect, useMemo } from 'react';
import { BookOpen, MapPin, Image as ImageIcon, Map as MapIcon } from 'lucide-react';

export function useMapCanvasViewModel(data) {
	// 1. Initialize Visibility
	const [visibility, setVisibility] = useState(() => {
		const init = { areas: false };
		if (!data) return init;

		// Initialize marker categories
		const uniqueCats = [...new Set(data.markers.map((m) => m.category))].filter(Boolean);
		uniqueCats.forEach((cat) => {
			init[`marker-cat-${cat}`] = true;
		});

		// Initialize individual markers (new)
		data.markers.forEach((m) => {
			if (m.label) init[`marker-item-${m.label}`] = true;
		});

		// Sessions/Overlays: OFF by default
		data.sessions.forEach((s) => (init[`session-${s.name}`] = false));
		data.overlays.forEach((o) => (init[`overlay-${o.name}`] = false));

		return init;
	});

	// Sync with data updates
	useEffect(() => {
		if (!data) return;
		setVisibility((prev) => {
			const next = { ...prev };
			let changed = false;

			// Sync Categories
			const uniqueCats = [...new Set(data.markers.map((m) => m.category))].filter(Boolean);
			uniqueCats.forEach((cat) => {
				const key = `marker-cat-${cat}`;
				if (next[key] === undefined) {
					next[key] = true;
					changed = true;
				}
			});

			// Sync Items
			data.markers.forEach((m) => {
				const key = `marker-item-${m.label}`;
				if (next[key] === undefined) {
					next[key] = true;
					changed = true;
				}
			});

			return changed ? next : prev;
		});
	}, [data?.markers]);

	const toggleLayer = (id) => {
		setVisibility((prev) => ({ ...prev, [id]: !prev[id] }));
	};

	// 2. Control Groups Configuration
	const sidebarGroups = useMemo(() => {
		if (!data) return [];

		const groups = [];

		// 1. Sessions
		if (data.sessions.length > 0) {
			groups.push({
				id: 'sessions-group',
				label: 'Sessions & Paths',
				items: data.sessions
					.map((s) => ({
						label: s.name,
						id: `session-${s.name}`,
						position: s.points[0]?.coordinates,
					}))
					.filter((i) => i.position),
			});
		}

		// 2. Markers by Category
		const uniqueCats = [...new Set(data.markers.map((m) => m.category))].filter(Boolean).sort();

		uniqueCats.forEach((cat) => {
			const catId = `marker-cat-${cat}`;
			const catMarkers = data.markers.filter((m) => m.category === cat);

			groups.push({
				id: catId,
				label: cat,
				items: catMarkers.map((m) => ({
					label: m.label,
					id: `marker-item-${m.label}`, // Individual ID
					position: m.position,
				})),
			});
		});

		// 3. Overlays
		if (data.overlays.length > 0) {
			groups.push({
				id: 'overlays-group',
				label: 'Overlays',
				items: data.overlays.map((o) => ({
					label: o.name,
					id: `overlay-${o.name}`,
					position: o.bounds[0],
				})),
			});
		}

		// 4. Areas
		if (data.areas.length > 0) {
			groups.push({
				id: 'areas',
				label: 'Regions & Areas',
				items: data.areas.map((a) => ({
					label: a.name,
					id: 'areas', // Shared ID for all areas for now
					position: a.positions[0],
				})),
			});
		}

		return groups;
	}, [data]);

	// 3. Filter Layers
	// Logic: Marker is visible if Category is ON AND Individual Item is ON
	const visibleMarkers = useMemo(
		() =>
			data?.markers.filter(
				(m) =>
					visibility[`marker-cat-${m.category}`] !== false && // Default to true if undefined
					visibility[`marker-item-${m.label}`] !== false
			) || [],
		[data, visibility]
	);

	const visibleSessions = useMemo(
		() => data?.sessions.filter((s) => visibility[`session-${s.name}`] || visibility['sessions-group']) || [],
		[data, visibility]
	);

	const visibleOverlays = useMemo(
		() => data?.overlays.filter((o) => visibility[`overlay-${o.name}`] || visibility['overlays-group']) || [],
		[data, visibility]
	);

	return {
		visibility,
		toggleLayer,
		sidebarGroups,
		visibleMarkers,
		visibleSessions,
		visibleOverlays,
		showAreas: visibility['areas'],
	};
}

--- END OF features\atlas\components\useMapCanvasViewModel.js ---

--- FILE: features\atlas\components\__MapLayerControl.jsx ---
import { useState, useEffect, useRef } from 'react';
import { Layers, ChevronDown, ChevronRight, Eye, EyeOff, Check } from 'lucide-react';
import { clsx } from 'clsx';
import L from 'leaflet';

// Reusable styled Group Header matching Sidebar aesthetics
const Group = ({ label, icon: Icon, children, defaultOpen = true }) => {
	const [isOpen, setIsOpen] = useState(defaultOpen);
	if (!children || children.length === 0) return null;

	return (
		<div className='mb-2'>
			<button
				onClick={(e) => {
					e.stopPropagation();
					setIsOpen(!isOpen);
				}}
				className='flex items-center w-full text-left text-[10px] font-bold uppercase tracking-widest text-muted-foreground hover:text-amber-700 transition-colors mb-1 select-none font-sans'>
				<span className='mr-1 opacity-70'>{isOpen ? <ChevronDown size={10} /> : <ChevronRight size={10} />}</span>
				<span className='flex items-center gap-1.5'>
					{Icon && <Icon size={12} />}
					{label}
				</span>
			</button>
			{isOpen && <div className='pl-2 space-y-0.5 border-l border-black/5 ml-1'>{children}</div>}
		</div>
	);
};

// Toggle Item with explicit Checkmark UI
const ToggleItem = ({ label, checked, onChange }) => (
	<div
		className='flex items-center gap-2 cursor-pointer group px-2 py-1 hover:bg-black/5 rounded-md transition-colors select-none'
		onClick={(e) => {
			e.stopPropagation();
			onChange();
		}}>
		{/* Custom Checkbox UI - Reduced size */}
		<div
			className={clsx(
				'w-3.5 h-3.5 rounded-[3px] border flex items-center justify-center transition-all shadow-sm shrink-0',
				checked ? 'bg-amber-600 border-amber-700 text-white' : 'bg-card border-border group-hover:border-amber-400'
			)}>
			{checked && <Check size={10} strokeWidth={3.5} />}
		</div>

		<span
			className={clsx(
				'text-[11px] font-medium leading-tight pt-0.5 font-sans',
				checked ? 'text-foreground' : 'text-muted-foreground'
			)}>
			{label}
		</span>
	</div>
);

export const MapLayerControl = ({ groups, visibility, toggleLayer }) => {
	const [expanded, setExpanded] = useState(true);
	const containerRef = useRef(null);

	// Prevent Leaflet map interactions when clicking inside this control
	useEffect(() => {
		if (containerRef.current) {
			L.DomEvent.disableClickPropagation(containerRef.current);
			L.DomEvent.disableScrollPropagation(containerRef.current);
		}
	}, []);

	return (
		<div className='leaflet-top leaflet-right font-sans' style={{ pointerEvents: 'none', zIndex: 1000 }}>
			<div
				ref={containerRef}
				className={clsx(
					'leaflet-control m-3 transition-all duration-200 ease-in-out',
					// Theme colors
					'bg-[#fdfbf7] border border-[#c9c2b8] rounded-lg shadow-xl overflow-hidden'
				)}
				style={{ pointerEvents: 'auto' }}>
				{/* Header */}
				<div
					className='flex items-center justify-between p-2.5 bg-[#f2efe9] border-b border-[#c9c2b8] cursor-pointer min-w-[180px]'
					onClick={() => setExpanded(!expanded)}>
					<div className='flex items-center gap-2 text-xs font-serif font-bold text-amber-900'>
						<Layers size={14} />
						<span>Atlas Layers</span>
					</div>
					<button className='p-0.5 hover:bg-black/5 rounded text-amber-900/70'>
						{expanded ? <Eye size={12} /> : <EyeOff size={12} />}
					</button>
				</div>

				{/* Content */}
				{expanded && (
					<div className='p-2 max-h-[60vh] overflow-y-auto w-56 custom-scrollbar bg-background/50'>
						{groups.overlays?.length > 0 && (
							<Group label='Overlays' icon={groups.icons.overlays} defaultOpen={false}>
								{groups.overlays.map((l) => (
									<ToggleItem
										key={l.id}
										label={l.label}
										checked={!!visibility[l.id]}
										onChange={() => toggleLayer(l.id)}
									/>
								))}
							</Group>
						)}

						{groups.sessions?.length > 0 && (
							<Group label='Journal & Paths' icon={groups.icons.sessions} defaultOpen={false}>
								{groups.sessions.map((l) => (
									<ToggleItem
										key={l.id}
										label={l.label}
										checked={!!visibility[l.id]}
										onChange={() => toggleLayer(l.id)}
									/>
								))}
							</Group>
						)}

						{groups.markers?.length > 0 && (
							<Group label='Map Markers' icon={groups.icons.markers} defaultOpen={true}>
								{groups.markers.map((cat) => (
									<ToggleItem
										key={cat.id}
										label={cat.label}
										checked={!!visibility[cat.id]}
										onChange={() => toggleLayer(cat.id)}
									/>
								))}
							</Group>
						)}

						<div className='mt-2 pt-2 border-t border-black/5'>
							<ToggleItem
								label='Show Areas & Regions'
								checked={!!visibility['areas']}
								onChange={() => toggleLayer('areas')}
							/>
						</div>
					</div>
				)}
			</div>
		</div>
	);
};

--- END OF features\atlas\components\__MapLayerControl.jsx ---

--- FILE: features\atlas\components\layers\MapAreas.jsx ---
import { Polygon, Tooltip } from 'react-leaflet';

export const MapAreas = ({ areas }) => {
	if (!areas || areas.length === 0) return null;

	return (
		<>
			{areas.map((area, idx) => (
				<Polygon
					key={`${area.name}-${idx}`}
					positions={area.positions}
					pathOptions={{
						color: area.lineColor || 'transparent',
						fillColor: area.interiorColor || '#ff0000',
						fillOpacity: 0.3,
						weight: 1,
					}}>
					<Tooltip
						permanent
						direction='center'
						className='bg-transparent border-0 shadow-none font-serif text-lg font-bold text-white drop-shadow-md text-center'>
						<div style={{ transform: `rotate(${area.textRotation || '0deg'})` }}>{area.name}</div>
					</Tooltip>
				</Polygon>
			))}
		</>
	);
};

--- END OF features\atlas\components\layers\MapAreas.jsx ---

--- FILE: features\atlas\components\layers\MapMarkers.jsx ---
import { Marker, Popup } from 'react-leaflet';
import { ArrowRight, BookOpen, Map as MapIcon } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import { clsx } from 'clsx';
import { resolveMarkerIcon } from '@/features/atlas/utils/markerUtils';
import { useEntityIndex } from '@/features/smart-text/useEntityIndex';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import { resolveImageUrl, parseAttributes } from '@/shared/utils/imageUtils';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

export const MapMarkers = ({ markers, onNavigate }) => {
	const navigate = useNavigate();
	const { map: entityMap } = useEntityIndex();

	if (!markers || markers.length === 0) return null;

	return (
		<>
			{markers.map((marker, idx) => {
				const leafletIcon = resolveMarkerIcon(marker);

				const entityMatch = Array.from(entityMap.values()).find(
					(e) => e.name.toLowerCase() === marker.label.toLowerCase()
				);

				const entityAttrs = entityMatch ? parseAttributes(entityMatch.attributes) : {};

				const displayData = {
					title: marker.label,
					category:
						marker.category && marker.category !== 'default'
							? marker.category
							: entityMatch
							? entityMatch.type
							: 'Point of Interest',
					description: marker.description
						? marker.description
						: entityMatch
						? getAttributeValue(entityAttrs, ['summary', 'narrative']) || entityMatch.description
						: null,
					image: entityMatch ? resolveImageUrl(entityAttrs, 'background') : null,
				};

				const entityConfig = entityMatch ? getEntityConfig(entityMatch.type) : null;

				const handleWikiNav = (e) => {
					e.stopPropagation();
					if (entityMatch) {
						navigate(`/wiki/${entityMatch.type}/${entityMatch.id}`);
					}
				};

				const handleMapNav = (e) => {
					e.stopPropagation();
					onNavigate(marker.mapLink);
				};

				return (
					<Marker key={`${marker.label}-${idx}`} position={marker.position} icon={leafletIcon}>
						<Popup className='custom-popup-clean' closeButton={false}>
							<div className='flex flex-col w-full font-sans bg-background rounded-lg overflow-hidden border border-border shadow-sm'>
								{displayData.image && (
									<div className='h-24 w-full relative bg-muted'>
										<img src={displayData.image} alt={displayData.title} className='w-full h-full object-cover' />
										{/* FIX: Improved Gradient - Stronger fade at bottom for text readability */}
										<div className='absolute inset-0 bg-gradient-to-t from-[var(--background)] via-[var(--background)]/80 via-30% to-transparent pointer-events-none' />
									</div>
								)}

								<div className={clsx('px-4 pb-3', displayData.image ? 'pt-2 -mt-8 relative z-10' : 'pt-4')}>
									<div className='flex items-start justify-between gap-2'>
										<div>
											<span
												className={clsx(
													'text-[10px] font-bold uppercase tracking-wider block mb-0.5',
													entityConfig ? entityConfig.tailwind.text : 'text-muted-foreground'
												)}>
												{displayData.category}
											</span>
											{/* FIX: Ensure title text color is always readable (foreground) */}
											<h3 className='font-serif font-bold text-lg leading-tight text-foreground drop-shadow-sm'>
												{displayData.title}
											</h3>
										</div>
										{entityConfig && (
											<div
												className={clsx(
													'p-1.5 rounded-md border shrink-0 bg-background/80 backdrop-blur-sm',
													entityConfig.tailwind.border,
													entityConfig.tailwind.text
												)}>
												<entityConfig.icon size={14} />
											</div>
										)}
									</div>

									<div className='h-px w-full bg-border/50 my-3' />

									<div className='text-xs text-muted-foreground leading-relaxed max-h-32 overflow-y-auto custom-scrollbar'>
										{displayData.description || <span className='italic opacity-70'>No details available.</span>}
									</div>
								</div>

								{(marker.mapLink || entityMatch) && (
									<div className='bg-muted/50 p-2 border-t border-border flex flex-col gap-1'>
										{marker.mapLink && (
											<button
												onClick={handleMapNav}
												className='w-full flex items-center justify-between px-3 py-1.5 rounded hover:bg-primary/10 text-primary transition-colors text-xs font-bold uppercase tracking-wide group'>
												<span className='flex items-center gap-2'>
													<MapIcon size={12} /> Enter Location
												</span>
												<ArrowRight size={12} className='group-hover:translate-x-1 transition-transform' />
											</button>
										)}

										{entityMatch && (
											<button
												onClick={handleWikiNav}
												className='w-full flex items-center justify-between px-3 py-1.5 rounded hover:bg-background text-muted-foreground hover:text-foreground transition-colors text-xs font-semibold group'>
												<span className='flex items-center gap-2'>
													<BookOpen size={12} /> View Encyclopedia
												</span>
												<ArrowRight size={12} className='opacity-0 group-hover:opacity-100 transition-opacity' />
											</button>
										)}
									</div>
								)}
							</div>
						</Popup>
					</Marker>
				);
			})}
		</>
	);
};

--- END OF features\atlas\components\layers\MapMarkers.jsx ---

--- FILE: features\atlas\components\layers\MapOverlays.jsx ---
import { ImageOverlay } from 'react-leaflet';

export const MapOverlays = ({ overlays }) => {
	if (!overlays || overlays.length === 0) return null;

	return (
		<>
			{overlays.map((overlay, idx) => (
				<ImageOverlay
					key={`${overlay.name}-${idx}`}
					url={`${import.meta.env.BASE_URL}${overlay.image}`}
					bounds={overlay.bounds}
					opacity={1}
				/>
			))}
		</>
	);
};

--- END OF features\atlas\components\layers\MapOverlays.jsx ---

--- FILE: features\atlas\components\layers\MapRecaps.jsx ---
import { Fragment } from 'react';
import { Polyline, Marker, Popup } from 'react-leaflet';
import { Calendar } from 'lucide-react';
import { createDotIcon } from '@/features/atlas/utils/markerUtils';

export const MapRecaps = ({ sessions }) => {
	if (!sessions || sessions.length === 0) return null;

	return (
		<>
			{sessions.map((session, idx) => (
				<Fragment key={session.name}>
					<Polyline
						positions={session.points.map((p) => p.coordinates)}
						pathOptions={{ color: session.lineColor || '#d97706', weight: 3, dashArray: '8, 8', opacity: 0.7 }}
					/>

					{session.points
						.filter((p) => p.text)
						.map((point, pIdx) => (
							<Marker
								key={`${session.name}-p-${pIdx}`}
								position={point.coordinates}
								icon={createDotIcon(session.lineColor || '#d97706')}>
								<Popup closeButton={false} className='leaflet-popup-clean'>
									<div className='flex flex-col w-[200px] font-sans bg-background rounded-md overflow-hidden shadow-sm border border-border/50'>
										{/* Header */}
										<div className='px-3 py-2 bg-amber-500/10/80 border-b border-amber-100/50 flex items-center gap-2'>
											<Calendar size={12} className='text-amber-700' />
											<span className='text-[10px] font-bold uppercase tracking-wider text-amber-900'>
												{session.name}
											</span>
										</div>

										{/* Content */}
										<div className='p-3 text-xs text-foreground/80 leading-snug'>{point.text}</div>
									</div>
								</Popup>
							</Marker>
						))}
				</Fragment>
			))}
		</>
	);
};

--- END OF features\atlas\components\layers\MapRecaps.jsx ---

--- FILE: features\atlas\config\mapConfig.js ---
export const MAP_CONFIG = {
	defaultCenter: [51.505, -0.09],
	defaultZoom: 13,
	tileLayer: {
		// Dark Matter theme matches your D&D aesthetic
		url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
		attribution: '&copy; <a href="https://carto.com/attributions">CARTO</a>',
	},
	style: {
		height: '100%',
		width: '100%',
		background: '#111',
	},
};

--- END OF features\atlas\config\mapConfig.js ---

--- FILE: features\atlas\utils\mapNavigation.js ---
import { CAMPAIGN_01, CAMPAIGN_01_ALIASES } from '@/features/atlas/data/campaign_01';

/**
 * Resolves the configuration object for a specific map key.
 * Handles aliases (e.g. 'korinis_island' -> 'world_maps.submaps...')
 */
export const getMapConfig = (mapKey, campaignData) => {
	// 1. If we have dynamic campaign data from Supabase/Context, use it.
	// Otherwise fallback to the static file.
	const rootData = campaignData || CAMPAIGN_01;

	// 2. Resolve Alias
	const fullPath = CAMPAIGN_01_ALIASES[mapKey] || mapKey || 'world_map';
	const pathParts = fullPath.split('.');

	// 3. Traverse
	// Note: We skip 'submaps' keyword if it appears in the path to make traversal robust
	// but based on your alias structure, we just follow the dots exactly.
	try {
		const config = pathParts.reduce((current, key) => {
			return current && current[key] ? current[key] : null;
		}, rootData);

		return config;
	} catch (e) {
		console.error(`Failed to load map config for: ${mapKey}`, e);
		return null;
	}
};

/**
 * Helper to calculate map bounds based on image size
 */
export const calculateBounds = (imageWidth, imageHeight) => {
	// In CRS.Simple, [0,0] is usually bottom-left.
	// We map [0,0] to top-left for easier mental mapping if needed,
	// but standard Leaflet CRS.Simple treats Y as going up.
	// Typically: [[0,0], [height, width]]
	return [
		[-imageHeight, 0],
		[0, imageWidth],
	];
};

--- END OF features\atlas\utils\mapNavigation.js ---

--- FILE: features\atlas\utils\markerUtils.js ---
import React from 'react';
import L from 'leaflet';
import { renderToString } from 'react-dom/server';
import { Skull, MapPin, Castle, User, Tent, Sparkles, Home, Sword, Anchor, Mountain, Scroll } from 'lucide-react';

// 1. Map your category strings to Lucide Components
const ICON_MAP = {
	combat: Skull,
	danger: Skull,
	encounter: Sword,
	city: Castle,
	town: Home,
	village: Home,
	npc: User,
	people: User,
	camp: Tent,
	magic: Sparkles,
	shrine: Sparkles,
	port: Anchor,
	landmark: MapPin,
	dungeon: Mountain,
	quest: Scroll,
	default: MapPin,
};

// Singleton for invisible/interactive-only markers
export const invisibleIcon = L.divIcon({
	className: 'bg-transparent border-none',
	html: '<div style="width: 100%; height: 100%;"></div>',
	iconSize: [20, 20],
	iconAnchor: [10, 10],
	popupAnchor: [0, -10],
});

/**
 * Creates a "Pin" style marker using a Lucide React Icon
 */
export const createLucideMarker = (category, color = '#d97706') => {
	const normalized = category?.toLowerCase() || 'default';
	let IconComponent = ICON_MAP.default;
	for (const [key, comp] of Object.entries(ICON_MAP)) {
		if (normalized.includes(key)) {
			IconComponent = comp;
			break;
		}
	}

	const iconHtml = renderToString(
		React.createElement(IconComponent, {
			size: 14,
			strokeWidth: 3,
			color: 'white',
		})
	);

	/**
	 * STABLE SVG PIN
	 * The point is exactly at 16, 36.
	 * The circle center is at 16, 16.
	 */
	return L.divIcon({
		className: 'custom-marker-container',
		html: `
            <div class="relative group" style="width: 32px; height: 36px;">
                <svg width="32" height="36" viewBox="0 0 32 36" fill="none" xmlns="http://www.w3.org/2000/svg" style="filter: drop-shadow(0px 2px 2px rgba(0,0,0,0.2));">
                    <!-- Pin Body -->
                    <path d="M16 36C16 36 32 26.5 32 16C32 7.16344 24.8366 0 16 0C7.16344 0 0 7.16344 0 16C0 26.5 16 36 16 36Z" fill="white"/>
                    <path d="M16 33C16 33 29 24.5 29 16C29 8.8203 23.1797 3 16 3C8.8203 3 3 8.8203 3 16C3 24.5 16 33 16 33Z" fill="${color}"/>
                    <!-- Inner Hole -->
                    <circle cx="16" cy="16" r="10" fill="white" fill-opacity="0.2"/>
                </svg>
                <!-- Icon Overlay -->
                <div class="absolute top-[8px] left-[8px] w-[16px] h-[16px] flex items-center justify-center pointer-events-none transition-transform group-hover:-translate-y-0.5">
                    ${iconHtml}
                </div>
            </div>
        `,
		iconSize: [32, 36],
		iconAnchor: [16, 36], // EXACT BOTTOM CENTER
		popupAnchor: [0, -36],
	});
};

// Text Label Marker Generator
export const createTextMarker = (label, fontSize) => {
	const sizeStyle = fontSize ? `${fontSize}px` : '1.5rem';
	return L.divIcon({
		className: 'map-text-marker',
		html: `
            <div style="transform: translate(-50%, -50%); width: max-content; text-align: center; display: flex; justify-content: center; align-items: center;">
                <span style="font-family: 'Inter', sans-serif; text-transform: uppercase; font-weight: 600; font-size: ${sizeStyle}; color: #2c1a0e; text-shadow: 0 0 4px #fdfbf7, 0 0 8px #fdfbf7, 0 0 15px #fdfbf7; pointer-events: auto; cursor: pointer; white-space: nowrap;">
                    ${label}
                </span>
            </div>`,
		iconSize: [0, 0],
		iconAnchor: [0, 0],
		popupAnchor: [0, -10],
	});
};

/**
 * Logic Hub: Resolves the appropriate Leaflet icon
 */
export const resolveMarkerIcon = (marker) => {
	const { icon, type, label, fontSize, category } = marker;

	// 1. Existing Text Marker logic
	if (type === 'text' || icon === 'text') {
		return createTextMarker(label, fontSize);
	}

	// 2. Invisible / Null Icon
	if (!icon && !category) {
		return invisibleIcon;
	}

	// 3. Lucide Marker logic
	let markerColor = '#d97706';
	const cat = category?.toLowerCase() || '';
	if (cat.includes('combat') || cat.includes('danger')) markerColor = '#dc2626'; // Red
	if (cat.includes('magic') || cat.includes('shrine')) markerColor = '#7c3aed'; // Purple
	if (['city', 'location', 'town', 'points of interest'].includes(cat)) markerColor = '#059669'; // Emerald
	if (cat.includes('city') || cat.includes('town')) markerColor = '#1e40af'; // Blue
	if (['npcs', 'people'].includes(cat)) markerColor = '#d97706'; // Orange

	return createLucideMarker(category, markerColor);
};

// For session paths/dots
export const createDotIcon = (color) =>
	L.divIcon({
		className: 'path-dot',
		html: `<div style="background-color: ${color};" class="w-3 h-3 rounded-full border-2 border-white shadow-sm"></div>`,
		iconSize: [12, 12],
		iconAnchor: [6, 6],
	});

--- END OF features\atlas\utils\markerUtils.js ---

--- FILE: features\campaign\CampaignContext.jsx ---
import { createContext, useContext } from 'react';
import { useCampaignPersistence } from './useCampaignPersistence';

const CampaignContext = createContext(null);

export const CampaignProvider = ({ children }) => {
	const persistence = useCampaignPersistence();

	return <CampaignContext.Provider value={persistence}>{children}</CampaignContext.Provider>;
};

export const useCampaign = () => {
	const context = useContext(CampaignContext);
	if (!context) {
		throw new Error('useCampaign must be used within CampaignProvider');
	}
	return context;
};

--- END OF features\campaign\CampaignContext.jsx ---

--- FILE: features\campaign\useCampaignPersistence.js ---
import { useState, useCallback } from 'react';

const STORAGE_KEY = 'campaignId';

// Safe wrapper for environments where localStorage might fail
const storage = {
	getItem: (key) => {
		try {
			return localStorage.getItem(key) || sessionStorage.getItem(key);
		} catch {
			return null;
		}
	},
	setItem: (key, value) => {
		try {
			localStorage.setItem(key, value);
		} catch {
			sessionStorage.setItem(key, value);
		}
	},
	removeItem: (key) => {
		try {
			localStorage.removeItem(key);
			sessionStorage.removeItem(key);
		} catch {
			// ignore
		}
	},
};

export function useCampaignPersistence() {
	const [campaignId, setCampaignIdState] = useState(() => {
		return storage.getItem(STORAGE_KEY) || null;
	});

	const setCampaignId = useCallback((id) => {
		setCampaignIdState(id);
		if (id) {
			storage.setItem(STORAGE_KEY, id);
		} else {
			storage.removeItem(STORAGE_KEY);
		}
	}, []);

	return { campaignId, setCampaignId };
}

--- END OF features\campaign\useCampaignPersistence.js ---

--- FILE: features\campaign\useCampaignSelection.js ---
import { useQuery } from '@tanstack/react-query';
import { useNavigate } from 'react-router-dom';
import { getCampaigns } from '@/features/campaign/api/campaignService';
import { useCampaign } from './CampaignContext';
// import './types';

export function useCampaignSelection() {
	const { setCampaignId } = useCampaign();
	const navigate = useNavigate(); // 2. Initialize hook

	const { data: campaigns, isLoading } = useQuery({
		queryKey: ['campaigns'],
		queryFn: getCampaigns,
	});

	// Sort by ID
	const sortedCampaigns = (campaigns || []).sort((a, b) => String(a.campaign_id).localeCompare(String(b.campaign_id)));

	const selectCampaign = (id) => {
		setCampaignId(id);
		navigate('/'); // 3. Force navigation to the main app route
	};

	return {
		isLoading,
		campaigns: sortedCampaigns,
		selectCampaign,
	};
}

--- END OF features\campaign\useCampaignSelection.js ---

--- FILE: features\campaign\api\campaignService.js ---
import { supabase } from '@/shared/api/supabaseClient';

export const getCampaigns = async () => {
	// We fetch campaigns and use a subquery to get names of entities with type 'character'
	// ARCHITECTURAL UPDATE: Added 'map_data' to check if Atlas should be enabled
	const { data, error } = await supabase
		.from('campaigns')
		.select(
			`
            id,
			campaign_id,
            name, 
            description,
			map_data,
            characters:entity_complete_view(name)
        `
		)
		.eq('entity_complete_view.type', 'character');

	if (error) throw error;

	// Clean up the nested character structure
	return data.map((campaign) => ({
		...campaign,
		characterNames: campaign.characters?.map((c) => c.name) || [],
	}));
};

--- END OF features\campaign\api\campaignService.js ---

--- FILE: features\campaign\components\CampaignCard.jsx ---
import { BookOpen, ArrowRight, Users } from 'lucide-react';
import Button from '@/shared/components/ui/Button';

export const CampaignCard = ({ campaign, onSelect }) => {
	const initial = (campaign.name?.[0] || 'C').toUpperCase();

	return (
		<div className='bg-card/80 backdrop-blur-sm rounded-xl border border-border shadow-lg hover:shadow-xl transition-all p-6 flex flex-col h-full border-t-4 border-t-primary'>
			{/* ID Badge */}
			<div className='mb-4 flex justify-between items-start'>
				<div className='w-12 h-12 rounded-lg bg-primary/10 flex items-center justify-center text-primary font-serif font-bold text-xl border border-primary/20'>
					{initial}
				</div>
				<span className='text-[10px] font-mono text-muted-foreground/70 bg-muted px-2 py-1 rounded'>
					ID: {campaign.id.slice(0, 8)}...
				</span>
			</div>

			<div className='flex-1 mb-6'>
				<h3 className='text-xl font-bold text-foreground font-serif mb-2'>{campaign.name}</h3>
				<p className='text-sm text-muted-foreground line-clamp-2 mb-4 leading-relaxed italic'>
					{campaign.description || 'A journey into the unknown.'}
				</p>

				{/* Characters Section */}
				{campaign.characterNames?.length > 0 && (
					<div className='pt-4 border-t border-border/50'>
						<div className='flex items-center gap-2 text-xs font-bold text-primary uppercase tracking-wider mb-2'>
							<Users size={12} />
							Party Members
						</div>
						<div className='flex flex-wrap gap-1'>
							{campaign.characterNames
								.filter((name) => name !== 'Party')
								.map((name, i) => (
									<span
										key={i}
										className='text-[11px] px-2 py-0.5 bg-primary/10 text-primary rounded-full border border-primary/20'>
										{name}
									</span>
								))}
						</div>
					</div>
				)}
			</div>

			<div className='mt-auto'>
				<Button onClick={() => onSelect(campaign.id)} fullWidth variant='primary' icon={ArrowRight}>
					Enter Campaign
				</Button>
			</div>
		</div>
	);
};

--- END OF features\campaign\components\CampaignCard.jsx ---

--- FILE: features\campaign\components\CampaignSelect.jsx ---
import { useCampaignSelection } from '@/features/campaign/useCampaignSelection';
import { CampaignCard } from './CampaignCard';
import LoadingSpinner from '@/shared/components/ui/LoadingSpinner';

export default function CampaignSelect() {
	const { campaigns, isLoading, selectCampaign } = useCampaignSelection();
	const logoPath = `${import.meta.env.BASE_URL}logo_detailed.png`;

	if (isLoading) {
		return (
			<div className='h-full w-full bg-muted flex flex-col items-center justify-center'>
				<LoadingSpinner size='lg' text='Consulting the Archives...' />
			</div>
		);
	}

	return (
		// FIX: Removed inline style that forced texture. Added bg-background.
		<div className='h-full w-full overflow-y-auto custom-scrollbar font-sans bg-background'>
			<div className='min-h-full w-full flex items-center justify-center p-6 md:p-12'>
				<div className='max-w-5xl w-full mx-auto'>
					{/* Header Section */}
					<div className='text-center mb-12 animate-in fade-in slide-in-from-top-4 duration-700'>
						<img src={logoPath} alt='Logo' className='h-32 md:h-40 mx-auto mb-8 drop-shadow-2xl' />
						<h1 className='text-4xl md:text-5xl font-serif font-bold text-foreground mb-4'>Select Campaign</h1>
						<p className='text-muted-foreground text-lg max-w-xl mx-auto'>
							Choose a world to enter. Your adventures, characters, and chronicles await.
						</p>
					</div>

					{/* Grid Section - Centered */}
					<div className='flex flex-wrap justify-center gap-8 pb-8'>
						{campaigns.map((campaign) => (
							<div key={campaign.id} className='w-full md:w-[calc(50%-1rem)] lg:w-[calc(33.33%-1.5rem)] max-w-sm'>
								<CampaignCard campaign={campaign} onSelect={selectCampaign} />
							</div>
						))}

						{campaigns.length === 0 && (
							<div className='w-full py-20 text-center border-2 border-dashed border-border rounded-xl bg-background/50 backdrop-blur-sm'>
								<p className='text-muted-foreground/70 font-serif text-xl'>No campaigns found in the library.</p>
							</div>
						)}
					</div>
				</div>
			</div>
		</div>
	);
}

--- END OF features\campaign\components\CampaignSelect.jsx ---

--- FILE: features\dashboard\DashboardPage.jsx ---
import { useQuery } from '@tanstack/react-query';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { getDashboardData } from '@/features/dashboard/api/dashboardService';
import LoadingSpinner from '@/shared/components/ui/LoadingSpinner';
import { CampaignHero } from './components/CampaignHero';
import { LatestSessionCard } from './components/LatestSessionCard';
import { RecentSessionsList } from './components/RecentSessionsList';
import { QuickInsights } from './components/QuickInsights';
import { ActiveQuestsWidget } from './components/ActiveQuestsWidget';
import { RecentEncountersWidget } from './components/RecentEncountersWidget';

export default function DashboardView() {
	const { campaignId } = useCampaign();

	const { data, isLoading } = useQuery({
		queryKey: ['dashboard', campaignId],
		queryFn: () => getDashboardData(campaignId),
		enabled: !!campaignId,
		staleTime: 1000 * 60 * 5,
	});

	if (isLoading) {
		return (
			<div className='h-full flex items-center justify-center bg-background'>
				<LoadingSpinner text='Loading campaign overview...' size='lg' />
			</div>
		);
	}

	const { campaign, sessions, stats, activeQuests, recentEncounters } = data || {};
	const latestSession = sessions?.[0];
	const olderSessions = sessions?.slice(1, 4) || [];

	return (
		<div className='h-full overflow-y-auto bg-background custom-scrollbar'>
			{/* Hero Section */}
			<CampaignHero campaign={campaign} stats={stats} />

			{/* Main Content Grid */}
			<div className='max-w-[1600px] mx-auto px-4 sm:px-6 pb-12'>
				{/* Latest Session - Full Width Feature */}
				{latestSession && (
					<div className='mb-8 -mt-10 relative z-10'>
						<LatestSessionCard session={latestSession} />
					</div>
				)}

				{/* Two Column Layout */}
				<div className='grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8'>
					{/* Left Column - Recent Sessions & Insights */}
					<div className='lg:col-span-2 space-y-6'>
						{/* Quick Insights */}
						<QuickInsights stats={stats} sessions={sessions} />

						{/* Recent Sessions */}
						{olderSessions.length > 0 && <RecentSessionsList sessions={olderSessions} />}
					</div>

					{/* Right Column - Widgets */}
					<div className='space-y-6'>
						{/* Active Quests */}
						{activeQuests && activeQuests.length > 0 && <ActiveQuestsWidget quests={activeQuests} />}

						{/* Recent Encounters */}
						{recentEncounters && recentEncounters.length > 0 && (
							<RecentEncountersWidget encounters={recentEncounters} />
						)}
					</div>
				</div>
			</div>
		</div>
	);
}

--- END OF features\dashboard\DashboardPage.jsx ---

--- FILE: features\dashboard\api\dashboardService.js ---
import { supabase } from '@/shared/api/supabaseClient';
import { getAttributeValue, parseAttributes } from '@/domain/entity/utils/attributeParser';

/**
 * Fetch comprehensive dashboard data
 */
export const getDashboardData = async (campaignId) => {
	// 1. Fetch Campaign Info
	const { data: campaign } = await supabase.from('campaigns').select('*').eq('id', campaignId).single();

	// 2. Fetch Sessions with Events (Get ALL sessions, we'll sort by session_number later)
	const { data: sessions, error: sessionError } = await supabase
		.from('sessions')
		.select(
			`
            id, 
            title, 
            narrative,
            created_at,
            events:session_events (
                id, 
                title, 
                description, 
                event_type, 
                event_order
            )
        `
		)
		.eq('campaign_id', campaignId);

	if (sessionError) throw sessionError;
	if (!sessions || sessions.length === 0) {
		return { campaign, sessions: [], stats: {}, activeQuests: [], recentEncounters: [] };
	}

	// 3. Fetch Attributes for Sessions
	const sessionIds = sessions.map((s) => s.id);
	const { data: attributes } = await supabase
		.from('attributes')
		.select('entity_id, name, value')
		.in('entity_id', sessionIds);

	const attrMap = new Map();
	(attributes || []).forEach((attr) => {
		if (!attrMap.has(attr.entity_id)) attrMap.set(attr.entity_id, []);
		attrMap.get(attr.entity_id).push(attr);
	});

	// 4. Process Sessions with Attributes
	const processedSessions = sessions.map((s) => {
		const rawAttrs = attrMap.get(s.id) || [];
		const attrs = rawAttrs.reduce((acc, c) => {
			acc[c.name] = c.value;
			return acc;
		}, {});

		const num = getAttributeValue(attrs, ['session_number', 'Session']) || 999;
		const date = getAttributeValue(attrs, ['session_date', 'Date']) || '';
		const summary = getAttributeValue(attrs, 'Summary');

		return {
			...s,
			name: s.title,
			session_number: Number(num),
			session_date: date,
			description: summary || s.narrative?.substring(0, 200) || '',
			attributes: attrs,
			events: (s.events || []).sort((a, b) => (a.event_order || 0) - (b.event_order || 0)),
		};
	});

	// Sort by session_number DESC to get proper latest session
	processedSessions.sort((a, b) => b.session_number - a.session_number);

	// Take only the 10 most recent for display
	const recentSessions = processedSessions.slice(0, 10);

	// 5. Fetch Event Relationships (for tags/mentions)
	const allEvents = recentSessions.flatMap((s) => s.events);
	const eventIds = allEvents.map((e) => e.id);

	if (eventIds.length > 0) {
		const { data: relationships } = await supabase
			.from('entity_relationships')
			.select(`from_entity_id, target:entities!to_entity_id ( id, name, type )`)
			.in('from_entity_id', eventIds);

		const relMap = new Map();
		(relationships || []).forEach((rel) => {
			if (!relMap.has(rel.from_entity_id)) relMap.set(rel.from_entity_id, []);
			relMap.get(rel.from_entity_id).push(rel);
		});

		recentSessions.forEach((session) => {
			session.events.forEach((event) => {
				event.relationships = relMap.get(event.id) || [];
			});
		});
	}

	// 6. Fetch Direct Session Relationships (only for recent sessions)
	const recentSessionIds = recentSessions.map((s) => s.id);
	const { data: sessionRels } = await supabase
		.from('entity_relationships')
		.select(`from_entity_id, target:entities!to_entity_id ( id, name, type )`)
		.in('from_entity_id', recentSessionIds);

	const sessionRelMap = new Map();
	(sessionRels || []).forEach((rel) => {
		if (!sessionRelMap.has(rel.from_entity_id)) sessionRelMap.set(rel.from_entity_id, []);
		sessionRelMap.get(rel.from_entity_id).push(rel.target);
	});

	// 7. Extract Mentions by Type
	recentSessions.forEach((session) => {
		const mentionsMap = new Map();

		// Add direct session relationships
		const directRels = sessionRelMap.get(session.id) || [];
		directRels.forEach((target) => {
			if (!target) return;
			mentionsMap.set(target.id, {
				id: target.id,
				name: target.name,
				type: target.type,
			});
		});

		// Add event relationships
		session.events.forEach((evt) => {
			if (evt.relationships) {
				evt.relationships.forEach((rel) => {
					if (!rel.target) return;
					mentionsMap.set(rel.target.id, {
						id: rel.target.id,
						name: rel.target.name,
						type: rel.target.type,
					});
				});
			}
		});

		// Group by type
		const groups = {};
		mentionsMap.forEach((item) => {
			const type = item.type?.toLowerCase() || 'other';
			if (!groups[type]) groups[type] = [];
			groups[type].push(item);
		});

		// Sort each group alphabetically
		Object.keys(groups).forEach((key) => {
			groups[key].sort((a, b) => a.name.localeCompare(b.name));
		});

		session.mentions = groups;
	});

	// 8. **FIX: Fetch ALL quests with their attributes properly**
	const { data: allQuestsRaw } = await supabase
		.from('entities')
		.select('id, name')
		.eq('campaign_id', campaignId)
		.eq('type', 'quest')
		.order('name');

	// Fetch attributes for all quests
	let questAttributes = [];
	if (allQuestsRaw && allQuestsRaw.length > 0) {
		const questIds = allQuestsRaw.map((q) => q.id);
		const { data: attrs } = await supabase
			.from('attributes')
			.select('entity_id, name, value')
			.in('entity_id', questIds);
		questAttributes = attrs || [];
	}

	// Map attributes to quests
	const questAttrMap = new Map();
	questAttributes.forEach((attr) => {
		if (!questAttrMap.has(attr.entity_id)) questAttrMap.set(attr.entity_id, []);
		questAttrMap.get(attr.entity_id).push(attr);
	});

	// Process quests with parsed attributes
	const allQuests = (allQuestsRaw || []).map((q) => {
		const rawAttrs = questAttrMap.get(q.id) || [];
		const attrs = parseAttributes(rawAttrs); // Convert array to object
		return {
			...q,
			attributes: attrs,
			rawAttributes: rawAttrs, // Keep raw for potential debugging
		};
	});

	// Fetch objectives for active quests (for display widget)
	const activeQuests = allQuests.filter((q) => {
		const status = getAttributeValue(q.attributes, ['status', 'Status', 'quest status', 'Quest Status']) || '';
		const statusLower = status.toLowerCase();
		return (
			statusLower.includes('active') ||
			statusLower.includes('in progress') ||
			statusLower.includes('progress') ||
			statusLower === '' ||
			statusLower === 'pending'
		);
	});

	// Fetch objectives for the active quests we'll display
	const displayQuestIds = activeQuests.slice(0, 5).map((q) => q.id);
	let questObjectives = [];
	if (displayQuestIds.length > 0) {
		const { data: objectives } = await supabase
			.from('quest_objectives')
			.select('*')
			.in('quest_id', displayQuestIds)
			.order('order_index', { ascending: true });
		questObjectives = objectives || [];
	}

	// Attach objectives to quests
	const displayedActiveQuests = activeQuests.slice(0, 5).map((q) => ({
		...q,
		objectives: questObjectives.filter((obj) => obj.quest_id === q.id),
	}));

	// **FIX: Count completed quests with proper attribute parsing**
	const completedQuestsCount = allQuests.filter((q) => {
		const status = getAttributeValue(q.attributes, ['status', 'Status', 'quest status', 'Quest Status']) || '';
		const statusLower = status.toLowerCase();
		return (
			statusLower.includes('complete') ||
			statusLower.includes('finish') ||
			statusLower.includes('done') ||
			statusLower.includes('success')
		);
	}).length;

	// 9. Fetch Recent Encounters with Session Info
	const { data: recentEncounters } = await supabase
		.from('entities')
		.select('id, name, created_at')
		.eq('campaign_id', campaignId)
		.eq('type', 'encounter')
		.order('created_at', { ascending: false })
		.limit(5);

	// Attach session info to encounters via relationships
	if (recentEncounters && recentEncounters.length > 0) {
		const encounterIds = recentEncounters.map((e) => e.id);

		const { data: encounterRels } = await supabase
			.from('entity_relationships')
			.select(`from_entity_id, target:entities!to_entity_id ( id, name, type )`)
			.in('from_entity_id', encounterIds)
			.eq('entities.type', 'session');

		const encounterSessionMap = new Map();
		(encounterRels || []).forEach((rel) => {
			if (rel.target && rel.target.type === 'session') {
				encounterSessionMap.set(rel.from_entity_id, rel.target);
			}
		});

		// Fetch session numbers for those sessions
		const encounterSessionIds = Array.from(encounterSessionMap.values()).map((s) => s.id);
		if (encounterSessionIds.length > 0) {
			const { data: sessionAttrs } = await supabase
				.from('attributes')
				.select('entity_id, value')
				.in('entity_id', encounterSessionIds)
				.or('name.eq.session_number,name.eq.Session');

			const sessionNumMap = new Map();
			(sessionAttrs || []).forEach((a) => sessionNumMap.set(a.entity_id, a.value));

			encounterSessionMap.forEach((session) => {
				session.session_number = sessionNumMap.get(session.id);
			});
		}

		// Attach to encounters
		recentEncounters.forEach((enc) => {
			enc.session = encounterSessionMap.get(enc.id) || null;
		});
	}

	// 10. Calculate Stats
	const stats = {
		totalSessions: processedSessions.length,
		totalEncounters: recentEncounters?.length || 0,
		uniqueNPCs: 0,
		uniqueLocations: 0,
		completedQuests: completedQuestsCount,
		activeQuests: activeQuests.length,
		mostActiveSession: null,
		topLocation: null,
		topNPC: null,
	};

	// Count unique entities across recent sessions
	const npcSet = new Set();
	const locationSet = new Set();
	let maxEvents = 0;
	let mostActiveSession = null;

	recentSessions.forEach((session) => {
		// Track most active session
		if (session.events.length > maxEvents) {
			maxEvents = session.events.length;
			mostActiveSession = {
				id: session.id,
				title: session.title,
				eventCount: session.events.length,
			};
		}

		// Count unique entities
		if (session.mentions) {
			(session.mentions.npc || []).forEach((npc) => npcSet.add(npc.id));
			(session.mentions.location || []).forEach((loc) => locationSet.add(loc.id));
		}
	});

	stats.uniqueNPCs = npcSet.size;
	stats.uniqueLocations = locationSet.size;
	stats.mostActiveSession = mostActiveSession;

	// Find most mentioned NPC/Location
	const npcMentions = new Map();
	const locationMentions = new Map();

	recentSessions.forEach((session) => {
		if (session.mentions) {
			(session.mentions.npc || []).forEach((npc) => {
				npcMentions.set(npc.id, {
					name: npc.name,
					count: (npcMentions.get(npc.id)?.count || 0) + 1,
				});
			});
			(session.mentions.location || []).forEach((loc) => {
				locationMentions.set(loc.id, {
					name: loc.name,
					count: (locationMentions.get(loc.id)?.count || 0) + 1,
				});
			});
		}
	});

	// Get top NPC
	let topNPC = { name: 'None', mentions: 0 };
	npcMentions.forEach((data) => {
		if (data.count > topNPC.mentions) {
			topNPC = { name: data.name, mentions: data.count };
		}
	});
	stats.topNPC = topNPC;

	// Get top Location
	let topLocation = { name: 'None', visits: 0 };
	locationMentions.forEach((data) => {
		if (data.count > topLocation.visits) {
			topLocation = { name: data.name, visits: data.count };
		}
	});
	stats.topLocation = topLocation;

	// 11. Return Complete Dashboard Data
	return {
		campaign,
		sessions: recentSessions,
		stats,
		activeQuests: displayedActiveQuests,
		recentEncounters: recentEncounters || [],
	};
};

--- END OF features\dashboard\api\dashboardService.js ---

--- FILE: features\dashboard\components\ActiveQuestsWidget.jsx ---
import { Link } from 'react-router-dom';
import { Scroll, CheckCircle2, Circle } from 'lucide-react';
import { clsx } from 'clsx';

export const ActiveQuestsWidget = ({ quests }) => {
	return (
		<div className='bg-background border border-border rounded-lg shadow-sm overflow-hidden'>
			<div className='px-4 py-3 bg-muted border-b border-border flex items-center justify-between'>
				<h3 className='text-sm font-bold uppercase tracking-wider text-foreground flex items-center gap-2'>
					<Scroll size={14} className='text-blue-600' />
					Active Quests
				</h3>
				<span className='text-xs font-bold text-muted-foreground bg-background px-2 py-0.5 rounded-full border border-border'>
					{quests.length}
				</span>
			</div>
			<div className='divide-y divide-border'>
				{quests.map((quest) => {
					const progress = quest.objectives
						? {
								completed: quest.objectives.filter((o) => o.status === 'completed').length,
								total: quest.objectives.length,
						  }
						: null;

					return (
						<Link
							key={quest.id}
							to={`/wiki/quest/${quest.id}`}
							className='block px-4 py-3 hover:bg-muted/50 transition-colors group'>
							<div className='flex items-start gap-3'>
								<Circle size={16} className='text-blue-500 shrink-0 mt-0.5' strokeWidth={2.5} />
								<div className='flex-1 min-w-0'>
									<p className='text-sm font-semibold text-foreground group-hover:text-primary transition-colors mb-1'>
										{quest.name}
									</p>
									{progress && (
										<div className='flex items-center gap-2'>
											<div className='flex-1 h-1.5 bg-muted rounded-full overflow-hidden border border-border'>
												<div
													className='h-full bg-blue-500/100 transition-all'
													style={{ width: `${(progress.completed / progress.total) * 100}%` }}
												/>
											</div>
											<span className='text-xs font-medium text-muted-foreground whitespace-nowrap'>
												{progress.completed}/{progress.total}
											</span>
										</div>
									)}
								</div>
							</div>
						</Link>
					);
				})}
			</div>
		</div>
	);
};

--- END OF features\dashboard\components\ActiveQuestsWidget.jsx ---

--- FILE: features\dashboard\components\CampaignHero.jsx ---
import { Sparkles, Calendar, MapPin, Users, Swords } from 'lucide-react';
import { clsx } from 'clsx';

export const CampaignHero = ({ campaign, stats }) => {
	const logoPath = `${import.meta.env.BASE_URL}logo_detailed.png`;

	return (
		<div className='relative overflow-hidden border-b border-border bg-background'>
			{/* Gradient Backdrop - Subtler in dark mode */}
			<div className='absolute inset-0 bg-gradient-to-br from-primary/10 via-background to-background' />

			{/* Background Pattern */}
			<div
				className='absolute inset-0 opacity-[0.05]'
				style={{
					backgroundImage: `radial-gradient(circle at 1px 1px, currentColor 1px, transparent 0)`,
					backgroundSize: '40px 40px',
				}}
			/>

			<div className='relative max-w-[1600px] mx-auto px-4 sm:px-6 py-12 md:py-16'>
				<div className='flex flex-col md:flex-row md:items-center gap-8'>
					{/* Logo */}
					<div className='shrink-0'>
						<img src={logoPath} alt='Campaign Logo' className='h-32 md:h-40 mx-auto drop-shadow-2xl opacity-100' />
					</div>

					{/* Campaign Info */}
					<div className='flex-1 text-center md:text-left'>
						<div className='flex items-center justify-center md:justify-start gap-3 mb-3'>
							<Sparkles size={20} className='text-primary' />
							<span className='text-xs font-bold uppercase tracking-widest text-primary'>Campaign Chronicle</span>
						</div>
						<h1 className='text-4xl md:text-5xl font-serif font-bold text-foreground mb-4 leading-tight'>
							{campaign?.name || 'Your Campaign'}
						</h1>
						{campaign?.description && (
							<p className='text-sm md:text-base text-muted-foreground leading-relaxed max-w-2xl mx-auto md:mx-0'>
								{campaign.description}
							</p>
						)}
					</div>

					{/* Stats Grid */}
					<div className='grid grid-cols-2 md:grid-cols-4 lg:grid-cols-2 gap-4 md:gap-6 w-full md:w-auto'>
						<StatBadge icon={Calendar} label='Sessions' value={stats?.totalSessions || 0} />
						<StatBadge icon={Swords} label='Encounters' value={stats?.totalEncounters || 0} />
						<StatBadge icon={Users} label='NPCs Met' value={stats?.uniqueNPCs || 0} />
						<StatBadge icon={MapPin} label='Locations' value={stats?.uniqueLocations || 0} />
					</div>
				</div>
			</div>
		</div>
	);
};

const StatBadge = ({ icon: Icon, label, value }) => (
	<div className='bg-card/50 backdrop-blur-sm border border-border rounded-lg p-4 shadow-sm hover:border-primary/50 transition-colors'>
		<div className='flex items-center gap-2 text-muted-foreground mb-1'>
			<Icon size={14} strokeWidth={2.5} />
			<span className='text-[10px] font-bold uppercase tracking-wider'>{label}</span>
		</div>
		<p className='text-3xl font-serif font-bold text-foreground'>{value}</p>
	</div>
);

--- END OF features\dashboard\components\CampaignHero.jsx ---

--- FILE: features\dashboard\components\LatestSessionCard.jsx ---
import { Link } from 'react-router-dom';
import { Calendar, ArrowRight, Sparkles, MapPin, Users, Scroll, Swords } from 'lucide-react';
import { clsx } from 'clsx';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import { SectionDivider } from '@/shared/components/ui/SectionDivider';

export const LatestSessionCard = ({ session }) => {
	const keyEvents = session.events
		?.filter((e) => {
			const isImportant = [
				'combat',
				'quest_started',
				'quest_progressed',
				'npc_encountered',
				'location_discovered',
			].includes(e.event_type?.toLowerCase());
			return isImportant || (e.relationships && e.relationships.length > 2);
		})
		.slice(0, 5);

	const mentionsByType = session.mentions
		? Object.entries(session.mentions)
				.map(([type, items]) => ({ type, items: items.slice(0, 5), total: items.length }))
				.filter((g) => g.total > 0)
		: [];

	return (
		<div className='bg-background border-2 border-primary/20 rounded-2xl shadow-2xl overflow-hidden hover:border-primary/40 transition-all group'>
			{/* Header Banner */}
			<div className='bg-gradient-to-r from-primary/10 via-primary/5 to-transparent px-6 py-4 border-b border-border/50'>
				<div className='flex items-center justify-between'>
					<div className='flex items-center gap-3'>
						<div className='p-2 bg-primary/10 rounded-lg border border-primary/20'>
							<Sparkles size={20} className='text-primary' />
						</div>
						<div>
							<span className='text-xs font-bold uppercase tracking-widest text-primary block mb-0.5'>
								Latest Session
							</span>
							<div className='flex items-center gap-2'>
								<span className='text-[11px] font-bold uppercase tracking-wider text-muted-foreground bg-muted px-2 py-0.5 rounded border border-border'>
									Session {session.session_number - 1}
								</span>
								{session.session_date && (
									<span className='text-xs text-muted-foreground flex items-center gap-1'>
										<Calendar size={11} strokeWidth={2.5} />
										{session.session_date}
									</span>
								)}
							</div>
						</div>
					</div>
					<Link
						to={`/wiki/session/${session.id}`}
						className='flex items-center gap-2 px-4 py-2 bg-primary/10 hover:bg-primary/20 text-primary font-semibold text-sm rounded-lg border border-primary/20 transition-all group-hover:translate-x-1'>
						Full Details
						<ArrowRight size={16} />
					</Link>
				</div>
			</div>

			{/* Content */}
			<div className='p-6'>
				{/* Title & Description */}
				<h2 className='text-3xl font-serif font-bold text-foreground mb-3 leading-tight'>{session.name}</h2>
				{session.description && (
					<p className='text-sm text-muted-foreground leading-relaxed mb-6 max-w-3xl'>{session.description}</p>
				)}

				<SectionDivider />

				{/* Two Column Layout */}
				<div className='grid grid-cols-1 lg:grid-cols-2 gap-8 mt-6'>
					{/* Left: Key Events */}
					<div>
						<h3 className='text-sm font-bold uppercase tracking-wider text-muted-foreground mb-4 flex items-center gap-2'>
							<Swords size={14} className='text-primary' />
							Key Moments
						</h3>
						{keyEvents && keyEvents.length > 0 ? (
							<div className='space-y-3'>
								{keyEvents.map((event) => (
									<div key={event.id} className='flex items-start gap-3 group/item'>
										<div className='shrink-0 w-2 h-2 rounded-full bg-primary/40 mt-2 group-hover/item:bg-primary transition-colors' />
										<div className='flex-1 min-w-0'>
											<p className='text-sm font-semibold text-foreground leading-snug mb-0.5'>{event.title}</p>
											{event.description && (
												<p className='text-xs text-muted-foreground line-clamp-2 leading-relaxed'>
													{event.description}
												</p>
											)}
										</div>
									</div>
								))}
							</div>
						) : (
							<p className='text-xs text-muted-foreground italic'>No events recorded</p>
						)}
					</div>

					{/* Right: Entity Mentions */}
					<div>
						<h3 className='text-sm font-bold uppercase tracking-wider text-muted-foreground mb-4 flex items-center gap-2'>
							<Users size={14} className='text-primary' />
							Entities Encountered
						</h3>
						<div className='space-y-4'>
							{mentionsByType.map(({ type, items, total }) => {
								const config = getEntityConfig(type);
								const Icon = config.icon;

								return (
									<div key={type}>
										<div className='flex items-center gap-2 mb-2'>
											<Icon size={12} className={clsx(config.tailwind.text, 'opacity-70')} strokeWidth={2.5} />
											<span className='text-xs font-bold text-muted-foreground uppercase tracking-wider'>
												{config.labelPlural}
											</span>
											<span className='text-[10px] font-bold text-muted-foreground bg-muted px-1.5 py-0.5 rounded-full border border-border'>
												{total}
											</span>
										</div>
										<div className='flex flex-wrap gap-1.5 ml-5'>
											{items.map((entity, idx) => (
												<Link
													key={`${entity.id}-${idx}`}
													to={`/wiki/${type}/${entity.id}`}
													className={clsx(
														'text-xs font-semibold px-2 py-1 rounded border transition-all hover:shadow-sm',
														config.tailwind.bg,
														config.tailwind.text,
														config.tailwind.border,
														'hover:scale-105'
													)}>
													{entity.name}
												</Link>
											))}
											{total > 5 && <span className='text-xs text-muted-foreground px-2 py-1'>+{total - 5} more</span>}
										</div>
									</div>
								);
							})}
						</div>
					</div>
				</div>
			</div>
		</div>
	);
};

--- END OF features\dashboard\components\LatestSessionCard.jsx ---

--- FILE: features\dashboard\components\QuickInsights.jsx ---
import { TrendingUp, Trophy, Map, Users } from 'lucide-react';
import { clsx } from 'clsx';

export const QuickInsights = ({ stats, sessions }) => {
	const insights = [
		{
			icon: TrendingUp,
			label: 'Most Active Session',
			value: stats?.mostActiveSession?.title || 'N/A',
			subtitle: `${stats?.mostActiveSession?.eventCount || 0} events`,
			color: 'text-blue-600',
			bg: 'bg-blue-500/10',
			border: 'border-blue-500/30',
		},
		{
			icon: Map,
			label: 'Most Visited Location',
			value: stats?.topLocation?.name || 'N/A',
			subtitle: `${stats?.topLocation?.visits || 0} visits`,
			color: 'text-emerald-600',
			bg: 'bg-emerald-500/10',
			border: 'border-emerald-500/30',
		},
		{
			icon: Users,
			label: 'Most Encountered NPC',
			value: stats?.topNPC?.name || 'N/A',
			subtitle: `${stats?.topNPC?.mentions || 0} mentions`,
			color: 'text-amber-600',
			bg: 'bg-amber-500/10',
			border: 'border-amber-500/30',
		},
		{
			icon: Trophy,
			label: 'Quests Completed',
			value: stats?.completedQuests || 0,
			subtitle: `${stats?.activeQuests || 0} still active`,
			color: 'text-purple-600',
			bg: 'bg-purple-500/10',
			border: 'border-purple-500/30',
		},
	];

	return (
		<div>
			<h2 className='text-xl font-serif font-bold text-foreground mb-4'>Campaign Insights</h2>
			<div className='grid grid-cols-1 md:grid-cols-2 gap-4'>
				{insights.map((insight, idx) => {
					const Icon = insight.icon;
					return (
						<div
							key={idx}
							className={clsx('bg-background border rounded-lg p-4 hover:shadow-md transition-all', insight.border)}>
							<div className='flex items-start gap-3'>
								<div className={clsx('p-2 rounded-lg shrink-0', insight.bg)}>
									<Icon size={20} className={insight.color} strokeWidth={2.5} />
								</div>
								<div className='flex-1 min-w-0'>
									<p className='text-[10px] font-bold uppercase tracking-wider text-muted-foreground mb-1'>
										{insight.label}
									</p>
									<p className='text-lg font-serif font-bold text-foreground truncate mb-0.5'>{insight.value}</p>
									<p className='text-xs text-muted-foreground'>{insight.subtitle}</p>
								</div>
							</div>
						</div>
					);
				})}
			</div>
		</div>
	);
};

--- END OF features\dashboard\components\QuickInsights.jsx ---

--- FILE: features\dashboard\components\RecentEncountersWidget.jsx ---
import { Link } from 'react-router-dom';
import { Swords, Skull } from 'lucide-react';
import { clsx } from 'clsx';

export const RecentEncountersWidget = ({ encounters }) => {
	return (
		<div className='bg-background border border-border rounded-lg shadow-sm overflow-hidden'>
			<div className='px-4 py-3 bg-muted border-b border-border flex items-center justify-between'>
				<h3 className='text-sm font-bold uppercase tracking-wider text-foreground flex items-center gap-2'>
					<Swords size={14} className='text-red-600' />
					Recent Encounters
				</h3>
				<span className='text-xs font-bold text-muted-foreground bg-background px-2 py-0.5 rounded-full border border-border'>
					{encounters.length}
				</span>
			</div>
			<div className='divide-y divide-border'>
				{encounters.map((encounter) => (
					<Link
						key={encounter.id}
						to={`/wiki/encounter/${encounter.id}`}
						className='block px-4 py-3 hover:bg-muted/50 transition-colors group'>
						<div className='flex items-start gap-3'>
							<Skull size={16} className='text-red-500 shrink-0 mt-0.5' strokeWidth={2.5} />
							<div className='flex-1 min-w-0'>
								<p className='text-sm font-semibold text-foreground group-hover:text-primary transition-colors mb-0.5'>
									{encounter.name}
								</p>
								{encounter.session && (
									<p className='text-xs text-muted-foreground'>Session {encounter.session.session_number - 1}</p>
								)}
							</div>
						</div>
					</Link>
				))}
			</div>
		</div>
	);
};

--- END OF features\dashboard\components\RecentEncountersWidget.jsx ---

--- FILE: features\dashboard\components\RecentSessionsList.jsx ---
import { Link } from 'react-router-dom';
import { Calendar, ArrowRight } from 'lucide-react';
import { clsx } from 'clsx';

export const RecentSessionsList = ({ sessions }) => {
	return (
		<div>
			<h2 className='text-xl font-serif font-bold text-foreground mb-4'>Recent Sessions</h2>
			<div className='space-y-3'>
				{sessions.map((session) => (
					<Link
						key={session.id}
						to={`/wiki/session/${session.id}`}
						className='block bg-background border border-border rounded-lg p-4 hover:border-primary/30 hover:shadow-md transition-all group'>
						<div className='flex items-start justify-between gap-4'>
							<div className='flex-1 min-w-0'>
								<div className='flex items-center gap-2 mb-1'>
									<span className='text-[10px] font-bold uppercase tracking-wider text-muted-foreground bg-muted px-2 py-0.5 rounded border border-border'>
										Session {session.session_number - 1}
									</span>
									{session.session_date && (
										<span className='text-xs text-muted-foreground flex items-center gap-1'>
											<Calendar size={10} />
											{session.session_date}
										</span>
									)}
								</div>
								<h3 className='text-base font-serif font-bold text-foreground mb-1 group-hover:text-primary transition-colors'>
									{session.name}
								</h3>
								{session.description && (
									<p className='text-xs text-muted-foreground line-clamp-2 leading-relaxed'>{session.description}</p>
								)}
								{session.events && session.events.length > 0 && (
									<div className='mt-2 flex items-center gap-2 text-xs text-muted-foreground'>
										<span>{session.events.length} events</span>
										{session.mentions && (
											<>
												<span>â€¢</span>
												<span>
													{Object.values(session.mentions).reduce((sum, arr) => sum + arr.length, 0)} entities
												</span>
											</>
										)}
									</div>
								)}
							</div>
							<ArrowRight
								size={18}
								className='shrink-0 text-muted-foreground/70 group-hover:text-primary group-hover:translate-x-1 transition-all'
							/>
						</div>
					</Link>
				))}
			</div>
		</div>
	);
};

--- END OF features\dashboard\components\RecentSessionsList.jsx ---

--- FILE: features\dashboard\components\SessionRecapCard.jsx ---
import { Link } from 'react-router-dom';
import { Calendar, ArrowRight, Swords, Users, MapPin, Scroll } from 'lucide-react';
import { clsx } from 'clsx';
import EntityIcon from '@/domain/entity/components/EntityIcon';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';

export const SessionRecapCard = ({ session, featured = false }) => {
	// Extract highlights (events with most mentions or specific types)
	const highlights = session.events
		?.filter((e) => {
			const hasMentions = e.relationships?.length > 0;
			const isImportant = ['combat', 'quest_started', 'quest_progressed', 'npc_encountered'].includes(
				e.event_type?.toLowerCase()
			);
			return hasMentions || isImportant;
		})
		.slice(0, 3);

	// Count mentions by type
	const mentionCounts = session.mentions
		? Object.entries(session.mentions).reduce((acc, [type, items]) => {
				if (items.length > 0) {
					acc.push({ type, count: items.length, items: items.slice(0, 3) });
				}
				return acc;
		  }, [])
		: [];

	return (
		<Link
			to={`/wiki/session/${session.id}`}
			className={clsx(
				'block group transition-all',
				featured
					? 'bg-background border-2 border-accent/30 rounded-xl p-6 shadow-lg hover:shadow-xl hover:border-accent/50'
					: 'bg-background border border-border rounded-lg p-4 shadow-sm hover:shadow-md hover:border-accent/30'
			)}>
			{/* Header */}
			<div className='flex items-start justify-between mb-4'>
				<div className='flex-1 min-w-0'>
					<div className='flex items-center gap-2 mb-1'>
						<span
							className={clsx(
								'text-[10px] font-bold uppercase tracking-wider px-2 py-0.5 rounded',
								featured
									? 'bg-accent/10 text-primary border border-accent/30'
									: 'bg-muted text-muted-foreground border border-border'
							)}>
							Session {session.session_number - 1}
						</span>
						{session.session_date && (
							<span className='text-xs text-muted-foreground flex items-center gap-1'>
								<Calendar size={10} />
								{session.session_date}
							</span>
						)}
					</div>
					<h3
						className={clsx(
							'font-serif font-bold group-hover:text-primary transition-colors',
							featured ? 'text-2xl mb-2' : 'text-lg mb-1'
						)}>
						{session.name}
					</h3>
					{session.description && (
						<p className={clsx('text-muted-foreground leading-relaxed', featured ? 'text-sm' : 'text-xs line-clamp-2')}>
							{session.description}
						</p>
					)}
				</div>
				<ArrowRight
					size={featured ? 20 : 16}
					className='shrink-0 text-muted-foreground/70 group-hover:text-primary group-hover:translate-x-1 transition-all'
				/>
			</div>

			{/* Highlights */}
			{highlights && highlights.length > 0 && (
				<div className='mb-4'>
					<h4 className='text-xs font-bold uppercase tracking-wider text-muted-foreground mb-2 flex items-center gap-1'>
						<Swords size={10} /> Key Moments
					</h4>
					<div className='space-y-1.5'>
						{highlights.map((event) => (
							<div key={event.id} className='flex items-start gap-2 text-xs'>
								<span className='text-accent mt-0.5'>â€¢</span>
								<span className='text-foreground leading-snug'>{event.title}</span>
							</div>
						))}
					</div>
				</div>
			)}

			{/* Mentions Summary */}
			{mentionCounts.length > 0 && (
				<div className='flex flex-wrap gap-3 pt-3 border-t border-border/50'>
					{mentionCounts.map(({ type, count, items }) => {
						const config = getEntityConfig(type);
						const Icon = config.icon;

						return (
							<div key={type} className='flex items-center gap-2'>
								<div
									className={clsx(
										'flex items-center gap-1 text-[10px] font-medium px-2 py-1 rounded border',
										config.tailwind.bg,
										config.tailwind.text,
										config.tailwind.border
									)}>
									<Icon size={10} />
									<span className='font-bold'>{count}</span>
									<span className='opacity-70'>{config.labelPlural}</span>
								</div>
							</div>
						);
					})}
				</div>
			)}
		</Link>
	);
};

--- END OF features\dashboard\components\SessionRecapCard.jsx ---

--- FILE: features\graph\GraphPage.jsx ---
import { useGraphViewModel } from './useGraphView';
import { GraphLegend } from './components/GraphLegend';
import { CytoscapeCanvas } from './components/CytoscapeCanvas';
import LoadingSpinner from '@/shared/components/ui/LoadingSpinner';

export default function RelationshipGraph() {
	const { elements, isLoading } = useGraphViewModel();

	if (isLoading) {
		return (
			<div className='h-full flex items-center justify-center'>
				<LoadingSpinner text='Analyzing Connections...' />
			</div>
		);
	}

	return (
		// IMPLEMENTATION: Constellation Background via CSS radial-gradient
		// FIX: Replaced #e5e5e5 with var(--border) to fix contrast in dark mode
		<div
			className='h-full w-full relative bg-background overflow-hidden'
			style={{
				backgroundImage:
					'radial-gradient(circle at center, var(--border) 1px, transparent 1px), radial-gradient(circle at center, var(--border) 1px, transparent 1px)',
				backgroundSize: '40px 40px, 20px 20px',
				backgroundPosition: '0 0, 20px 20px',
			}}>
			{/* Overlay UI */}
			<GraphLegend />

			{/* The Graph Layer */}
			<CytoscapeCanvas elements={elements} />
		</div>
	);
}

--- END OF features\graph\GraphPage.jsx ---

--- FILE: features\graph\useGraphView.js ---
import { useQuery } from '@tanstack/react-query';
import { useMemo } from 'react';
import { getGraphData } from '@/features/graph/api/graphService';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { transformGraphData } from './utils/graphMapper'; // Import transform
// import './types';

export function useGraphViewModel() {
	const { campaignId } = useCampaign();

	const { data: rawEntities, isLoading } = useQuery({
		queryKey: ['graph', campaignId],
		queryFn: () => getGraphData(campaignId),
		enabled: !!campaignId,
	});

	// Use the pure transform function
	const elements = useMemo(() => {
		return transformGraphData(rawEntities);
	}, [rawEntities]);

	return { elements, isLoading };
}

--- END OF features\graph\useGraphView.js ---

--- FILE: features\graph\api\graphService.js ---
import { supabase } from '@/shared/api/supabaseClient';

export const getGraphData = async (campaignId) => {
	const { data, error } = await supabase
		.from('entity_complete_view')
		.select('id, name, type, relationships, attributes')
		.eq('campaign_id', campaignId);

	if (error) {
		console.error('Graph Fetch Error:', error);
		return [];
	}
	return data || [];
};

--- END OF features\graph\api\graphService.js ---

--- FILE: features\graph\components\CytoscapeCanvas.jsx ---
import { useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import cytoscape from 'cytoscape';
import fcose from 'cytoscape-fcose'; // IMPLEMENTATION: fCoSE
import { CYTOSCAPE_STYLES, LAYOUT_CONFIG } from '@/features/graph/config/graphStyles';

// Register the layout extension
cytoscape.use(fcose);

export const CytoscapeCanvas = ({ elements }) => {
	const containerRef = useRef(null);
	const cyRef = useRef(null);
	const navigate = useNavigate();

	useEffect(() => {
		if (!containerRef.current) return;

		// 1. Initialize Cytoscape
		cyRef.current = cytoscape({
			container: containerRef.current,
			elements: [],
			style: CYTOSCAPE_STYLES,
			layout: LAYOUT_CONFIG,
			wheelSensitivity: 3,
			minZoom: 0.2,
			maxZoom: 3,
			autoungrabify: true, // CHANGED: Set to true to disable node dragging
		});

		const cy = cyRef.current;

		// --- EVENT HANDLERS ---

		// 1. Click Node: Highlight Connections
		cy.on('tap', 'node', (evt) => {
			const node = evt.target;

			// Clear previous states
			cy.elements().removeClass('highlighted dimmed');

			const connectedEdges = node.connectedEdges();
			const connectedNodes = connectedEdges.connectedNodes();

			// Dim everything else
			cy.elements().difference(connectedNodes.union(connectedEdges).union(node)).addClass('dimmed');

			// Highlight selection
			node.addClass('highlighted');
			connectedNodes.addClass('highlighted');
			connectedEdges.addClass('highlighted');
		});

		// 2. Click Background: Reset
		cy.on('tap', (evt) => {
			if (evt.target === cy) {
				cy.elements().removeClass('highlighted dimmed');
			}
		});

		// 3. IMPLEMENTATION: Double Click to Navigate
		cy.on('dblclick', 'node', (evt) => {
			const node = evt.target;
			const { id, type } = node.data();
			if (id && type) {
				navigate(`/wiki/${type}/${id}`);
			}
		});

		return () => {
			if (cyRef.current) {
				cyRef.current.destroy();
				cyRef.current = null;
			}
		};
	}, [navigate]);

	// 2. Handle Data Updates
	useEffect(() => {
		if (!cyRef.current || !elements) return;

		const cy = cyRef.current;

		cy.batch(() => {
			cy.elements().remove();
			cy.add(elements);
		});

		if (elements.length > 0) {
			// Run fCoSE layout
			cy.layout(LAYOUT_CONFIG).run();
		}
	}, [elements]);

	return <div ref={containerRef} className='absolute inset-0 w-full h-full' />;
};

--- END OF features\graph\components\CytoscapeCanvas.jsx ---

--- FILE: features\graph\components\GraphLegend.jsx ---
import { ENTITY_CONFIG } from '@/domain/entity/config/entityConfig'; // Adjust path

export const GraphLegend = () => {
	// Filter out the 'default' config to keep legend clean
	const legendItems = Object.values(ENTITY_CONFIG).filter((c) => c.label !== 'Entity');

	return (
		<div className='absolute top-4 left-4 z-10 bg-background/90 p-3 rounded shadow border border-border backdrop-blur pointer-events-none select-none'>
			<h2 className='text-xs font-bold uppercase text-muted-foreground/70 mb-2'>Legend</h2>
			<div className='space-y-1.5'>
				{legendItems.map((config) => (
					<div key={config.label} className='flex items-center gap-2 text-xs font-medium text-muted-foreground'>
						<div className='w-2.5 h-2.5 rounded-full shadow-sm' style={{ backgroundColor: config.color }} />
						{config.label}
					</div>
				))}
			</div>
		</div>
	);
};

--- END OF features\graph\components\GraphLegend.jsx ---

--- FILE: features\graph\config\graphStyles.js ---
export const CYTOSCAPE_STYLES = [
	// --- MAJOR NODES (Hubs/VIPs) ---
	{
		selector: 'node',
		style: {
			label: 'data(label)',
			'border-color': 'data(color)',
			'background-image': 'data(image)',
			'background-fit': 'cover',
			'border-width': 2,
			width: 'mapData(degree, 3, 20, 30, 50)',
			height: 'mapData(degree, 3, 20, 30, 50)',
			'font-family': 'Inter, sans-serif',
			'font-size': '10pt',
			'font-weight': '500',
			'text-valign': 'bottom',
			'text-margin-y': 6,
			'letter-spacing': 0,

			// FIX: Hardcode robust colors that work on both backgrounds
			// Using a semi-transparent white background for text ensures readability
			// on both the Dark Mode stars and the Parchment texture.
			'text-background-color': '#ffffff',
			'text-background-opacity': 0.7,
			'text-background-padding': 2,
			'text-background-shape': 'roundrectangle',

			// Dark text is readable against the white text-background
			color: '#000000',

			'text-wrap': 'ellipsis',
			'text-max-width': 100,
			'transition-property': 'opacity, width, height',
			'transition-duration': '0.3s',
		},
	},
	// --- MINOR NODES (Dots) ---
	{
		selector: 'node.minor',
		style: {
			width: 20,
			height: 20,
			'background-color': 'data(color)',
			'border-width': 1,
			'border-color': 'data(color)',
			'font-size': 10,
			'text-margin-y': 4,

			// Minor nodes: clear text with white outline (halo)
			// This is cleaner than a box for small items
			'text-background-opacity': 0,
			'text-outline-color': '#ffffff',
			'text-outline-width': 2,
			'text-outline-opacity': 0.8,
			color: '#374151', // Gray-700
		},
	},
	// --- EDGES ---
	{
		selector: 'edge',
		style: {
			'line-color': 'data(color)',
			'target-arrow-color': 'data(color)',
			'curve-style': 'bezier',
			width: 1,
			opacity: 0.3,
			'arrow-scale': 0.6,
			'target-arrow-shape': 'triangle',
			events: 'no',
		},
	},
	// --- INTERACTION STATES ---
	{
		selector: '.dimmed',
		style: {
			opacity: 0.05,
			'text-opacity': 0.1,
			'border-opacity': 0.1,
			'background-opacity': 0.1,
		},
	},
	{
		selector: '.highlighted',
		style: {
			'z-index': 9999,
			'text-wrap': 'wrap',
		},
	},
	{
		selector: 'edge.highlighted',
		style: {
			width: 2,
			opacity: 1,
		},
	},
];

export const LAYOUT_CONFIG = {
	name: 'fcose',
	quality: 'default',
	randomize: false,
	animate: false,
	animationDuration: 1000,
	fit: true,
	padding: 50,
	nodeDimensionsIncludeLabels: true,
	nodeRepulsion: (node) => {
		const degree = node.data('degree') || 0;
		return 40000 + degree * 5000;
	},
	idealEdgeLength: (edge) => {
		const d1 = edge.source().data('degree') || 0;
		const d2 = edge.target().data('degree') || 0;
		const maxDegree = Math.max(d1, d2);
		return 150 + maxDegree * 30;
	},
	edgeElasticity: (edge) => 0.1,
	gravity: 0.25,
	gravityRange: 3.8,
	numIter: 2500,
	tile: true,
	tilingPaddingVertical: 100,
	tilingPaddingHorizontal: 100,
};

--- END OF features\graph\config\graphStyles.js ---

--- FILE: features\graph\utils\graphMapper.js ---
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import { resolveImageUrl } from '@/shared/utils/imageUtils';
import { getAffinityRank } from '@/domain/entity/utils/statusUtils';

const INK_COLORS = {
	ALLY: '#4d7c0f',
	ENEMY: '#7f1d1d',
	NEUTRAL: '#78716c',
};

const FALLBACK_ICON_PATH = 'images/icons';

export const transformGraphData = (rawEntities) => {
	if (!rawEntities || rawEntities.length === 0) return [];

	const entities = rawEntities.filter((e) => {
		const type = e.type?.toLowerCase();
		return type !== 'session_event' && type !== 'event';
	});

	const nodes = [];
	const edges = [];
	const entityIds = new Set(entities.map((e) => e.id));
	const connectedNodeIds = new Set();
	const uniqueEdgeTracker = new Set();
	const degreeMap = new Map();

	// Pass 1: Edges
	entities.forEach((entity) => {
		(entity.relationships || []).forEach((rel) => {
			if (!entityIds.has(rel.entity_id)) return;

			const [id1, id2] = [entity.id, rel.entity_id].sort();
			const edgeKey = `${id1}-${id2}`;

			if (uniqueEdgeTracker.has(edgeKey)) return;
			uniqueEdgeTracker.add(edgeKey);

			connectedNodeIds.add(entity.id);
			connectedNodeIds.add(rel.entity_id);

			degreeMap.set(entity.id, (degreeMap.get(entity.id) || 0) + 1);
			degreeMap.set(rel.entity_id, (degreeMap.get(rel.entity_id) || 0) + 1);

			const rank = getAffinityRank(rel.type);
			let edgeColor = INK_COLORS.NEUTRAL;
			if (rank === 1) edgeColor = INK_COLORS.ALLY;
			if (rank === 3) edgeColor = INK_COLORS.ENEMY;

			edges.push({
				group: 'edges',
				data: {
					id: `e-${edgeKey}`,
					source: entity.id,
					target: rel.entity_id,
					color: edgeColor,
				},
			});
		});
	});

	// Pass 2: Nodes
	entities.forEach((entity) => {
		if (!connectedNodeIds.has(entity.id)) return;

		const config = getEntityConfig(entity.type);
		const finalIconUrl = resolveImageUrl(entity.attributes, 'icon') || `${FALLBACK_ICON_PATH}/${entity.type}.png`;
		const degree = degreeMap.get(entity.id) || 1;
		const isMinor = degree < 3;

		nodes.push({
			group: 'nodes',
			classes: isMinor ? 'minor' : 'major',
			data: {
				id: entity.id,
				label: entity.name,
				color: config.color,
				image: finalIconUrl,
				type: entity.type,
				degree: degree,
			},
		});
	});

	return [...nodes, ...edges];
};

--- END OF features\graph\utils\graphMapper.js ---

--- FILE: features\navigation\MainLayout.jsx ---
import { Outlet } from 'react-router-dom';
import { Menu, Search } from 'lucide-react';
import { useMainLayout } from '@/features/navigation/useNavigation';
import { Sidebar } from './components/Sidebar';
import DevAdminButton from '@/shared/components/ui/DevAdminButton';
import Breadcrumbs from '@/shared/components/ui/Breadcrumbs';
import GlobalSearch from '@/features/search/GlobalSearch';
import { SearchProvider, useSearch } from '@/features/search/SearchContext';

const MobileHeaderActions = ({ vm }) => {
	const { openSearch } = useSearch();

	return (
		// CHANGED: Added pt-safe for notch support and min-h for touch targets
		<div className='lg:hidden flex items-center justify-between px-4 pb-3 pt-[calc(0.75rem+env(safe-area-inset-top))] border-b border-border bg-background/95 backdrop-blur-md shrink-0 sticky top-0 z-40 transition-all'>
			<button
				onClick={() => vm.setSidebarOpen(true)}
				className='p-2 -ml-2 text-muted-foreground hover:bg-muted rounded-full active:scale-95 transition-transform'
				aria-label='Open Menu'>
				<Menu size={24} strokeWidth={1.5} />
			</button>

			<h1 className='text-base font-serif font-bold truncate max-w-[60%]'>{vm.campaign?.name || 'Campaign'}</h1>

			<button
				onClick={openSearch}
				className='p-2 -mr-2 text-muted-foreground hover:bg-muted rounded-full active:scale-95 transition-transform'
				aria-label='Search'>
				<Search size={24} strokeWidth={1.5} />
			</button>
		</div>
	);
};

export default function MainLayout() {
	const vm = useMainLayout();

	return (
		<SearchProvider>
			<div className='flex h-full w-full bg-background text-foreground overflow-hidden'>
				<Sidebar vm={vm} />
				<main className='flex-1 h-full overflow-hidden bg-background relative flex flex-col w-full'>
					{/* Mobile Header */}
					<MobileHeaderActions vm={vm} />

					{/* Desktop Breadcrumbs */}
					<div className='absolute top-4 left-6 z-40 hidden lg:block pointer-events-none'>
						<div className='pointer-events-auto'>
							<Breadcrumbs />
						</div>
					</div>

					{/* Content Area */}
					<div className='flex-1 overflow-hidden relative w-full'>
						<Outlet />
					</div>

					<DevAdminButton />
				</main>

				<GlobalSearch />
			</div>
		</SearchProvider>
	);
}

--- END OF features\navigation\MainLayout.jsx ---

--- FILE: features\navigation\useNavigation.js ---
import { useState, useMemo, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { getCampaigns } from '@/features/campaign/api/campaignService';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { NAV_STRUCTURE } from './config/navConfig';
// import './types';

export function useMainLayout() {
	const navigate = useNavigate();
	const location = useLocation();
	const { campaignId, setCampaignId } = useCampaign();
	const [sidebarOpen, setSidebarOpen] = useState(false);

	const { data: campaigns } = useQuery({
		queryKey: ['campaigns'],
		queryFn: getCampaigns,
		staleTime: 1000 * 60 * 10,
	});

	const currentCampaignData = campaigns?.find((c) => c.id === campaignId);

	const campaign = currentCampaignData
		? {
				name: currentCampaignData.name || 'Campaign',
				initial: (currentCampaignData.name?.[0] || 'C').toUpperCase(),
		  }
		: null;

	// --- NEW: Dynamic Document Title ---
	useEffect(() => {
		if (campaign?.name) {
			document.title = `${campaign.name} | Campaign Manager`;
		}
		// Reset when unmounting (leaving campaign view)
		return () => {
			document.title = 'D&D Campaign Manager';
		};
	}, [campaign]);
	// -----------------------------------

	const navStructure = useMemo(() => {
		const hasMapData = !!currentCampaignData?.map_data;

		return NAV_STRUCTURE.map((group) => ({
			...group,
			items: group.items.filter((item) => {
				if (item.key === 'atlas') {
					return hasMapData;
				}
				return true;
			}),
		})).filter((group) => group.items.length > 0);
	}, [currentCampaignData]);

	const navigateTo = (path) => {
		navigate(path);
		setSidebarOpen(false);
	};

	const onSwitchCampaign = () => {
		setCampaignId(null);
		navigate('/wiki/session');
	};

	return {
		sidebarOpen,
		setSidebarOpen,
		currentPath: location.pathname,
		navigateTo,
		campaign,
		onSwitchCampaign,
		navStructure,
	};
}

--- END OF features\navigation\useNavigation.js ---

--- FILE: features\navigation\components\Sidebar.jsx ---
import { clsx } from 'clsx';
import { Drawer } from '@/shared/components/ui/Drawer';
import { SidebarHeader } from './SidebarHeader';
import { SidebarNav } from './SidebarNav';
import { SidebarFooter } from './SidebarFooter';

export const Sidebar = ({ vm }) => {
	const { sidebarOpen, setSidebarOpen, campaign, navStructure, currentPath, navigateTo, onSwitchCampaign } = vm;

	const SidebarContent = () => (
		// FIXED: Uses semantic colors
		<div className='flex flex-col h-full bg-muted border-r border-border'>
			<SidebarHeader campaign={campaign} />
			<SidebarNav structure={navStructure} currentPath={currentPath} onNavigate={navigateTo} />
			<SidebarFooter onSwitch={onSwitchCampaign} />
		</div>
	);

	return (
		<>
			{/* Mobile */}
			<Drawer
				isOpen={sidebarOpen}
				onClose={() => setSidebarOpen(false)}
				title={campaign?.name || 'Menu'}
				position='left'
				className='w-72'>
				<div className='flex flex-col h-full bg-muted'>
					{/* FIX: Pass onSearch to close sidebar when search is triggered on mobile */}
					<SidebarHeader campaign={campaign} onSearch={() => setSidebarOpen(false)} />
					<SidebarNav structure={navStructure} currentPath={currentPath} onNavigate={navigateTo} />
					<SidebarFooter onSwitch={onSwitchCampaign} />
				</div>
			</Drawer>

			{/* Desktop */}
			<aside className='hidden lg:flex w-64 flex-col h-full border-r border-border bg-muted shrink-0'>
				<SidebarContent />
			</aside>
		</>
	);
};

--- END OF features\navigation\components\Sidebar.jsx ---

--- FILE: features\navigation\components\SidebarFooter.jsx ---
import { Moon, Sun, Sword, Settings } from 'lucide-react';
import { useTheme, THEMES } from '@/shared/hooks/useTheme';

export const SidebarFooter = ({ onSwitch }) => {
	const { theme, cycleTheme } = useTheme();

	const getThemeIcon = () => {
		switch (theme) {
			case THEMES.DARK:
				return <Moon size={14} className='mr-2' />;
			case THEMES.DND:
				return <Sword size={14} className='mr-2' />;
			default:
				return <Sun size={14} className='mr-2' />;
		}
	};

	const getThemeLabel = () => {
		switch (theme) {
			case THEMES.DARK:
				return 'Dark Mode';
			case THEMES.DND:
				return 'D&D PHB';
			default:
				return 'Light Mode';
		}
	};

	return (
		<div className='mt-auto p-4 border-t border-border space-y-2 bg-inherit'>
			<button
				onClick={cycleTheme}
				className='flex items-center w-full px-2 py-2 text-xs font-medium text-muted-foreground hover:text-foreground hover:bg-black/5 rounded-md transition-colors'>
				{getThemeIcon()}
				Theme: {getThemeLabel()}
			</button>

			<button
				onClick={onSwitch}
				className='flex items-center w-full px-2 py-2 text-xs text-muted-foreground hover:text-foreground hover:bg-black/5 rounded-md transition-colors'>
				<Settings size={14} className='mr-2' />
				Switch Campaign
			</button>
		</div>
	);
};

--- END OF features\navigation\components\SidebarFooter.jsx ---

--- FILE: features\navigation\components\SidebarHeader.jsx ---
import { SearchTrigger } from '@/features/search/components/SearchTrigger';

export const SidebarHeader = ({ campaign, onSearch }) => {
	return (
		<div className='p-4'>
			{/* Campaign Card */}
			<div className='hidden lg:flex items-center gap-3 px-2 py-2 mb-4 hover:bg-muted rounded-lg cursor-pointer transition-colors'>
				<div className='w-8 h-8 rounded bg-gradient-to-br from-amber-700 to-amber-900 flex items-center justify-center text-white font-serif font-bold shadow-sm'>
					{campaign?.initial || 'C'}
				</div>
				<div className='flex-1 min-w-0'>
					<h2 className='text-sm font-bold text-foreground font-serif'>{campaign?.name || 'Loading...'}</h2>
				</div>
			</div>

			{/* Global Search Trigger - Desktop */}
			<div className='lg:mb-6'>
				<SearchTrigger onClick={onSearch} />
			</div>
		</div>
	);
};

--- END OF features\navigation\components\SidebarHeader.jsx ---

--- FILE: features\navigation\components\SidebarNav.jsx ---
import { clsx } from 'clsx';

export const SidebarNav = ({ structure, currentPath, onNavigate }) => {
	return (
		<div className='flex-1 overflow-y-auto px-4 space-y-6'>
			{structure.map((group) => (
				<div key={group.title}>
					<h3 className='px-3 text-xs font-semibold text-muted-foreground/70 uppercase tracking-wider mb-2'>
						{group.title}
					</h3>
					<div className='space-y-0.5'>
						{group.items.map((item) => {
							const isWiki = item.path.startsWith('/wiki/');
							const active = isWiki ? currentPath.startsWith(item.path) : currentPath === item.path;
							const Icon = item.Icon;
							return (
								<button
									key={item.path}
									onClick={() => onNavigate(item.path)}
									className={clsx(
										'flex items-center w-full px-3 py-1.5 text-sm font-medium rounded-md transition-colors',
										active
											? 'bg-background shadow-sm ring-1 ring-border'
											: 'text-muted-foreground hover:bg-muted hover:text-foreground'
									)}>
									<Icon size={16} className={clsx('mr-2', active ? 'text-amber-600' : 'text-muted-foreground/70')} />
									{item.label}
								</button>
							);
						})}
					</div>
				</div>
			))}
		</div>
	);
};

--- END OF features\navigation\components\SidebarNav.jsx ---

--- FILE: features\navigation\config\navConfig.js ---
import { Map, History, Network, BookOpen, Users, Scroll, Sword, Shield, Home, Calendar } from 'lucide-react';

export const NAV_STRUCTURE = [
	{
		title: 'Overview',
		items: [{ label: 'Dashboard', Icon: Home, path: '/', key: 'dashboard' }],
	},
	{
		title: 'World',
		items: [
			{ label: 'Atlas', Icon: Map, path: '/atlas', key: 'atlas' },
			{ label: 'Timeline', Icon: History, path: '/timeline', key: 'timeline' },
			{ label: 'Graph', Icon: Network, path: '/relationships', key: 'graph' },
		],
	},
	{
		title: 'Wiki',
		items: [
			{ label: 'Sessions', Icon: BookOpen, path: '/wiki/session', key: 'session' },
			{ label: 'Characters', Icon: Users, path: '/wiki/character', key: 'character' },
			{ label: 'NPCs', Icon: Users, path: '/wiki/npc', key: 'npc' },
			{ label: 'Locations', Icon: Map, path: '/wiki/location', key: 'location' },
			{ label: 'Factions', Icon: Shield, path: '/wiki/faction', key: 'faction' },
			{ label: 'Quests', Icon: Scroll, path: '/wiki/quest', key: 'quest' },
			{ label: 'Encounters', Icon: Sword, path: '/wiki/encounter', key: 'encounter' },
		],
	},
];

--- END OF features\navigation\config\navConfig.js ---

--- FILE: features\search\GlobalSearch.jsx ---
import { useRef, useEffect } from 'react';
import { SearchModal } from './components/SearchModal';
import { useGlobalSearchViewModel } from './useGlobalSearch';

export default function GlobalSearch() {
	const vm = useGlobalSearchViewModel();
	const inputRef = useRef(null);

	// Focus input when opened
	useEffect(() => {
		if (vm.isOpen && inputRef.current) {
			// Small timeout to ensure DOM is ready on mobile transitions
			setTimeout(() => inputRef.current?.focus(), 50);
		}
	}, [vm.isOpen]);

	// If not open, don't render anything (Modal handles Portal)
	if (!vm.isOpen) return null;

	return <SearchModal vm={vm} inputRef={inputRef} />;
}

--- END OF features\search\GlobalSearch.jsx ---

--- FILE: features\search\SearchContext.jsx ---
import { createContext, useContext, useState, useCallback, useEffect } from 'react';

const SearchContext = createContext(null);

export const SearchProvider = ({ children }) => {
	const [isOpen, setIsOpen] = useState(false);
	const [query, setQuery] = useState('');

	// Keyboard shortcut listener (CMD+K)
	useEffect(() => {
		const handleKeyDown = (e) => {
			if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
				e.preventDefault();
				setIsOpen((prev) => !prev);
			}
			if (e.key === 'Escape' && isOpen) {
				setIsOpen(false);
			}
		};

		window.addEventListener('keydown', handleKeyDown);
		return () => window.removeEventListener('keydown', handleKeyDown);
	}, [isOpen]);

	const openSearch = useCallback(() => setIsOpen(true), []);
	const closeSearch = useCallback(() => {
		setIsOpen(false);
		setQuery(''); // Optional: clear query on close
	}, []);

	return (
		<SearchContext.Provider value={{ isOpen, query, setQuery, openSearch, closeSearch }}>
			{children}
		</SearchContext.Provider>
	);
};

export const useSearch = () => {
	const context = useContext(SearchContext);
	if (!context) throw new Error('useSearch must be used within SearchProvider');
	return context;
};

--- END OF features\search\SearchContext.jsx ---

--- FILE: features\search\useGlobalSearch.js ---
import { useState, useEffect, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { globalSearch } from '@/features/search/api/searchService';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import { transformSearchResults } from '@/features/search/utils/searchMapper';
import { useSearch } from './SearchContext'; // IMPORT CONTEXT

const STORAGE_KEY = 'recent-searches';

export function useGlobalSearchViewModel() {
	const navigate = useNavigate();
	const { campaignId } = useCampaign();

	// 1. Consume Context
	const { isOpen, openSearch: setIsOpen, closeSearch, query, setQuery } = useSearch();

	const [selectedIndex, setSelectedIndex] = useState(0);
	const [recentSearches, setRecentSearches] = useState(() => {
		try {
			const stored = localStorage.getItem(STORAGE_KEY);
			return stored ? JSON.parse(stored) : [];
		} catch {
			return [];
		}
	});

	// Fetch search results
	const { data: rawData, isLoading } = useQuery({
		queryKey: ['globalSearch', campaignId, query],
		queryFn: () => globalSearch(campaignId, query),
		enabled: !!campaignId && query.trim().length > 0,
		staleTime: 1000 * 30,
	});

	// Transform results
	const results = useMemo(() => {
		if (!rawData) return [];
		const processedItems = transformSearchResults(rawData);

		return processedItems.map((result) => {
			const config = getEntityConfig(result.type);
			return {
				id: result.id,
				name: result.name,
				type: result.type,
				typeLabel: result.type.toUpperCase(),
				description: result.description || '',
				icon: config.icon,
				theme: config.tailwind,
			};
		});
	}, [rawData]);

	const flattenedRawResults = useMemo(() => {
		if (!rawData) return [];
		return transformSearchResults(rawData);
	}, [rawData]);

	const recentSearchesViewModel = useMemo(() => {
		return recentSearches.map((result) => {
			const config = getEntityConfig(result.type);
			return {
				id: result.id,
				name: result.name,
				type: result.type,
				typeLabel: result.type.toUpperCase(),
				description: result.description || '',
				icon: config.icon,
				theme: config.tailwind,
			};
		});
	}, [recentSearches]);

	const handleSelect = (result) => {
		const rawResult = flattenedRawResults.find((r) => r.id === result.id);

		if (rawResult) {
			const toStore = {
				id: rawResult.id,
				name: rawResult.name,
				type: rawResult.type,
				description: rawResult.description || '',
			};
			const updated = [toStore, ...recentSearches.filter((r) => r.id !== toStore.id)].slice(0, 5);
			setRecentSearches(updated);
			try {
				localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
			} catch {}
		}

		navigate(`/wiki/${result.type}/${result.id}`);

		// Use Context Close
		closeSearch();
		setSelectedIndex(0);
	};

	const clearRecent = () => {
		setRecentSearches([]);
		try {
			localStorage.removeItem(STORAGE_KEY);
		} catch {}
	};

	// Arrow key navigation
	useEffect(() => {
		if (!isOpen || results.length === 0) return;

		const handleKeyDown = (e) => {
			if (e.key === 'ArrowDown') {
				e.preventDefault();
				setSelectedIndex((prev) => (prev + 1) % results.length);
			} else if (e.key === 'ArrowUp') {
				e.preventDefault();
				setSelectedIndex((prev) => (prev - 1 + results.length) % results.length);
			} else if (e.key === 'Enter' && results[selectedIndex]) {
				e.preventDefault();
				handleSelect(results[selectedIndex]);
			}
		};

		window.addEventListener('keydown', handleKeyDown);
		return () => window.removeEventListener('keydown', handleKeyDown);
	}, [isOpen, results, selectedIndex]);

	return {
		isOpen,
		setIsOpen, // Keeps API compatible with old components if they passed bool
		closeSearch, // New explicit close
		query,
		setQuery,
		results,
		isLoading,
		recentSearches: recentSearchesViewModel,
		selectedIndex,
		setSelectedIndex,
		handleSelect,
		clearRecent,
	};
}

--- END OF features\search\useGlobalSearch.js ---

--- FILE: features\search\api\searchService.js ---
import { supabase } from '@/shared/api/supabaseClient';

export const globalSearch = async (campaignId, query) => {
	if (!query || query.trim().length === 0) return { sessions: [], entities: [], sessionAttributes: [] };

	const searchTerm = `%${query.trim()}%`;

	// 1. Search Entities
	const { data: entities, error: entitiesError } = await supabase
		.from('entities')
		.select('id, name, type, description')
		.eq('campaign_id', campaignId)
		.or(`name.ilike.${searchTerm},description.ilike.${searchTerm}`)
		.limit(8);

	if (entitiesError) console.error('Entity search error:', entitiesError);

	// 2. Search Sessions
	const { data: sessions, error: sessionsError } = await supabase
		.from('sessions')
		.select('id, title, narrative')
		.eq('campaign_id', campaignId)
		.or(`title.ilike.${searchTerm},narrative.ilike.${searchTerm}`)
		.limit(5);

	if (sessionsError) console.error('Session search error:', sessionsError);

	// 3. Fetch Attributes for Sessions (if any found)
	let sessionAttributes = [];
	if (sessions && sessions.length > 0) {
		const sessionIds = sessions.map((s) => s.id);
		const { data } = await supabase.from('attributes').select('entity_id, name, value').in('entity_id', sessionIds);
		sessionAttributes = data || [];
	}

	return {
		sessions: sessions || [],
		entities: entities || [],
		sessionAttributes,
	};
};

--- END OF features\search\api\searchService.js ---

--- FILE: features\search\components\SearchFooter.jsx ---
export const SearchFooter = () => {
	return (
		<div className='flex items-center justify-between px-4 py-2.5 border-t border-border bg-muted/30 text-[10px] text-muted-foreground'>
			<div className='flex items-center gap-4'>
				<span className='flex items-center gap-1.5'>
					<kbd className='px-1.5 py-0.5 bg-background border border-border rounded font-semibold'>â†‘</kbd>
					<kbd className='px-1.5 py-0.5 bg-background border border-border rounded font-semibold'>â†“</kbd>
					<span>navigate</span>
				</span>
				<span className='flex items-center gap-1.5'>
					<kbd className='px-1.5 py-0.5 bg-background border border-border rounded font-semibold'>â†µ</kbd>
					<span>select</span>
				</span>
			</div>
			<span className='flex items-center gap-1.5'>
				<kbd className='px-1.5 py-0.5 bg-background border border-border rounded font-semibold'>ESC</kbd>
				<span>close</span>
			</span>
		</div>
	);
};

--- END OF features\search\components\SearchFooter.jsx ---

--- FILE: features\search\components\SearchModal.jsx ---
import { createPortal } from 'react-dom';
import { Search, X, Loader2 } from 'lucide-react';
import { SearchResults } from './SearchResults';
import { SearchFooter } from './SearchFooter';

export const SearchModal = ({ vm, inputRef }) => {
	return createPortal(
		// Fixed inset-0 for full screen coverage on mobile
		<div className='fixed inset-0 z-[100] flex flex-col lg:items-center lg:pt-[15vh] px-0 lg:px-4'>
			{/* Backdrop */}
			<div
				className='absolute inset-0 bg-background/95 lg:bg-black/60 lg:backdrop-blur-sm transition-all'
				onClick={vm.closeSearch}
			/>

			{/* Search Panel */}
			<div className='relative w-full lg:max-w-2xl bg-background lg:rounded-xl shadow-2xl border-b lg:border border-border overflow-hidden flex flex-col h-full lg:h-auto lg:max-h-[70vh] animate-in fade-in slide-in-from-bottom-2 lg:slide-in-from-top-4 duration-200'>
				{/* Search Input Area */}
				<div className='flex items-center gap-3 p-4 border-b border-border bg-background shrink-0'>
					<button onClick={vm.closeSearch} className='lg:hidden p-1 -ml-1 text-muted-foreground'>
						<X size={20} />
					</button>
					<Search size={18} className='text-muted-foreground/70 shrink-0 hidden lg:block' />

					<input
						ref={inputRef}
						type='text'
						value={vm.query}
						onChange={(e) => {
							vm.setQuery(e.target.value);
							vm.setSelectedIndex(0);
						}}
						placeholder='Search sessions, entities, lore...'
						className='flex-1 bg-transparent text-base lg:text-sm text-foreground placeholder:text-muted-foreground/70 outline-none h-10 lg:h-auto'
					/>

					{vm.isLoading && <Loader2 size={16} className='animate-spin text-amber-600' />}

					{vm.query && !vm.isLoading && (
						<button
							onClick={() => {
								vm.setQuery('');
								inputRef.current?.focus();
							}}
							className='p-1 text-muted-foreground/70 hover:text-foreground hover:bg-muted rounded transition-colors'>
							<X size={16} />
						</button>
					)}
					<kbd className='hidden lg:inline-block px-2 py-1 text-[10px] font-semibold text-muted-foreground/70 bg-muted border border-border rounded'>
						ESC
					</kbd>
				</div>

				{/* Results Area - Flex 1 for mobile scrolling */}
				<div className='flex-1 overflow-y-auto bg-muted/10 custom-scrollbar'>
					<SearchResults vm={vm} />
				</div>

				{/* Footer (Desktop Only) */}
				<div className='hidden lg:block'>
					<SearchFooter />
				</div>
			</div>
		</div>,
		document.body
	);
};

--- END OF features\search\components\SearchModal.jsx ---

--- FILE: features\search\components\SearchResultItem.jsx ---
import { clsx } from 'clsx';

export const SearchResultItem = ({ item, isSelected, onSelect, onHover }) => {
	return (
		<button
			onClick={onSelect}
			onMouseEnter={onHover}
			className={clsx(
				'w-full flex items-start gap-3 px-4 py-2.5 transition-colors text-left',
				isSelected ? 'bg-amber-500/10' : 'hover:bg-muted'
			)}>
			<div
				className={clsx(
					'shrink-0 w-9 h-9 rounded-lg border flex items-center justify-center',
					item.theme.bg,
					item.theme.border,
					item.theme.text
				)}>
				<item.icon size={16} />
			</div>
			<div className='flex-1 min-w-0'>
				<div className='flex items-center gap-2 mb-0.5'>
					<span className='text-sm font-semibold text-foreground truncate'>{item.name}</span>
					<span className='shrink-0 text-[10px] uppercase font-bold tracking-wider text-muted-foreground/70 bg-muted px-1.5 py-0.5 rounded'>
						{item.type}
					</span>
				</div>
				{item.description && <p className='text-xs text-muted-foreground line-clamp-2 leading-relaxed'>{item.description}</p>}
			</div>
			{isSelected && (
				<kbd className='shrink-0 text-[10px] font-semibold text-muted-foreground/70 bg-muted px-2 py-1 rounded border border-border'>
					â†µ
				</kbd>
			)}
		</button>
	);
};

--- END OF features\search\components\SearchResultItem.jsx ---

--- FILE: features\search\components\SearchResults.jsx ---
import { Search, Clock, Calendar, Database } from 'lucide-react';
import { clsx } from 'clsx';
import { SearchResultItem } from './SearchResultItem';

const GroupHeader = ({ label, icon: Icon }) => (
	<div className='px-4 py-2 mt-2 text-[10px] font-bold uppercase tracking-widest text-muted-foreground flex items-center gap-2 bg-muted/50 border-y border-border/50 sticky top-0 z-10 backdrop-blur-sm'>
		<Icon size={12} />
		{label}
	</div>
);

export const SearchResults = ({ vm }) => {
	const { query, results, isLoading, recentSearches, selectedIndex, setSelectedIndex, handleSelect, clearRecent } = vm;

	// GROUPING LOGIC
	const groupedResults = results.reduce(
		(acc, item) => {
			const group = item.type === 'session' ? 'sessions' : 'entities';
			if (!acc[group]) acc[group] = [];
			acc[group].push(item);
			return acc;
		},
		{ sessions: [], entities: [] }
	);

	return (
		<div className='pb-4'>
			{query.trim() === '' ? (
				// Recent Searches / Empty State
				<div className='p-4'>
					{recentSearches.length > 0 ? (
						<>
							<div className='flex items-center justify-between mb-3'>
								<h3 className='text-xs font-semibold uppercase tracking-wider text-muted-foreground/70'>Recent Searches</h3>
								<button onClick={clearRecent} className='text-xs text-muted-foreground/70 hover:text-foreground transition-colors'>
									Clear
								</button>
							</div>
							<div className='space-y-1'>
								{recentSearches.map((item) => (
									<button
										key={item.id}
										onClick={() => handleSelect(item)}
										className='w-full flex items-start gap-3 p-2 rounded-lg hover:bg-muted transition-colors text-left group'>
										<Clock size={14} className='mt-1 text-gray-300 group-hover:text-amber-600 transition-colors' />
										<span className='text-sm text-muted-foreground group-hover:text-foreground transition-colors'>
											{item.name}
										</span>
									</button>
								))}
							</div>
						</>
					) : (
						<div className='text-center py-12 opacity-60'>
							<Search size={40} className='mx-auto text-gray-300 mb-3' />
							<p className='text-sm font-medium text-foreground mb-1'>Global Search</p>
							<p className='text-xs text-muted-foreground'>Find anything in your campaign</p>
						</div>
					)}
				</div>
			) : results.length > 0 ? (
				// Grouped Search Results
				<div>
					{groupedResults.sessions.length > 0 && (
						<div className='mb-2'>
							<GroupHeader label='Sessions' icon={Calendar} />
							{groupedResults.sessions.map((item) => {
								const idx = results.indexOf(item);
								return (
									<SearchResultItem
										key={item.id}
										item={item}
										isSelected={idx === selectedIndex}
										onSelect={() => handleSelect(item)}
										onHover={() => setSelectedIndex(idx)}
									/>
								);
							})}
						</div>
					)}

					{groupedResults.entities.length > 0 && (
						<div>
							<GroupHeader label='Entities' icon={Database} />
							{groupedResults.entities.map((item) => {
								const idx = results.indexOf(item);
								return (
									<SearchResultItem
										key={item.id}
										item={item}
										isSelected={idx === selectedIndex}
										onSelect={() => handleSelect(item)}
										onHover={() => setSelectedIndex(idx)}
									/>
								);
							})}
						</div>
					)}
				</div>
			) : (
				// No Results
				!isLoading && (
					<div className='text-center py-12 px-4'>
						<p className='text-sm font-medium text-foreground mb-1'>No matches for "{query}"</p>
						<p className='text-xs text-muted-foreground'>Try checking your spelling</p>
					</div>
				)
			)}
		</div>
	);
};

--- END OF features\search\components\SearchResults.jsx ---

--- FILE: features\search\components\SearchTrigger.jsx ---
import { Search } from 'lucide-react';
import { useSearch } from '@/features/search/SearchContext'; // Import Context

export const SearchTrigger = ({ className, onClick }) => {
	const { openSearch } = useSearch();

	const handleClick = (e) => {
		openSearch();
		if (onClick) onClick(e);
	};

	return (
		<button
			onClick={handleClick}
			className={`w-full flex items-center gap-2 px-3 py-1.5 bg-background border border-border rounded-md text-sm text-muted-foreground hover:text-foreground hover:border-primary/50 transition-all group ${className}`}>
			<Search size={14} className='text-muted-foreground/70 group-hover:text-primary' />
			<span className='flex-1 text-left text-xs'>Search...</span>
			<kbd className='hidden sm:inline-block px-1.5 py-0.5 text-[10px] font-semibold text-muted-foreground/70 bg-muted border border-border rounded'>
				âŒ˜K
			</kbd>
		</button>
	);
};

--- END OF features\search\components\SearchTrigger.jsx ---

--- FILE: features\search\utils\searchMapper.js ---
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

export const transformSearchResults = (rawResults) => {
	const { sessions, entities, sessionAttributes } = rawResults;

	// 1. Process Sessions
	const attrMap = new Map();
	(sessionAttributes || []).forEach((attr) => {
		if (!attrMap.has(attr.entity_id)) attrMap.set(attr.entity_id, []);
		attrMap.get(attr.entity_id).push(attr);
	});

	const processedSessions = sessions.map((s) => {
		const rawAttrs = attrMap.get(s.id) || [];
		const attrs = rawAttrs.reduce((acc, c) => ({ ...acc, [c.name]: c.value }), {});

		const num = getAttributeValue(attrs, ['session_number', 'Session']);
		const date = getAttributeValue(attrs, ['session_date', 'Date']);
		const summaryAttr = getAttributeValue(attrs, 'Summary');

		return {
			id: s.id,
			name: s.title,
			type: 'session',
			// Prefer Summary attribute, fallback to snippet of narrative
			description: summaryAttr || s.narrative?.substring(0, 150) || '',
			attributes: {
				Session: num,
				Date: date,
			},
		};
	});

	// 2. Combine with standard entities
	return [...processedSessions, ...(entities || [])];
};

--- END OF features\search\utils\searchMapper.js ---

--- FILE: features\smart-text\SmartMarkdown.jsx ---
import ReactMarkdown from 'react-markdown';
import { useSmartText } from './useSmartText';
import { SmartEntityLink } from './components/SmartEntityLink';
import { EntityEmbed } from './components/EntityEmbed'; // New Import
import { generateId, extractText } from '@/shared/utils/textUtils';

export default function SmartMarkdown({ children, ...props }) {
	// ... (Existing safety check logic) ...
	let safeText = children;
	if (Array.isArray(children)) {
		safeText = children.join('');
	} else if (typeof children !== 'string' && children !== null && children !== undefined) {
		safeText = String(children);
	}

	const processedText = useSmartText(safeText);

	const HeadingRenderer = ({ level, children }) => {
		const text = extractText(children);
		const id = generateId(text);
		const Tag = `h${level}`;
		return <Tag id={id}>{children}</Tag>;
	};

	return (
		<ReactMarkdown
			{...props}
			components={{
				...props.components,
				h1: (props) => <HeadingRenderer level={1} {...props} />,
				h2: (props) => <HeadingRenderer level={2} {...props} />,
				h3: (props) => <HeadingRenderer level={3} {...props} />,

				// UPGRADED LINK RENDERER
				a: ({ href, children }) => {
					// 1. Check for Entity Link Protocol
					if (href && href.startsWith('#entity/')) {
						const parts = href.split('/');
						const id = parts[1];
						const type = parts[2] || 'default';

						// Check content for Embed Pattern: ":: Label ::"
						const textContent = String(children);
						const isEmbed = textContent.startsWith('::') && textContent.endsWith('::');

						if (isEmbed) {
							// Clean the label (remove ::)
							const label = textContent.replace(/^::\s*|\s*::$/g, '');
							return <EntityEmbed id={id} type={type} label={label} />;
						}

						return (
							<SmartEntityLink id={id} type={type}>
								{children}
							</SmartEntityLink>
						);
					}

					// 2. External Links
					return (
						<a href={href} className='text-blue-600 hover:underline' target='_blank' rel='noopener noreferrer'>
							{children}
						</a>
					);
				},
			}}>
			{processedText}
		</ReactMarkdown>
	);
}

--- END OF features\smart-text\SmartMarkdown.jsx ---

--- FILE: features\smart-text\useEntityIndex.js ---
import { useQuery } from '@tanstack/react-query';
import { getEntityIndex } from '@/domain/entity/api/entityService';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { resolveImageUrl, parseAttributes } from '@/shared/utils/imageUtils';
import { getParentId } from '@/domain/entity/utils/entityUtils'; // You added this util previously

export function useEntityIndex() {
	const { campaignId } = useCampaign();

	const { data } = useQuery({
		queryKey: ['entityIndex', campaignId],
		queryFn: async () => {
			const rawData = await getEntityIndex(campaignId);

			const list = [];
			const map = new Map();

			rawData.forEach((entity) => {
				const attrs = parseAttributes(entity.attributes);
				const lightEntity = {
					...entity,
					// Pre-calculate hierarchy once
					parentId: getParentId(entity),
					// Resolve Icon once
					iconUrl: resolveImageUrl(attrs, 'icon'),
				};

				// Remove heavy relationships array to save memory
				delete lightEntity.relationships;

				list.push(lightEntity);
				map.set(entity.id, lightEntity);
			});

			// Return optimized structures
			return {
				list: list.sort((a, b) => b.name.length - a.name.length),
				map,
			};
		},
		staleTime: 1000 * 60 * 30, // 30 mins
		enabled: !!campaignId,
	});

	// Default return shape
	return data || { list: [], map: new Map() };
}

--- END OF features\smart-text\useEntityIndex.js ---

--- FILE: features\smart-text\useSmartText.js ---
import { useMemo } from 'react';
import { useEntityIndex } from './useEntityIndex';

/**
 * Escape special regex characters
 */
const escapeRegex = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

/**
 * Find non-overlapping entity mentions in text
 */
const findEntityMatches = (text, entityIndex) => {
	const matches = [];
	const processedRanges = [];

	// Sort by length DESC
	const sortedEntities = [...entityIndex].sort((a, b) => b.name.length - a.name.length);

	for (const entity of sortedEntities) {
		const pattern = new RegExp(`\\b${escapeRegex(entity.name)}\\b`, 'gi');
		let match;

		while ((match = pattern.exec(text)) !== null) {
			const start = match.index;
			const end = start + match[0].length;

			const overlaps = processedRanges.some(
				(range) =>
					(start >= range.start && start < range.end) ||
					(end > range.start && end <= range.end) ||
					(start <= range.start && end >= range.end)
			);

			if (!overlaps) {
				matches.push({ start, end, text: match[0], entity });
				processedRanges.push({ start, end });
			}
		}
	}

	return matches.sort((a, b) => a.start - b.start);
};

const replaceMatches = (text, matches) => {
	if (matches.length === 0) return text;
	let result = '';
	let lastIndex = 0;
	for (const match of matches) {
		result += text.slice(lastIndex, match.start);
		result += `[${match.text}](#entity/${match.entity.id}/${match.entity.type})`;
		lastIndex = match.end;
	}
	result += text.slice(lastIndex);
	return result;
};

export function useSmartText(text) {
	const { list: entityIndex } = useEntityIndex();

	const shouldProcess = useMemo(() => {
		if (!text || typeof text !== 'string' || text.length < 3) return false;
		if (!entityIndex || entityIndex.length === 0) return false;
		return true;
	}, [text, entityIndex]);

	return useMemo(() => {
		if (!shouldProcess) return text || '';

		try {
			// CRITICAL FIX: Split by existing Markdown links to protect them
			// Matches [text](url) pattern. The capturing group () keeps the delimiter in the result array.
			// This regex is basic but handles standard single-line links.
			const linkProtectionRegex = /(\[.*?\]\(.*?\))/g;
			const parts = text.split(linkProtectionRegex);

			// Process only the parts that ARE NOT links
			const processedParts = parts.map((part) => {
				// Simple check: does it look like a markdown link?
				if (part.startsWith('[') && part.includes('](') && part.endsWith(')')) {
					return part; // Return existing link as-is (Protected)
				}

				// Otherwise, auto-link entities in this plain text segment
				const matches = findEntityMatches(part, entityIndex);
				return replaceMatches(part, matches);
			});

			return processedParts.join('');
		} catch (err) {
			console.error('SmartMarkdown processing error:', err);
			return text;
		}
	}, [text, entityIndex, shouldProcess]);
}

--- END OF features\smart-text\useSmartText.js ---

--- FILE: features\smart-text\components\EntityEmbed.jsx ---
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { ArrowRight } from 'lucide-react';
import { clsx } from 'clsx';
import EntityIcon from '@/domain/entity/components/EntityIcon';
import { useEntityIndex } from '@/features/smart-text/useEntityIndex';
import { resolveImageUrl, parseAttributes } from '@/shared/utils/imageUtils';

// Utility to calculate brightness from an image
const getImageBrightness = (imageUrl) => {
	return new Promise((resolve) => {
		const img = new Image();
		img.crossOrigin = 'Anonymous';

		img.onload = () => {
			try {
				const canvas = document.createElement('canvas');
				const ctx = canvas.getContext('2d');

				canvas.width = 100;
				canvas.height = 100;

				ctx.drawImage(img, 0, 0, 100, 100);
				const imageData = ctx.getImageData(0, 0, 100, 100);
				const data = imageData.data;

				let totalBrightness = 0;
				let pixelCount = 0;

				for (let i = 0; i < data.length; i += 4) {
					const r = data[i];
					const g = data[i + 1];
					const b = data[i + 2];
					const a = data[i + 3];

					if (a < 125) continue;

					const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
					totalBrightness += brightness;
					pixelCount++;
				}

				const avgBrightness = totalBrightness / pixelCount;
				resolve(avgBrightness);
			} catch (e) {
				resolve(200);
			}
		};

		img.onerror = () => {
			resolve(200);
		};

		img.src = imageUrl;
	});
};

export const EntityEmbed = ({ id, type, label }) => {
	const navigate = useNavigate();
	// FIX: Destructure the 'map' from the new hook signature
	const { map: entityMap } = useEntityIndex();

	// FIX: Use .get() (O(1) speed) instead of .find()
	const entity = entityMap.get(id);
	const resolvedLabel = label || entity?.name || 'Unknown Entity';

	// Resolve Images
	const attributes = parseAttributes(entity?.attributes);
	const customIcon = entity?.iconUrl || resolveImageUrl(attributes, 'icon');
	const bgImage = resolveImageUrl(attributes, 'background');

	// State for brightness detection
	const [isDarkBackground, setIsDarkBackground] = useState(false);
	const [isAnalyzing, setIsAnalyzing] = useState(!!bgImage);

	// Analyze background image brightness
	useEffect(() => {
		if (!bgImage) {
			setIsAnalyzing(false);
			return;
		}

		setIsAnalyzing(true);

		getImageBrightness(bgImage).then((brightness) => {
			setIsDarkBackground(brightness < 127.5);
			setIsAnalyzing(false);
		});
	}, [bgImage]);

	// Border Color Logic (Left Side Only)
	const getBorderColor = () => {
		switch (type) {
			case 'encounter':
				return 'border-l-red-600';
			case 'quest':
				return 'border-l-blue-600';
			case 'location':
				return 'border-l-emerald-600';
			default:
				return 'border-l-amber-600';
		}
	};

	const getActionLabel = () => {
		switch (type) {
			case 'encounter':
				return 'View Encounter';
			case 'quest':
				return 'View Quest';
			case 'location':
				return 'View Map';
			default:
				return 'View Entity';
		}
	};

	return (
		<span
			role='button'
			onClick={(e) => {
				e.preventDefault();
				navigate(`/wiki/${type}/${id}`);
			}}
			className={clsx(
				// Layout & Base (Changed to flex to behave like block context within span)
				'group relative w-full h-[30px] my-4 cursor-pointer select-none overflow-hidden',
				'flex rounded-md transition-all duration-200',

				// Borders
				'border border-border/60 border-l-[3px]',
				getBorderColor(),

				// Background (Default White if no image)
				!bgImage && 'bg-background hover:bg-muted/30',

				// Hover Effects
				'hover:shadow hover:border-l-4'
			)}>
			{/* BACKGROUND IMAGE LAYER */}
			{bgImage && (
				<span
					className='absolute inset-0 bg-cover bg-center opacity-80 group-hover:scale-105 transition-transform duration-500 block'
					style={{ backgroundImage: `url('${bgImage}')` }}
				/>
			)}

			{/* CONTENT LAYER */}
			<span className='relative z-10 flex items-center gap-2 pl-2 pr-3 h-full w-full'>
				{/* Icon - Adaptive color, no background */}
				<span
					className={clsx(
						'shrink-0 flex items-center justify-center opacity-90 group-hover:opacity-100 transition-all duration-200',
						isAnalyzing ? 'opacity-0' : 'opacity-100'
					)}
					style={{
						filter: bgImage
							? isDarkBackground
								? 'brightness(0) invert(1)' // White for dark backgrounds
								: 'brightness(0)' // Black for light backgrounds
							: 'none',
					}}>
					<EntityIcon
						type={type}
						customIconUrl={customIcon}
						size={16}
						inline={true}
						className='object-cover rounded-full'
					/>
				</span>

				{/* Label */}
				<span
					className={clsx(
						'font-serif font-bold text-[12px] truncate leading-none flex-1 pt-0.5 block',
						'transition-colors duration-200',
						isAnalyzing ? 'opacity-0' : 'opacity-100',
						bgImage ? (isDarkBackground ? 'text-white' : 'text-black') : 'text-foreground'
					)}>
					{resolvedLabel}
				</span>

				{/* Right Side Action */}
				<span
					className={clsx(
						'text-[9px] font-bold uppercase tracking-wider flex items-center gap-1 shrink-0 transition-colors',
						isAnalyzing ? 'opacity-0' : 'opacity-100',
						bgImage
							? isDarkBackground
								? 'text-white/90 group-hover:text-white'
								: 'text-black/90 group-hover:text-black'
							: 'text-muted-foreground/60 group-hover:text-amber-700'
					)}>
					{getActionLabel()} <ArrowRight size={10} />
				</span>
			</span>
		</span>
	);
};

--- END OF features\smart-text\components\EntityEmbed.jsx ---

--- FILE: features\smart-text\components\SmartEntityLink.jsx ---
/**
 * SmartEntityLink - MIGRATED to use EntityLink component
 * This is now just a thin wrapper that adds entity index lookup
 */

import EntityLink from '@/domain/entity/components/EntityLink';
import { useEntityIndex } from '@/features/smart-text/useEntityIndex';

export const SmartEntityLink = ({ id, type, children }) => {
	// FIX: Destructure the 'map' from the new hook signature
	const { map: entityMap } = useEntityIndex();

	// FIX: Use .get() (O(1) speed) instead of .find()
	const entity = entityMap.get(id);
	const customIconUrl = entity?.iconUrl;

	return (
		<EntityLink id={id} type={type} customIconUrl={customIconUrl} inline>
			{children}
		</EntityLink>
	);
};

--- END OF features\smart-text\components\SmartEntityLink.jsx ---

--- FILE: features\smart-tooltip\TooltipContainer.jsx ---
import { createPortal } from 'react-dom';
import { useQuery } from '@tanstack/react-query';
import { getTooltipData } from '@/domain/entity/api/entityService';
import { TooltipCard } from './components/TooltipCard';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

export const TooltipContainer = ({ target, onMouseEnter, onMouseLeave }) => {
	const targetId = target?.id;
	const targetType = target?.type;
	const isValidId = targetId ? /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(targetId) : false;

	const { data, isLoading } = useQuery({
		queryKey: ['tooltip', targetId],
		// Call Service instead of Supabase directly
		queryFn: async () => {
			if (!targetId) return null;
			const rawData = await getTooltipData(targetId, targetType);

			// Small amount of VIEW logic remains here to shape it for the Card
			if (targetType === 'session') {
				const attrs = (rawData.attributes || []).reduce((acc, c) => ({ ...acc, [c.name]: c.value }), {});
				const num = getAttributeValue(attrs, ['session_number', 'Session']);
				const date = getAttributeValue(attrs, ['session_date', 'Date']);
				const summaryAttr = getAttributeValue(attrs, 'Summary');

				return {
					name: rawData.name,
					type: 'session',
					description: summaryAttr || rawData.description,
					attributes: { Session: num, Date: date },
				};
			}
			return rawData;
		},
		enabled: !!targetId && isValidId,
		staleTime: 1000 * 60 * 5,
		retry: false,
	});

	if (!target) return null;
	const isMobile = window.matchMedia('(pointer: coarse)').matches || window.innerWidth < 1024;

	return createPortal(
		<>
			{isMobile && target.isPinned && (
				<div
					className='fixed inset-0 bg-black/20 z-[9998]'
					onClick={(e) => {
						e.stopPropagation();
						onMouseLeave && onMouseLeave();
					}}
					style={{ touchAction: 'none' }}
				/>
			)}
			<TooltipCard
				data={data}
				type={target.type}
				id={target.id}
				position={target.pos}
				isLoading={isLoading}
				onMouseEnter={onMouseEnter}
				onMouseLeave={onMouseLeave}
			/>
		</>,
		document.body
	);
};

--- END OF features\smart-tooltip\TooltipContainer.jsx ---

--- FILE: features\smart-tooltip\TooltipContext.jsx ---
import { createContext, useContext } from 'react';
import { useTooltipState } from './useTooltipState';
import { TooltipContainer } from './TooltipContainer';

const TooltipContext = createContext(null);

export const TooltipProvider = ({ children }) => {
	const { activeTooltip, openTooltip, closeTooltip, cancelClose } = useTooltipState();

	return (
		<TooltipContext.Provider value={{ openTooltip, closeTooltip, cancelClose }}>
			{children}

			{/* Pass interaction handlers to the Overlay Layer */}
			<TooltipContainer target={activeTooltip} onMouseEnter={cancelClose} onMouseLeave={closeTooltip} />
		</TooltipContext.Provider>
	);
};

export const useTooltip = () => {
	const context = useContext(TooltipContext);

	// CHANGED: Graceful degradation instead of hard crash
	if (!context) {
		// Return dummy functions so components don't break
		return {
			openTooltip: () => {},
			closeTooltip: () => {},
			cancelClose: () => {},
		};
	}
	return context;
};

--- END OF features\smart-tooltip\TooltipContext.jsx ---

--- FILE: features\smart-tooltip\useSmartPosition.js ---
import { useState, useEffect, useRef } from 'react';

/**
 * Calculates smart positioning for tooltips to keep them onscreen
 * @param {Object} targetPosition - { x, y } coordinates of the trigger element
 * @param {boolean} isOpen - Whether the tooltip is currently visible
 * @returns {Object} - { style, tooltipRef } for positioning
 */
export function useSmartPosition(targetPosition, isOpen) {
	const tooltipRef = useRef(null);
	const [position, setPosition] = useState({ top: 0, left: 0, transform: '' });
	const [isPositioned, setIsPositioned] = useState(false);

	useEffect(() => {
		if (!isOpen || !tooltipRef.current || !targetPosition) {
			setIsPositioned(false);
			return;
		}

		const calculatePosition = () => {
			const tooltip = tooltipRef.current;
			const rect = tooltip.getBoundingClientRect();

			// Get viewport dimensions
			const viewportWidth = window.innerWidth;
			const viewportHeight = window.innerHeight;

			// Configuration
			const EDGE_PADDING = 10; // Minimum distance from screen edges
			const OFFSET_Y = 20; // Distance below cursor
			const TOOLTIP_WIDTH = 300; // Match your tooltip width

			let top = targetPosition.y + OFFSET_Y;
			let left = targetPosition.x;
			let transform = 'translateX(-50%)'; // Center by default

			// --- HORIZONTAL POSITIONING ---

			// Calculate where the tooltip would end up with center alignment
			const leftEdge = left - TOOLTIP_WIDTH / 2;
			const rightEdge = left + TOOLTIP_WIDTH / 2;

			if (rightEdge > viewportWidth - EDGE_PADDING) {
				// Tooltip would overflow right side
				// Align to right edge of viewport with padding
				left = viewportWidth - EDGE_PADDING;
				transform = 'translateX(-100%)'; // Right align
			} else if (leftEdge < EDGE_PADDING) {
				// Tooltip would overflow left side
				// Align to left edge of viewport with padding
				left = EDGE_PADDING;
				transform = 'translateX(0)'; // Left align
			}

			// --- VERTICAL POSITIONING ---

			// Check if tooltip would overflow bottom
			if (top + rect.height > viewportHeight - EDGE_PADDING) {
				// Position above the cursor instead
				top = targetPosition.y - rect.height - 10;

				// If it still doesn't fit above, clamp to top
				if (top < EDGE_PADDING) {
					top = EDGE_PADDING;
				}
			}

			// Ensure tooltip doesn't go above viewport
			if (top < EDGE_PADDING) {
				top = EDGE_PADDING;
			}

			setPosition({ top, left, transform });
			setIsPositioned(true);
		};

		// Initial calculation
		calculatePosition();

		// Recalculate on resize (debounced)
		let resizeTimer;
		const handleResize = () => {
			clearTimeout(resizeTimer);
			resizeTimer = setTimeout(calculatePosition, 100);
		};

		window.addEventListener('resize', handleResize);

		return () => {
			window.removeEventListener('resize', handleResize);
			clearTimeout(resizeTimer);
		};
	}, [targetPosition, isOpen]);

	const style = {
		position: 'fixed',
		top: `${position.top}px`,
		left: `${position.left}px`,
		transform: position.transform,
		zIndex: 9999,
		width: '300px',
		pointerEvents: 'auto',
		opacity: isPositioned ? 1 : 0,
		transition: 'opacity 0.15s ease-out',
	};

	return { style, tooltipRef, isPositioned };
}

--- END OF features\smart-tooltip\useSmartPosition.js ---

--- FILE: features\smart-tooltip\useTooltipState.js ---
import { useState, useRef, useCallback, useEffect } from 'react';
// import './types';

export function useTooltipState() {
	const [activeTooltip, setActiveTooltip] = useState(null);
	const timeoutRef = useRef(null);

	useEffect(() => {
		return () => {
			if (timeoutRef.current) {
				clearTimeout(timeoutRef.current);
			}
		};
	}, []);

	const openTooltip = useCallback((e, id, type, isPinned = false) => {
		// If we are opening a new one, clear any pending close
		if (timeoutRef.current) clearTimeout(timeoutRef.current);

		// Get position from event
		let x = e.clientX;
		let y = e.clientY;

		// For touch events on mobile, use touch coordinates
		if (e.touches && e.touches[0]) {
			x = e.touches[0].clientX;
			y = e.touches[0].clientY;
		}

		setActiveTooltip({ id, type, pos: { x, y }, isPinned });
	}, []);

	const closeTooltip = useCallback(() => {
		// Add a delay so the user can move their mouse from the link TO the tooltip
		timeoutRef.current = setTimeout(() => {
			setActiveTooltip(null);
		}, 300); // 300ms grace period
	}, []);

	// Allows the Tooltip Card to say "I'm being hovered, don't close!"
	const cancelClose = useCallback(() => {
		if (timeoutRef.current) clearTimeout(timeoutRef.current);
	}, []);

	return {
		activeTooltip,
		openTooltip,
		closeTooltip,
		cancelClose,
	};
}

--- END OF features\smart-tooltip\useTooltipState.js ---

--- FILE: features\smart-tooltip\components\TooltipCard.jsx ---
import { useNavigate } from 'react-router-dom';
import { clsx } from 'clsx';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';
import { ArrowRight } from 'lucide-react';
import { useSmartPosition } from '@/features/smart-tooltip/useSmartPosition';
import { resolveImageUrl, parseAttributes } from '@/shared/utils/imageUtils';

export const TooltipCard = ({ data, type, id, position, isLoading, onMouseEnter, onMouseLeave }) => {
	const navigate = useNavigate();
	const config = getEntityConfig(type);
	const Icon = config.icon;

	// Use smart positioning hook
	const { style, tooltipRef, isPositioned } = useSmartPosition(position, true);

	const handleClick = (e) => {
		e.stopPropagation();
		navigate(`/wiki/${type}/${id}`);
		onMouseLeave && onMouseLeave();
	};

	if (isLoading) {
		return (
			<div
				ref={tooltipRef}
				style={style}
				className='bg-background p-3 rounded-lg shadow-xl border border-border text-xs text-muted-foreground/70'>
				Loading info...
			</div>
		);
	}

	if (!data) return null;

	const attributes = parseAttributes(data.attributes);
	const image = resolveImageUrl(attributes, 'background');
	const status = getAttributeValue(attributes, ['status', 'disposition']);
	const race = getAttributeValue(attributes, ['race', 'ancestry']);
	const classJob = getAttributeValue(attributes, ['class', 'occupation', 'role']);

	const tags = [status, race, classJob].filter(Boolean).join(' â€¢ ');

	return (
		<div
			ref={tooltipRef}
			style={style}
			onClick={handleClick}
			onMouseEnter={onMouseEnter}
			onMouseLeave={onMouseLeave}
			className={clsx(
				'bg-background rounded-xl shadow-2xl overflow-hidden ring-1 ring-black/10 cursor-pointer group',
				'hover:ring-amber-500/50 transition-shadow'
			)}>
			{/* IMAGE BANNER */}
			{image ? (
				<div className='h-24 w-full relative bg-gray-900 overflow-hidden'>
					<img
						src={image}
						alt={data.name}
						onError={(e) => {
							e.target.style.display = 'none';
							e.target.parentElement.classList.add('bg-amber-900');
						}}
						className='w-full h-full object-cover object-top opacity-80 group-hover:scale-105 transition-transform duration-500'
					/>
					<div className='absolute inset-0 bg-gradient-to-t from-background to-transparent' />
				</div>
			) : (
				<div
					className={clsx(
						'h-1.5 w-full',
						config.tailwind.bg.replace(
							'bg-',
							'bg-gradient-to-r from-transparent via-current to-transparent opacity-50'
						),
						config.tailwind.text
					)}
				/>
			)}

			<div className={clsx('px-4', image ? '-mt-6 relative z-10' : 'pt-3')}>
				<div className='flex items-start justify-between'>
					<div>
						<span
							className={clsx(
								'text-[10px] font-bold uppercase tracking-wider opacity-70 mb-0.5 block',
								config.tailwind.text
							)}>
							{data.type}
						</span>
						<h3 className='font-serif font-bold text-lg leading-none text-foreground group-hover:text-amber-700 transition-colors'>
							{data.name}
						</h3>
					</div>
					<div
						className={clsx(
							'p-1.5 rounded-lg shadow-sm border bg-background',
							config.tailwind.border,
							config.tailwind.text
						)}>
						<Icon size={16} />
					</div>
				</div>
				{tags && (
					<p className='text-[11px] font-medium text-muted-foreground mt-1.5 pb-2 border-b border-border/50'>{tags}</p>
				)}
			</div>

			<div className='p-4 pt-3'>
				{/* FIX: Added 'custom-scrollbar' to allow styled scrolling if description is long */}
				<p className='text-xs text-muted-foreground overflow-auto h-full max-h-32 leading-relaxed custom-scrollbar'>
					{data.description || 'No overview available.'}
				</p>
			</div>

			<div className='bg-muted/50 p-2 border-t border-border flex justify-end'>
				<span className='text-[10px] font-semibold text-muted-foreground/70 flex items-center gap-1 group-hover:text-amber-600 transition-colors'>
					View Details <ArrowRight size={10} />
				</span>
			</div>
		</div>
	);
};

--- END OF features\smart-tooltip\components\TooltipCard.jsx ---

--- FILE: features\table-of-contents\TableOfContents.jsx ---
import { useState } from 'react';
import { clsx } from 'clsx';
import { List, AlignLeft } from 'lucide-react';
import { useTocObserver } from './hooks/useTocObserver';
import { useTocScroll } from './hooks/useTocScroll';
import { TocItem } from './components/TocItem';
import { TocMobileDrawer } from './components/TocMobileDrawer';

export const TableOfContents = ({
	items,
	className,
	visibilityClass = 'hidden 2xl:block',
	mobileToggleClass = '2xl:hidden',
}) => {
	const [isOpen, setIsOpen] = useState(false);

	// Hooks
	const activeId = useTocObserver(items.map((i) => i.id));
	const { scrollToId } = useTocScroll(() => setIsOpen(false));

	if (!items || items.length === 0) return null;

	const renderList = () => (
		<div className='flex flex-col space-y-0.5'>
			{items.map((item) => (
				<TocItem key={item.id} item={item} isActive={activeId === item.id} onClick={scrollToId} />
			))}
		</div>
	);

	return (
		<>
			{/* --- DESKTOP VIEW --- */}
			{/* 
				Sticky Positioning Logic:
				- top-40 (160px): Increased from top-32 to ensure no overlap with sticky TabContainers or Headers.
				- self-start: Critical for CSS Grid contexts (like Timeline) to prevent the item from stretching 
				  to full height, which breaks sticky behavior.
			*/}
			<div className={clsx(visibilityClass, 'sticky top-90 w-64 shrink-0 self-start', className)}>
				<div className='max-h-[calc(100vh-12rem)] overflow-y-auto custom-scrollbar pb-10 pr-2'>
					<div className='flex items-center gap-2 mb-4 px-4 text-xs font-bold uppercase tracking-widest text-muted-foreground/70'>
						<AlignLeft size={12} />
						<span>On this Page</span>
					</div>
					<nav>{renderList()}</nav>
				</div>
			</div>

			{/* --- MOBILE/TABLET TOGGLE --- */}
			<div className={clsx('fixed bottom-6 right-6 z-40', mobileToggleClass)}>
				<button
					onClick={() => setIsOpen(true)}
					className='h-12 w-12 bg-background border border-border shadow-lg rounded-full flex items-center justify-center text-foreground hover:bg-amber-500/10 hover:border-amber-300 hover:text-amber-700 transition-all active:scale-95'
					aria-label='Open Table of Contents'>
					<List size={20} />
				</button>
			</div>

			{/* --- MOBILE DRAWER --- */}
			<TocMobileDrawer
				isOpen={isOpen}
				items={items}
				activeId={activeId}
				onClose={() => setIsOpen(false)}
				onScrollTo={scrollToId}
			/>
		</>
	);
};

--- END OF features\table-of-contents\TableOfContents.jsx ---

--- FILE: features\table-of-contents\components\TocItem.jsx ---
import { clsx } from 'clsx';

export const TocItem = ({ item, isActive, onClick }) => {
	return (
		<button
			onClick={() => onClick(item.id)}
			className={clsx(
				'group flex items-start text-left w-full py-1.5 transition-all duration-200 border-l-[3px] px-4',
				isActive
					? 'border-amber-600 text-amber-700 font-bold bg-amber-500/10/50'
					: 'border-transparent text-muted-foreground hover:text-foreground hover:border-border'
			)}>
			<span className={clsx('text-[13px] leading-snug', item.depth === 3 && 'ml-3 opacity-90 text-[12px]')}>
				{item.text}
			</span>
		</button>
	);
};

--- END OF features\table-of-contents\components\TocItem.jsx ---

--- FILE: features\table-of-contents\components\TocMobileDrawer.jsx ---
import { Drawer } from '@/shared/components/ui/Drawer';
import { TocItem } from './TocItem';

export const TocMobileDrawer = ({ isOpen, items, activeId, onClose, onScrollTo }) => {
	return (
		<Drawer isOpen={isOpen} onClose={onClose} title='Table of Contents' position='right'>
			<div className='py-4 flex flex-col space-y-0.5'>
				{items.map((item) => (
					<TocItem key={item.id} item={item} isActive={activeId === item.id} onClick={onScrollTo} />
				))}
			</div>
		</Drawer>
	);
};

--- END OF features\table-of-contents\components\TocMobileDrawer.jsx ---

--- FILE: features\table-of-contents\hooks\useTocObserver.js ---
import { useState, useEffect, useRef } from 'react';

export function useTocObserver(itemIds) {
	const [activeId, setActiveId] = useState('');
	const observer = useRef(null);
	const headingsMap = useRef(new Map());

	useEffect(() => {
		// 1. Safety Check
		if (!itemIds || itemIds.length === 0) return;

		// 2. The Callback
		const handleObserver = (entries) => {
			entries.forEach((entry) => {
				// Store all intersecting states in a map
				headingsMap.current.set(entry.target.id, entry);
			});

			// 3. Determine the "Winner"
			// We find the first visible heading from the top
			const visibleHeadings = [];

			headingsMap.current.forEach((entry) => {
				if (entry.isIntersecting) {
					visibleHeadings.push(entry);
				}
			});

			if (visibleHeadings.length > 0) {
				// Sort by their position relative to the top of the viewport
				// The one closest to 0 (top) without being way off-screen is the winner
				visibleHeadings.sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top);

				// Pick the top-most visible one
				setActiveId(visibleHeadings[0].target.id);
			} else {
				// Edge case: User scrolled past a section but next one hasn't entered.
				// We keep the last active ID or check if we are at the very top.
				const scrollY = window.scrollY;
				if (scrollY < 100 && itemIds.length > 0) {
					setActiveId(itemIds[0]);
				}
			}
		};

		// 4. Initialize Observer
		// rootMargin: '-10% 0px -80% 0px' creates a "reading line" at the top of the screen.
		// An element must cross this top zone to trigger the update.
		observer.current = new IntersectionObserver(handleObserver, {
			rootMargin: '-80px 0px -80% 0px',
			threshold: [0, 1],
		});

		// 5. Observe elements
		itemIds.forEach((id) => {
			const el = document.getElementById(id);
			if (el) {
				observer.current.observe(el);
			}
		});

		return () => {
			if (observer.current) observer.current.disconnect();
			headingsMap.current.clear();
		};
	}, [itemIds]);

	return activeId;
}

--- END OF features\table-of-contents\hooks\useTocObserver.js ---

--- FILE: features\table-of-contents\hooks\useTocScroll.js ---
import { useCallback } from 'react';

export function useTocScroll(callback) {
	const scrollToId = useCallback(
		(id) => {
			const element = document.getElementById(id);

			if (element) {
				// CSS 'scroll-margin-top' handles the offset (sticky header)
				element.scrollIntoView({ behavior: 'smooth', block: 'start' });

				// Optional callback (e.g., to close mobile drawer)
				if (callback) callback();
			} else {
				console.warn(`[ToC] Target element not found: #${id}`);
			}
		},
		[callback]
	);

	return { scrollToId };
}

--- END OF features\table-of-contents\hooks\useTocScroll.js ---

--- FILE: features\timeline\TimelinePage.jsx ---
import { useTimelineViewModel } from './useTimelineView';
import { TimelineSession } from './components/TimelineSession';
import { TableOfContents } from '@/features/table-of-contents/TableOfContents';

export default function TimelineView() {
	const { sessions, isLoading } = useTimelineViewModel();

	if (isLoading) return <div className='p-8 text-center text-muted-foreground/70'>Loading timeline...</div>;

	// Construct ToC items manually for the timeline sessions
	const tocItems = sessions.map((s) => ({
		id: `session-marker-${s.number}`,
		text: `${s.title}`,
		depth: 1,
	}));

	return (
		<div className='h-full overflow-hidden flex flex-col'>
			<div className='flex-1 overflow-y-auto bg-background custom-scrollbar'>
				{/* OPTIMIZATION: Reduced padding on mobile (p-4 vs p-12) */}
				<div className='max-w-7xl mx-auto p-4 md:p-12'>
					<h1 className='text-3xl font-serif font-bold text-foreground mb-10'>Campaign History</h1>

					<div className='grid grid-cols-1 xl:grid-cols-[1fr_240px] gap-12 relative'>
						{/* Column 1: Timeline Content */}
						{/* OPTIMIZATION: Reduced margin-left (ml-3) for more width */}
						<div className='relative border-l-2 border-border ml-3 md:ml-4 space-y-16 pb-20'>
							{sessions.map((session) => (
								<div key={session.id} id={`session-marker-${session.number}`} className='scroll-mt-24'>
									<TimelineSession session={session} />
								</div>
							))}
						</div>

						{/* Column 2: ToC */}
						<TableOfContents items={tocItems} visibilityClass='hidden xl:block' mobileToggleClass='xl:hidden' />
					</div>
				</div>
			</div>
		</div>
	);
}

--- END OF features\timeline\TimelinePage.jsx ---

--- FILE: features\timeline\useTimelineView.js ---
import { useMemo } from 'react';
import { useQuery } from '@tanstack/react-query';
import { getTimeline } from '@/features/timeline/api/timelineService';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { getEventStyle } from './utils/eventStyles';
// import './types';

/**
 * @returns {{ sessions: import('./types').TimelineSessionModel[], isLoading: boolean }}
 */
export function useTimelineViewModel() {
	const { campaignId } = useCampaign();

	const { data, isLoading } = useQuery({
		queryKey: ['timeline', campaignId],
		queryFn: () => getTimeline(campaignId),
		enabled: !!campaignId,
	});

	const sessions = useMemo(() => {
		return (data || []).map((session) => {
			// Sort events safely: Use spread to avoid mutating read-only cache, handle nulls
			const sortedEvents = [...(session.events || [])].sort((a, b) => (a.event_order || 0) - (b.event_order || 0));

			// Map events to View Model
			const events = sortedEvents.map((event) => {
				// TRANSFORMATION: Convert relationships to tags
				const tags = (event.relationships || [])
					.map((rel) => {
						if (!rel.target) return null;
						return {
							name: rel.target.name,
							type: rel.target.type?.toLowerCase() || 'default',
						};
					})
					.filter(Boolean); // Remove nulls

				return {
					id: event.id,
					title: event.title,
					typeLabel: event.event_type?.replace(/_/g, ' ') || 'Event',
					description: event.description,
					tags, // New property containing all connected entities
					style: getEventStyle(event.event_type),
				};
			});

			return {
				id: session.id,
				number: session.session_number,
				dateLabel: session.session_date || 'Unknown Date',
				title: session.title,
				events,
			};
		});
	}, [data]);

	return { sessions, isLoading };
}

--- END OF features\timeline\useTimelineView.js ---

--- FILE: features\timeline\api\timelineService.js ---
import { supabase } from '@/shared/api/supabaseClient';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

export const getTimeline = async (campaignId) => {
	// 1. Fetch Sessions (No summary)
	const { data: sessions, error: sessionError } = await supabase
		.from('sessions')
		.select(
			`
            id, 
            title, 
            narrative,
            events:session_events (
                id, 
                title, 
                description, 
                event_type, 
                event_order
            )
        `
		)
		.eq('campaign_id', campaignId);

	if (sessionError) throw sessionError;
	if (!sessions || sessions.length === 0) return [];

	// 2. Fetch Attributes
	const sessionIds = sessions.map((s) => s.id);
	const { data: attributes } = await supabase
		.from('attributes')
		.select('entity_id, name, value')
		.in('entity_id', sessionIds);

	const attrMap = new Map();
	(attributes || []).forEach((attr) => {
		if (!attrMap.has(attr.entity_id)) attrMap.set(attr.entity_id, []);
		attrMap.get(attr.entity_id).push(attr);
	});

	// 3. Process
	const processedSessions = sessions
		.map((s) => {
			const rawAttrs = attrMap.get(s.id) || [];
			const attrs = rawAttrs.reduce((acc, c) => {
				acc[c.name] = c.value;
				return acc;
			}, {});

			const num = getAttributeValue(attrs, ['session_number', 'Session']) || 999;
			const date = getAttributeValue(attrs, ['session_date', 'Date']) || 'Unknown Date';

			return {
				...s,
				session_number: Number(num),
				session_date: date,
				attributes: attrs,
				events: s.events || [],
			};
		})
		.sort((a, b) => a.session_number - b.session_number);

	// ... Steps 4, 5, 6 (Tags logic) remain exactly the same ...
	// (Included for completeness)
	const allEvents = processedSessions.flatMap((s) => s.events);
	const eventIds = allEvents.map((e) => e.id);

	if (eventIds.length === 0) return processedSessions;

	const { data: relationships, error: relError } = await supabase
		.from('entity_relationships')
		.select(`from_entity_id, target:entities!to_entity_id ( name, type )`)
		.in('from_entity_id', eventIds);

	if (relError) return processedSessions;

	const relMap = new Map();
	relationships.forEach((rel) => {
		if (!relMap.has(rel.from_entity_id)) relMap.set(rel.from_entity_id, []);
		relMap.get(rel.from_entity_id).push(rel);
	});

	processedSessions.forEach((session) => {
		if (session.events.length > 0) {
			session.events.sort((a, b) => (a.event_order || 0) - (b.event_order || 0));
			session.events.forEach((event) => {
				event.relationships = relMap.get(event.id) || [];
			});
		}
	});

	return processedSessions;
};

--- END OF features\timeline\api\timelineService.js ---

--- FILE: features\timeline\components\TimelineEvent.jsx ---
import { useMemo } from 'react';
import { clsx } from 'clsx';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import SmartMarkdown from '@/features/smart-text/SmartMarkdown';
import { Diamond } from 'lucide-react';

export const TimelineEvent = ({ event }) => {
	const { Icon, container } = event.style;

	// Group tags by entity type
	const groupedTags = useMemo(() => {
		if (!event.tags || event.tags.length === 0) return [];

		const groups = {};
		event.tags.forEach((tag) => {
			const type = tag.type || 'default';
			if (!groups[type]) {
				groups[type] = [];
			}
			groups[type].push(tag);
		});

		// Convert to array of groups
		return Object.values(groups);
	}, [event.tags]);

	return (
		<div className='relative flex gap-3 md:gap-4 group'>
			{/* Icon Bubble */}
			<div
				className={clsx(
					'shrink-0 w-8 h-8 rounded-full flex items-center justify-center shadow-sm border-2 z-10 transition-transform group-hover:scale-110 bg-background',
					container
				)}>
				<Icon size={14} strokeWidth={2.5} />
			</div>

			{/* Content */}
			<div className='flex-1 -mt-1 pb-2 min-w-0'>
				{/* FIX: Title color muted to text-foreground/80 */}
				<h4 className='text-sm font-bold text-foreground/80 mb-1 flex flex-wrap items-center gap-2'>
					<span className='mr-auto'>{event.title}</span>
					<span className='text-[9px] font-normal uppercase tracking-wider text-foreground border border-border px-1.5 rounded-sm bg-muted whitespace-nowrap'>
						{event.typeLabel}
					</span>
				</h4>

				{event.description && (
					<div className='text-sm text-muted-foreground leading-relaxed text-pretty text-left'>
						<SmartMarkdown>{event.description}</SmartMarkdown>
					</div>
				)}

				{/* Grouped Tags */}
				{groupedTags.length > 0 && (
					<div className='flex flex-wrap items-center gap-2 mt-2'>
						{groupedTags.map((group, groupIndex) => (
							<div key={groupIndex} className='flex items-center gap-2'>
								{/* Tags in this group */}
								<div className='flex flex-wrap gap-1.5'>
									{group.map((tag, idx) => {
										const config = getEntityConfig(tag.type);
										const TagIcon = config.icon;
										const styles = config.tailwind;

										return (
											<span
												key={`${tag.name}-${idx}`}
												className={clsx(
													// FIX: Changed font-bold to font-semibold for better legibility
													'inline-flex items-center gap-1 text-[10px] uppercase font-semibold px-1.5 py-0.5 rounded border cursor-default whitespace-nowrap',
													styles.bg,
													styles.text,
													styles.border
												)}>
												<TagIcon size={10} /> {tag.name}
											</span>
										);
									})}
								</div>

								{/* Separator */}
								{groupIndex < groupedTags.length - 1 && (
									<Diamond size={6} className='text-gray-300 fill-gray-300 shrink-0' />
								)}
							</div>
						))}
					</div>
				)}
			</div>
		</div>
	);
};

--- END OF features\timeline\components\TimelineEvent.jsx ---

--- FILE: features\timeline\components\TimelineSession.jsx ---
import { Calendar } from 'lucide-react';
import { TimelineEvent } from './TimelineEvent';

export const TimelineSession = ({ session }) => {
	return (
		// OPTIMIZATION: Reduced padding (pl-4) on mobile to maximize text width
		<div className='relative pl-4 md:pl-12'>
			{/* Session Marker (Circle on the main line) */}
			<div className='absolute -left-[9px] top-0 flex items-center justify-center w-5 h-5 rounded-full bg-background border-2 border-border shadow-sm z-10'>
				<div className='w-2 h-2 rounded-full bg-gray-400' />
			</div>

			{/* Session Header */}
			<div className='mb-8'>
				<div className='flex flex-col sm:flex-row sm:items-center gap-2 sm:gap-4 mb-2'>
					<span className='text-[10px] font-bold uppercase tracking-wider text-muted-foreground bg-muted px-2 py-0.5 rounded self-start border border-border'>
						Session {session.number - 1}
					</span>
					<time className='text-xs text-muted-foreground/70 flex items-center gap-1 font-medium'>
						<Calendar size={12} /> {session.dateLabel}
					</time>
				</div>
				<h2 className='text-2xl font-serif font-bold text-foreground mb-3'>{session.title}</h2>
			</div>

			{/* Events List */}
			<div className='space-y-6 relative'>
				{/* Connector Line for events */}
				{/* Adjusted left position slightly to align with tighter padding if needed, 
                    but 15px centers it nicely within the w-8 icon (16px center) roughly */}
				<div className='absolute left-[15px] top-4 bottom-4 w-0.5 bg-muted -z-10' />

				{session.events.map((event) => (
					<TimelineEvent key={event.id} event={event} />
				))}
			</div>
		</div>
	);
};

--- END OF features\timeline\components\TimelineSession.jsx ---

--- FILE: features\timeline\utils\eventStyles.js ---
import { getEntityStyles } from '@/domain/entity/config/entityStyles';
import {
	Sword,
	Skull,
	MessageSquare,
	Scroll,
	CheckCircle2,
	Footprints,
	Map,
	MapPin,
	User,
	Flag,
	Search,
	BookOpen,
	Sparkles,
	Eye,
	ShoppingBag,
	Star,
	Tent,
} from 'lucide-react';

export const getEventStyle = (eventType) => {
	const type = eventType?.toLowerCase() || '';

	let entityType = 'default';
	let Icon = Star;

	switch (type) {
		case 'combat':
			entityType = 'encounter'; // Orange
			Icon = Skull;
			break;
		case 'social':
			entityType = 'npc'; // Amber
			Icon = MessageSquare;
			break;
		case 'quest_started':
			entityType = 'quest'; // Blue
			Icon = Scroll;
			break;
		case 'quest_progressed':
			entityType = 'quest'; // Blue
			Icon = CheckCircle2;
			break;
		case 'travel':
			entityType = 'location'; // Emerald
			Icon = Footprints; // Journeys
			break;
		case 'location_discovered':
			entityType = 'location'; // Emerald
			Icon = Map; // Finding new places
			break;
		case 'location_visited':
			entityType = 'location'; // Emerald
			Icon = MapPin; // Arriving at known places
			break;
		case 'npc_encountered':
			entityType = 'npc'; // Amber
			Icon = User;
			break;
		case 'faction_discovered':
			entityType = 'faction'; // Purple
			Icon = Flag;
			break;
		case 'investigation':
			entityType = 'default'; // Gray (Neutral/Mechanics)
			Icon = Search;
			break;
		case 'backstory':
			entityType = 'character'; // Red (Personal)
			Icon = BookOpen;
			break;
		case 'discovery':
			entityType = 'encounter'; // Orange (Loot/Items/Secrets)
			Icon = Sparkles;
			break;
		case 'vision':
			entityType = 'faction'; // Purple (Magic/Mystical)
			Icon = Eye;
			break;
		case 'shopping':
			entityType = 'npc'; // Amber (Trade/Commerce)
			Icon = ShoppingBag;
			break;
		case 'special_event':
			entityType = 'session'; // Slate (Meta/Unique)
			Icon = Star;
			break;
		// Fallbacks for legacy types or fuzzy matches
		default:
			if (type.match(/combat|fight|kill/)) {
				entityType = 'encounter';
				Icon = Sword;
			} else if (type.match(/npc|social|meet/)) {
				entityType = 'npc';
				Icon = MessageSquare;
			} else if (type.match(/location|visit|arrive/)) {
				entityType = 'location';
				Icon = MapPin;
			} else if (type.match(/quest|mission/)) {
				entityType = 'quest';
				Icon = Scroll;
			} else if (type.match(/camp|rest/)) {
				entityType = 'location';
				Icon = Tent;
			} else {
				entityType = 'default';
				Icon = Star;
			}
	}

	// Use centralized styles
	const styles = getEntityStyles(entityType);

	return {
		Icon,
		// Map standard styles to timeline specific class structure
		container: `${styles.border} ${styles.bg} ${styles.text}`,
		// Heuristic for line color (usually 200 or 300 shade) based on bg class
		// line: styles.bg.replace('-50', '-200'),
	};
};

--- END OF features\timeline\utils\eventStyles.js ---

--- FILE: features\wiki\useEntityView.js ---
import { useMemo } from 'react';
import { parseAttributes } from '@/shared/utils/imageUtils'; // Use the safe parser
import { transformAttributes } from '@/features/wiki/utils/attributeMapper';
import { useEntityHeader } from './hooks/useEntityHeader';
import { useEntityContent } from './hooks/useEntityContent';
import { useEntitySidebar } from './hooks/useEntitySidebar';

export function useEntityViewModel(entity) {
	// 1. Prepare Attributes
	// Optimization: parseAttributes now just returns the object if it's already an object.
	// This allows this hook to work with both Raw Service data and Transformed View data.
	const attributes = useMemo(() => {
		return parseAttributes(entity?.attributes);
	}, [entity]);

	// 2. Transform attributes into traits and sections
	const { traits, sections } = useMemo(() => {
		if (!entity) return { traits: [], sections: [] };
		// Pass description to avoid duplicating it in attributes list
		return transformAttributes(attributes, entity.description);
	}, [entity, attributes]);

	// 3. Build sub-models
	// We pass the full entity because it might contain pre-calculated props (like 'objectives' or 'events')
	// from the transform layer that the sub-hooks need.
	const header = useEntityHeader(entity, attributes);
	const sidebar = useEntitySidebar(entity, traits);
	const content = useEntityContent(entity, attributes, sections);

	// 4. Determine layout mode
	const layoutMode = useMemo(() => {
		// Safe check for session type
		return entity?.type === 'session' ? 'tabs' : 'standard';
	}, [entity]);

	return useMemo(() => {
		if (!entity) return null;

		return {
			layoutMode,
			header,
			sidebar,
			content,
		};
	}, [entity, layoutMode, header, sidebar, content]);
}

--- END OF features\wiki\useEntityView.js ---

--- FILE: features\wiki\useWikiNavigation.js ---
import { useState } from 'react';
import { useParams } from 'react-router-dom';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import { useEntityFetching } from './hooks/useEntityFetching';
import { useEntityGrouping } from './hooks/useEntityGrouping';
// import './types';

export function useWikiNavigation() {
	const { type } = useParams();
	const [search, setSearch] = useState('');

	const normalizedType = type === 'sessions' ? 'session' : type;

	// 1. Fetch entities
	const { entities, isLoading } = useEntityFetching(normalizedType);

	// 2. Group and filter entities
	const groups = useEntityGrouping(entities, normalizedType, search);

	// 3. Build UI config
	const entityConfig = getEntityConfig(normalizedType);
	const config = {
		label: `${entityConfig.label}s`,
		Icon: entityConfig.icon,
		textClass: entityConfig.tailwind.text,
	};

	return {
		config,
		isLoading,
		hasItems: groups.length > 0 && groups.some((g) => g.items.length > 0),
		groups,
		search,
		setSearch,
	};
}

--- END OF features\wiki\useWikiNavigation.js ---

--- FILE: features\wiki\WikiLayout.jsx ---
import { Outlet } from 'react-router-dom';
import { useWikiNavigation } from './useWikiNavigation';
import { WikiSidebar } from '@/features/wiki/components/navigation/WikiSidebar';

export default function WikiLayout() {
	const navigation = useWikiNavigation();

	return (
		<div className='relative flex flex-col lg:flex-row h-full bg-background overflow-hidden'>
			{/* Sidebar - First in DOM for Mobile Top position, Ordered 2nd for Desktop Right position */}
			<WikiSidebar navigation={navigation} className='lg:order-2 lg:border-l lg:border-border lg:h-full z-30' />

			{/* Main Content */}
			<div className='flex-1 lg:order-1 overflow-y-auto bg-background relative z-0 custom-scrollbar'>
				<Outlet />
			</div>
		</div>
	);
}

--- END OF features\wiki\WikiLayout.jsx ---

--- FILE: features\wiki\api\wikiService.js ---
import { supabase } from '@/shared/api/supabaseClient';

// Moved getWikiEntry here to reduce bloat in entities.js
export const getWikiEntry = async (id, type) => {
	if (type === 'session') {
		const { data, error } = await supabase
			.from('sessions')
			.select(`*, events:session_events (*)`)
			.eq('id', id)
			.single();
		if (error) throw error;

		const { data: attributes } = await supabase.from('attributes').select('name, value').eq('entity_id', id);

		const eventIds = (data.events || []).map((e) => e.id);
		let eventRelMap = new Map();

		if (eventIds.length > 0) {
			const { data: rels } = await supabase
				.from('entity_relationships')
				.select(`from_entity_id, target:entities!to_entity_id ( id, name, type )`)
				.in('from_entity_id', eventIds);

			(rels || []).forEach((rel) => {
				if (!eventRelMap.has(rel.from_entity_id)) eventRelMap.set(rel.from_entity_id, []);
				eventRelMap.get(rel.from_entity_id).push({
					entity_id: rel.target.id,
					entity_name: rel.target.name,
					entity_type: rel.target.type,
					type: 'mention',
				});
			});
		}

		const { data: directRels } = await supabase
			.from('entity_relationships')
			.select(`target:entities!to_entity_id ( id, name, type ), relationship_type`)
			.eq('from_entity_id', id);

		const sessionRelationships = (directRels || []).map((rel) => ({
			entity_id: rel.target.id,
			entity_name: rel.target.name,
			entity_type: rel.target.type,
			type: rel.relationship_type,
		}));

		return {
			data,
			type: 'session',
			additional: { attributes, eventRelMap, sessionRelationships },
		};
	}

	// --- STANDARD ENTITY FETCH ---
	const { data, error: entityError } = await supabase.from('entity_complete_view').select('*').eq('id', id).single();
	if (entityError) throw entityError;

	const additional = {};

	// FETCH QUEST OBJECTIVES
	if (type === 'quest') {
		const { data: objectives } = await supabase
			.from('quest_objectives')
			.select('*, session:sessions(id, title)')
			.eq('quest_id', id)
			.order('order_index', { ascending: true });

		if (objectives && objectives.length > 0) {
			const sessionIds = objectives.map((o) => o.completed_session_id).filter(Boolean);
			if (sessionIds.length > 0) {
				const { data: attrs } = await supabase
					.from('attributes')
					.select('entity_id, value')
					.in('entity_id', sessionIds)
					.or('name.eq.session_number,name.eq.Session');

				const sessionNumMap = new Map();
				(attrs || []).forEach((a) => sessionNumMap.set(a.entity_id, a.value));

				objectives.forEach((obj) => {
					if (obj.session) {
						obj.session.session_number = sessionNumMap.get(obj.session.id);
					}
				});
			}
		}
		additional.objectives = objectives || [];
	}

	// FETCH ENCOUNTER ACTIONS
	if (type === 'encounter') {
		const { data: actions } = await supabase
			.from('encounter_actions')
			.select(`*, actor:entities!actor_entity_id (id, name, type), target:entities!target_entity_id (id, name, type)`)
			.eq('encounter_id', id)
			.order('round_number', { ascending: true })
			.order('action_order', { ascending: true });

		if (actions && actions.length > 0) {
			const entityIds = new Set();
			actions.forEach((a) => {
				if (a.actor?.id) entityIds.add(a.actor.id);
				if (a.target?.id) entityIds.add(a.target.id);
			});

			if (entityIds.size > 0) {
				const { data: attrs } = await supabase
					.from('attributes')
					.select('entity_id, name, value')
					.in('entity_id', Array.from(entityIds));

				const attrMap = new Map();
				(attrs || []).forEach((attr) => {
					if (!attrMap.has(attr.entity_id)) attrMap.set(attr.entity_id, []);
					attrMap.get(attr.entity_id).push(attr);
				});

				actions.forEach((action) => {
					if (action.actor?.id) action.actor.attributes = attrMap.get(action.actor.id) || [];
					if (action.target?.id) action.target.attributes = attrMap.get(action.target.id) || [];
				});
			}
		}
		additional.encounterActions = actions || [];
	}

	// RESOLVE SESSION NUMBERS FOR EVENTS
	let events = data.events;
	// Flatten logic
	if (events && typeof events === 'object' && !Array.isArray(events)) events = Object.values(events).flat();

	if (events && Array.isArray(events) && events.length > 0) {
		const sessionIds = [...new Set(events.map((e) => e.session_id).filter(Boolean))];
		if (sessionIds.length > 0) {
			const { data: sessions } = await supabase.from('sessions').select('id').in('id', sessionIds);
			const { data: attrs } = await supabase
				.from('attributes')
				.select('entity_id, name, value')
				.in('entity_id', sessionIds)
				.or('name.eq.session_number,name.eq.Session');

			const sessionMap = new Map();
			(sessions || []).forEach((s) => {
				const sAttr = (attrs || []).find((a) => a.entity_id === s.id);
				const num = sAttr ? parseInt(sAttr.value) : null;
				sessionMap.set(s.id, num);
			});
			additional.sessionMap = sessionMap;
		}
	}

	return { data, type, additional };
};

--- END OF features\wiki\api\wikiService.js ---

--- FILE: features\wiki\components\EncounterTimeline.jsx ---
import React from 'react';
import {
	Swords,
	Shield,
	Zap,
	Skull,
	Footprints,
	MessageSquare,
	Hand,
	Dices,
	Target,
	Activity,
	ArrowRight,
	CornerDownRight,
} from 'lucide-react';
import { clsx } from 'clsx';
import EntityIcon from '@/domain/entity/components/EntityIcon';
import EntityLink from '@/domain/entity/components/EntityLink';
import SmartMarkdown from '@/features/smart-text/SmartMarkdown';
import { useTheme } from '@/shared/hooks/useTheme'; // FIX: Import theme hook

// ... (getActionIcon helper remains the same) ...
const getActionIcon = (type) => {
	switch (type?.toLowerCase()) {
		case 'attack':
			return Swords;
		case 'spell':
			return Zap;
		case 'move':
			return Footprints;
		case 'check':
			return Dices;
		case 'save':
			return Shield;
		case 'item':
			return Hand;
		case 'legendary':
			return Skull;
		case 'social':
			return MessageSquare;
		default:
			return Activity;
	}
};

const CombatLogEntry = ({ action }) => {
	const { isFriendly, actor, target, description, result, effect, type } = action;
	const ActionIcon = getActionIcon(type);
	const { theme } = useTheme(); // FIX: Use app theme state

	// FIX: Logic based on explicit App Theme, ignoring System Preference
	const isDark = theme === 'dark';

	// Background:
	// - Friendly: None
	// - Hostile:
	//    - Dark: Red-900 at 10% (Visible on black)
	//    - Light/DND: Red-500 at 5% (Subtle on parchment/white)
	const rowBg = isFriendly ? '' : isDark ? 'bg-red-900/5' : 'bg-red-500/2';

	// Text Colors:
	// - Dark: Lighter shades (400)
	// - Light/DND: Darker shades (700)
	const manualActorColor = isFriendly
		? isDark
			? 'text-emerald-400'
			: 'text-emerald-700'
		: isDark
		? 'text-red-400'
		: 'text-red-700';

	const effectIconColor = isDark ? 'text-amber-500' : 'text-amber-600';

	return (
		<div
			className={clsx(
				'flex items-start gap-2.5 p-2.5 border-b border-border last:border-0 text-sm transition-colors group',
				'hover:bg-muted/50',
				rowBg
			)}>
			{/* 1. Large Sidebar Icon */}
			<div className='shrink-0 mt-0.5'>
				<EntityIcon type={actor.type} customIconUrl={actor.iconUrl} size={28} className='rounded opacity-90' />
			</div>

			{/* 2. Content */}
			<div className='flex-1 min-w-0'>
				{/* Header Line */}
				<div className='flex flex-wrap items-center gap-1 mb-1 leading-snug'>
					{/* Actor Name */}
					{actor.id ? (
						<EntityLink
							id={actor.id}
							type={actor.type}
							inline={true}
							showIcon={true}
							customIconUrl={actor.iconUrl}
							className='font-serif font-bold text-sm !no-underline hover:underline'>
							{actor.name}
						</EntityLink>
					) : (
						// Manual Entry
						<span
							className={clsx(
								'font-serif font-bold text-sm flex items-center gap-1.5 cursor-default',
								manualActorColor
							)}>
							<EntityIcon type={actor.type} size={14} inline />
							{actor.name}
						</span>
					)}

					{/* Action Badge */}
					<span className='text-[10px] uppercase font-bold text-muted-foreground/70 tracking-wider flex border border-border items-center gap-1 rounded-sm px-1.5 bg-background/50'>
						<ActionIcon size={10} />
						{type}
					</span>

					{/* Target */}
					{target && (
						<div className='flex items-center gap-1.5 text-muted-foreground'>
							<ArrowRight size={10} className='opacity-50' />

							{target.id ? (
								<EntityLink
									id={target.id}
									type={target.type}
									inline={true}
									showIcon={true}
									customIconUrl={target.iconUrl}
									className='font-serif font-semibold text-sm !no-underline hover:underline'>
									{target.name}
								</EntityLink>
							) : (
								<span className='font-serif font-semibold text-foreground text-sm flex items-center gap-1.5 cursor-default'>
									<EntityIcon type={target.type} size={14} inline />
									{target.name}
								</span>
							)}
						</div>
					)}

					{/* Result Badge */}
					{result && (
						<span className='ml-auto text-[10px] font-bold text-foreground/80 bg-background/80 px-1.5 py-0.5 rounded border border-border whitespace-nowrap'>
							{result}
						</span>
					)}
				</div>

				{/* Description */}
				{description && (
					<div className='text-xs text-muted-foreground leading-relaxed pl-0.5'>
						<SmartMarkdown components={{ p: 'span' }}>{description}</SmartMarkdown>
					</div>
				)}

				{/* Effect */}
				{effect && (
					<div className='mt-1 flex items-center gap-1.5 text-xs font-medium text-muted-foreground w-fit px-1.5 py-0.5 rounded -ml-1'>
						<CornerDownRight size={10} className={effectIconColor} />
						<span className='italic opacity-90'>
							<SmartMarkdown components={{ p: 'span' }}>{effect}</SmartMarkdown>
						</span>
					</div>
				)}
			</div>
		</div>
	);
};

export const EncounterTimeline = ({ rounds }) => {
	if (!rounds || Object.keys(rounds).length === 0) return null;

	return (
		<div className='my-6'>
			<h3 className='text-sm font-bold text-muted-foreground uppercase tracking-widest mb-3 flex items-center gap-2'>
				<Swords size={14} className='text-primary' /> Combat Log
			</h3>

			<div className='border border-border rounded-lg overflow-hidden bg-background'>
				{Object.entries(rounds).map(([roundNum, actions]) => (
					<div key={roundNum}>
						{/* Round Header */}
						<div className='bg-muted/80 border-b border-border px-3 py-1.5 flex items-center justify-between'>
							<span className='text-xs font-serif font-bold text-foreground'>Round {roundNum}</span>
							<span className='text-[9px] font-bold uppercase text-muted-foreground tracking-wider'>
								{actions.length} Turns
							</span>
						</div>

						{/* Actions Group */}
						<div
							className={clsx(
								'bg-background',
								Number(roundNum) !== Object.keys(rounds).length && 'border-b border-border'
							)}>
							{actions.map((action) => (
								<CombatLogEntry key={action.id} action={action} />
							))}
						</div>
					</div>
				))}
			</div>
		</div>
	);
};

--- END OF features\wiki\components\EncounterTimeline.jsx ---

--- FILE: features\wiki\components\EntityBody.jsx ---
import { History, Diamond } from 'lucide-react';
import { clsx } from 'clsx';
import SmartMarkdown from '@/features/smart-text/SmartMarkdown';
import { EntityHistory } from './EntityHistory';
import { QuestObjectives } from './QuestObjectives';
import { SectionDivider } from '@/shared/components/ui/SectionDivider';
import { EncounterTimeline } from './EncounterTimeline';
import { EntityMiniMap } from '@/features/wiki/components/EntityMiniMap';

// Re-exporting History for use in tabs if needed by parent
export { EntityHistory } from './EntityHistory';

const LevelUpBanner = ({ level }) => {
	const logoPath = `${import.meta.env.BASE_URL}logo_detailed.png`;

	return (
		<div className='mt-4 mb-6 w-full'>
			{/* Full Width, Fixed Height (~64px) Banner */}
			<div className='flex items-center h-16 bg-muted/60 border-y border-r border-border border-l-2 border-l-amber-700/80 rounded-lg shadow-sm w-full overflow-hidden'>
				{/* Logo Section - Vertical Center */}
				<div className='shrink-0 h-full flex items-center px-5 bg-amber-500/10/50 border-r border-border/40'>
					<img src={logoPath} alt='Campaign Logo' className='h-12 w-auto object-contain opacity-80 drop-shadow-sm' />
				</div>

				{/* Text Content */}
				<div className='flex-1 flex flex-col justify-center px-4'>
					<h3 className='text-xs font-serif font-bold text-amber-900 uppercase tracking-[0.15em] leading-none m-0! p-0!'>
						Level Up
					</h3>
					<p className='font-serif text-sm text-card-foreground leading-none p-0! m-0!'>
						The party has reached <span className='font-bold text-foreground'>Level {level}</span>.
					</p>
				</div>
			</div>
		</div>
	);
};

export const EntityBody = ({
	summary,
	sections,
	history,
	objectives,
	combatRounds,
	levelUp,
	mapImageUrl,
	mapMarkers,
}) => {
	return (
		<div className='prose max-w-none prose-headings:font-serif prose-headings:font-bold prose-headings:text-foreground prose-p:text-foreground prose-p:text-[11pt] prose-p:leading-relaxed prose-p:my-2 prose-strong:text-foreground prose-strong:font-bold prose-li:marker:text-amber-600 prose-li:text-sm prose-li:my-0.5 prose-p:text-justify'>
			{summary && (
				<div className='mb-4'>
					<SmartMarkdown>{summary}</SmartMarkdown>
				</div>
			)}
			{/* Quest Objectives */}
			{objectives && objectives.length > 0 && (
				<>
					<SectionDivider />
					<QuestObjectives objectives={objectives} />
				</>
			)}
			{mapImageUrl && mapImageUrl.length > 0 && (
				<>
					<SectionDivider />
					<EntityMiniMap imageUrl={mapImageUrl} markers={mapMarkers} />
				</>
			)}

			{/* Combat Timeline */}
			{combatRounds && Object.keys(combatRounds).length > 0 && (
				<>
					<SectionDivider />
					<EncounterTimeline rounds={combatRounds} />
				</>
			)}
			{/* Narrative Sections */}
			{sections.map((prop) => {
				if (prop.displayType === 'list' && Array.isArray(prop.value)) {
					return (
						<div key={prop.key}>
							<SectionDivider />
							{/* FIX: Changed text-accent (invisible) to text-amber-900/text-foreground for brown/dark headers */}
							<h3 className='capitalize text-lg mt-0 font-serif text-amber-900 dark:text-foreground mb-2 font-bold'>
								{prop.key}
							</h3>
							<ul className='grid grid-cols-1 gap-1.5 pl-1 list-none my-0'>
								{prop.value.map((item, idx) => (
									<li key={idx} className='flex items-start gap-3 m-0 p-0 text-foreground group'>
										<div className='mt-[0.45rem] shrink-0 text-accent/60 group-hover:text-accent transition-colors'>
											<Diamond size={8} fill='currentColor' />
										</div>
										<span className='text-[11pt] leading-snug'>
											<SmartMarkdown components={{ p: 'span' }}>{item}</SmartMarkdown>
										</span>
									</li>
								))}
							</ul>
						</div>
					);
				}
				return (
					<div key={prop.key}>
						<SectionDivider />
						{/* FIX: Changed text-accent (invisible) to text-amber-900/text-foreground */}
						<h3 className='capitalize text-lg font-serif text-amber-900 dark:text-foreground mb-1 mt-0 inline-block pb-0.5'>
							{prop.key}
						</h3>
						<div className='mt-0.5'>
							<SmartMarkdown>{prop.value}</SmartMarkdown>
						</div>
					</div>
				);
			})}
			{history && history.length > 0 && (
				<div className='mt-2'>
					<SectionDivider />
					<h3 className='font-serif text-lg mt-0 font-bold text-foreground mb-3 flex items-center gap-2'>
						<History size={16} className='text-amber-900/70 dark:text-muted-foreground' /> Events
					</h3>
					<EntityHistory events={history} />
				</div>
			)}
			{/* Level Up Banner */}
			{levelUp && <LevelUpBanner level={levelUp} />}
		</div>
	);
};

--- END OF features\wiki\components\EntityBody.jsx ---

--- FILE: features\wiki\components\EntityHeader.jsx ---
import { useState, useEffect } from 'react';
import { createPortal } from 'react-dom';
import { Link, useParams } from 'react-router-dom';
import { Edit3, ZoomIn, X, Maximize2 } from 'lucide-react';
import { clsx } from 'clsx';
import EntityIcon from '@/domain/entity/components/EntityIcon';
import EntityBadge from '@/domain/entity/components/EntityBadge';
import { getPriorityStyles } from '@/domain/entity/config/entityStyles';

/**
 * Premium Fullscreen Image Viewer
 */
const ImageLightbox = ({ src, alt, onClose }) => {
	// Lock body scroll & Handle Escape Key
	useEffect(() => {
		document.body.style.overflow = 'hidden';
		const handleEsc = (e) => {
			if (e.key === 'Escape') onClose();
		};
		window.addEventListener('keydown', handleEsc);
		return () => {
			document.body.style.overflow = 'unset';
			window.removeEventListener('keydown', handleEsc);
		};
	}, [onClose]);

	return createPortal(
		<div
			className='fixed inset-0 z-[9999] flex items-center justify-center p-8 bg-background/30 backdrop-blur-md animate-in fade-in duration-200'
			onClick={onClose}>
			{/* Content Wrapper - Shrinks to fit image */}
			<div
				className='relative inline-block shadow-2xl rounded-lg overflow-hidden bg-black/5 ring-1 ring-black/10'
				onClick={(e) => e.stopPropagation()}>
				{/* Image */}
				<img src={src} alt={alt} className='max-w-[85vw] max-h-[85vh] object-contain block select-none' />

				{/* Close Button - Pinned to Image */}
				<button
					onClick={onClose}
					className='absolute top-3 right-3 p-1.5 bg-black/50 hover:bg-black/70 text-white/90 hover:text-white rounded-full transition-all duration-200 backdrop-blur-sm shadow-sm'
					title='Close (Esc)'>
					<X size={18} strokeWidth={2.5} />
				</button>
			</div>
		</div>,
		document.body
	);
};

/**
 * EntityHeader Component
 */
export const EntityHeader = ({ data }) => {
	const { title, typeLabel, imageUrl, avatarUrl, status, priority, extraTags } = data;
	const { entityId } = useParams();
	const [isLightboxOpen, setIsLightboxOpen] = useState(false);

	// Only show edit controls in Dev mode
	const isDev = import.meta.env.DEV;

	// FIX: Improved "Spotlight" gradient for headers without images
	// Creates a subtle light source from the top-center that fades into the page background
	const noImageStyle = !imageUrl
		? {
				background: `
            radial-gradient(
                80% 100% at 50% -20%, 
                var(--muted) 0%, 
                var(--background) 100%
            )
        `,
		  }
		: {};

	return (
		<>
			<div
				className={clsx(
					// HEIGHT ADJUSTMENT: Increased base height and md height
					'h-48 md:h-64 relative group overflow-hidden select-none',
					imageUrl ? 'cursor-pointer' : 'border-b border-border/40' // Add subtle border if no image
				)}
				style={noImageStyle}
				onClick={() => imageUrl && setIsLightboxOpen(true)}>
				{/* 1. BACKGROUND LAYER (Banner) */}
				{imageUrl && (
					<>
						<img
							src={imageUrl}
							alt={title}
							className={clsx(
								'absolute inset-0 w-full h-full object-cover transition-all duration-[2000ms] ease-in-out',
								// Start position: Center-Top (Focuses on faces/landscapes usually in upper 3rd)
								// Hover position: True Center (Slow pan effect)
								'object-[center_30%] group-hover:object-[center_50%] group-hover:scale-105'
							)}
						/>

						{/* Subtler Zoom Hint */}
						<div className='absolute top-4 right-4 opacity-0 group-hover:opacity-100 transition-opacity duration-300 z-10'>
							<div className='bg-black/30 backdrop-blur-md p-2 rounded-full text-white/80 border border-white/10 shadow-lg'>
								<Maximize2 size={16} />
							</div>
						</div>

						{/* FIX: Smoother, Longer Gradient Overlay */}
						{/* Uses a longer fade (via-30% to via-60%) to avoid the "harsh line" effect */}
						<div className='absolute inset-0 bg-gradient-to-t from-[var(--background)] from-0% via-[var(--background)]/80 via-20% via-[var(--background)]/20 via-60% to-transparent pointer-events-none' />
					</>
				)}

				{/* 2. DEVELOPER ACTION BAR */}
				{isDev && entityId && (
					<div
						className='absolute top-4 right-4 z-30 animate-in fade-in slide-in-from-right-2 duration-500'
						onClick={(e) => e.stopPropagation()} // Prevent lightbox trigger
					>
						<Link
							to={`/dm/manage/${typeLabel.toLowerCase()}/${entityId}`}
							className='flex items-center gap-2 px-3 py-1.5 bg-background/80 backdrop-blur-md border border-border rounded-full shadow-lg text-muted-foreground hover:text-amber-700 hover:border-amber-500/50 transition-all group/edit'
							title='Edit in DM Console'>
							<Edit3 size={14} className='group-hover/edit:scale-110 transition-transform' />
							<span className='text-[10px] font-bold uppercase tracking-tight'>Quick Edit</span>
						</Link>
					</div>
				)}

				{/* 3. CONTENT LAYER */}
				<div className='absolute bottom-0 left-0 w-full p-4 md:p-6 pointer-events-none'>
					<div className='max-w-6xl mx-auto flex items-end gap-5'>
						{/* AVATAR - FIX: Size alignment and container logic */}
						<div className='hidden md:flex md:items-end pointer-events-auto mb-1'>
							<EntityIcon
								type={typeLabel.toLowerCase()}
								customIconUrl={avatarUrl}
								// FIX: Passed larger size to component to fill container
								size={64}
								showBackground
								// FIX: Adjusted width/height classes to be proportional (w-20/h-20 is 80px)
								className='w-[84px] h-[84px] shadow-xl border-2 border-background/50 object-cover bg-background'
							/>
						</div>

						{/* Title & Status Metadata */}
						<div className='flex-1 pb-1 min-w-0'>
							<div className='flex items-center flex-wrap gap-2 mb-2'>
								{/* Type Badge */}
								<EntityBadge
									type={typeLabel.toLowerCase()}
									size='sm'
									variant='solid'
									className='bg-background/80 backdrop-blur-sm border-border/50 text-foreground shadow-sm'
								/>

								{/* Status Badge */}
								{status.hasStatus && (
									<span
										className={clsx(
											'px-1.5 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider border shadow-sm backdrop-blur-sm',
											status.isDead ? 'badge-dead' : 'badge-alive'
										)}>
										{status.label}
									</span>
								)}

								{/* Priority Badge (For Quests) */}
								{priority && (
									<span
										className={clsx(
											'px-1.5 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider border shadow-sm backdrop-blur-sm',
											getPriorityStyles(priority)
										)}>
										{priority} Priority
									</span>
								)}

								{/* Extra Tags (Session Date, etc) */}
								{extraTags &&
									extraTags.map((tag, i) => (
										<span
											key={i}
											className='px-1.5 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider border shadow-sm bg-card/80 backdrop-blur-sm border-slate-300 text-slate-700 dark:text-slate-300 dark:border-slate-700'>
											{tag}
										</span>
									))}
							</div>

							<h1 className='text-3xl md:text-5xl font-serif font-bold text-foreground leading-none drop-shadow-sm tracking-tight break-words'>
								{title}
							</h1>
						</div>
					</div>
				</div>
			</div>

			{/* Lightbox Portal */}
			{isLightboxOpen && imageUrl && (
				<ImageLightbox src={imageUrl} alt={title} onClose={() => setIsLightboxOpen(false)} />
			)}
		</>
	);
};

--- END OF features\wiki\components\EntityHeader.jsx ---

--- FILE: features\wiki\components\EntityHistory.jsx ---
import { Calendar } from 'lucide-react';
import { clsx } from 'clsx';
import SmartMarkdown from '@/features/smart-text/SmartMarkdown';

export const EntityHistory = ({ events, showSession = true, fullHeight = true }) => {
	if (!events || events.length === 0) return null;

	return (
		// 1. Container Logic
		// If fullHeight is true, we allow the div to expand naturally.
		// If false, we clamp it to 600px with a scrollbar.
		<div className={clsx(!fullHeight && 'max-h-[600px] overflow-y-auto custom-scrollbar pr-2')}>
			{/* 2. Timeline Container */}
			{/* ml-5 pushes the border line right, creating a safe gutter for the dots (-left-[19px]) 
                so they don't get clipped by overflow:hidden or scroll containers */}
			<div className='border-l-2 border-border ml-2 pl-3 space-y-6 relative my-2'>
				{events.map((evt, idx) => (
					<div key={evt.id || idx} className='relative group'>
						{/* Timeline Dot */}
						<div
							className={clsx(
								'absolute -left-[19px] top-1.5 w-3 h-3 rounded-full border border-background',
								'bg-stone-300 ring-1 ring-border',
								'group-hover:bg-accent group-hover:ring-accent/40 transition-colors shadow-sm'
							)}
						/>

						{/* Title Row with Session Badge */}
						<div className='flex items-center gap-2 mb-1 flex-wrap'>
							<h4 className='font-bold text-foreground text-sm mt-0.5'>{evt.title}</h4>
							{showSession && evt.session_number != null && (
								<span className='inline-flex items-center gap-1 text-[9px] font-bold uppercase tracking-wider px-2 py-0.5 rounded border ml-auto max-w-[45%] truncate bg-muted text-muted-foreground border-border/60'>
									<Calendar size={9} />
									Session {evt.session_number}
								</span>
							)}
						</div>

						{/* Description */}
						<div className='text-sm text-muted-foreground leading-relaxed text-justify'>
							<SmartMarkdown>{evt.description}</SmartMarkdown>
						</div>
					</div>
				))}
			</div>
		</div>
	);
};

--- END OF features\wiki\components\EntityHistory.jsx ---

--- FILE: features\wiki\components\EntityMiniMap.jsx ---
import React, { useEffect, useState, useRef } from 'react';
import { MapContainer, ImageOverlay, Marker, Popup, useMap } from 'react-leaflet';
import L from 'leaflet';
import { Map as MapIcon, Maximize, Minimize, BookOpen, ArrowRight } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import { clsx } from 'clsx';
import { resolveMarkerIcon } from '@/features/atlas/utils/markerUtils';
import LoadingSpinner from '@/shared/components/ui/LoadingSpinner';
import { useEntityIndex } from '@/features/smart-text/useEntityIndex';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import { resolveImageUrl, parseAttributes } from '@/shared/utils/imageUtils';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

const MapController = ({ bounds, activeFullscreen }) => {
	const map = useMap();
	useEffect(() => {
		if (bounds && map) {
			const timer = setTimeout(() => {
				map.invalidateSize({ animate: true });
				map.fitBounds(bounds, { padding: [20, 20] });
			}, 100);
			return () => clearTimeout(timer);
		}
	}, [map, bounds, activeFullscreen]);
	return null;
};

export const EntityMiniMap = ({ imageUrl, markers = [] }) => {
	const [dimensions, setDimensions] = useState(null);
	const [loading, setLoading] = useState(true);
	const [isFullscreen, setIsFullscreen] = useState(false);
	const [isPseudoFullscreen, setIsPseudoFullscreen] = useState(false);
	const containerRef = useRef(null);
	const navigate = useNavigate();
	const { map: entityMap } = useEntityIndex();

	const activeFullscreen = isFullscreen || isPseudoFullscreen;

	useEffect(() => {
		const handler = () => setIsFullscreen(!!document.fullscreenElement);
		document.addEventListener('fullscreenchange', handler);
		return () => document.removeEventListener('fullscreenchange', handler);
	}, []);

	useEffect(() => {
		const handleEsc = (e) => {
			if (e.key === 'Escape' && isPseudoFullscreen) setIsPseudoFullscreen(false);
		};
		window.addEventListener('keydown', handleEsc);
		return () => window.removeEventListener('keydown', handleEsc);
	}, [isPseudoFullscreen]);

	useEffect(() => {
		const img = new Image();
		img.src = imageUrl;
		img.onload = () => {
			const w = img.width;
			const h = img.height;
			const southWest = [-h, 0];
			const northEast = [0, w];
			setDimensions(L.latLngBounds(southWest, northEast));
			setLoading(false);
		};
	}, [imageUrl]);

	const toggleFullscreen = (e) => {
		e.stopPropagation();
		if (!containerRef.current) return;
		const supportsNative =
			document.fullscreenEnabled || document.webkitFullscreenEnabled || containerRef.current.requestFullscreen;
		if (supportsNative) {
			if (!document.fullscreenElement) {
				containerRef.current.requestFullscreen().catch(() => setIsPseudoFullscreen(true));
			} else {
				document.exitFullscreen();
			}
		} else {
			setIsPseudoFullscreen(!isPseudoFullscreen);
		}
	};

	if (loading)
		return (
			<div className='h-64 w-full bg-muted rounded-xl flex items-center justify-center border border-border mb-8'>
				<LoadingSpinner text='Generating tactical view...' size='sm' />
			</div>
		);

	return (
		<div
			className={clsx('mb-10 space-y-3 group', isPseudoFullscreen && 'fixed inset-0 z-[9999] m-0! bg-background')}
			ref={containerRef}>
			{!activeFullscreen && (
				<div className='flex items-center justify-between px-1'>
					<h3 className='font-serif text-lg mt-0 font-bold text-foreground mb-3 flex items-center gap-2'>
						<MapIcon size={16} className='text-accent' /> Map
					</h3>
				</div>
			)}

			<div
				className={clsx(
					'w-full overflow-hidden relative z-0 transition-all duration-300',
					activeFullscreen ? 'h-screen rounded-none border-0' : 'h-96 rounded-xl border border-border shadow-sm'
				)}>
				<MapContainer
					crs={L.CRS.Simple}
					bounds={dimensions}
					zoom={-2}
					minZoom={-3}
					scrollWheelZoom={true}
					attributionControl={false}
					style={{
						height: '100%',
						width: '100%',
						backgroundColor: 'var(--background)',
						backgroundImage:
							'radial-gradient(circle at center, var(--border) 1px, transparent 1px), radial-gradient(circle at center, var(--border) 1px, transparent 1px)',
						backgroundSize: '40px 40px, 20px 20px',
						backgroundPosition: '0 0, 20px 20px',
					}}>
					<MapController bounds={dimensions} activeFullscreen={activeFullscreen} />
					<ImageOverlay url={imageUrl} bounds={dimensions} />

					{markers.map((marker, idx) => {
						const entityMatch = Array.from(entityMap.values()).find(
							(e) => e.name.toLowerCase() === marker.label.toLowerCase()
						);
						const entityAttrs = entityMatch ? parseAttributes(entityMatch.attributes) : {};

						const displayData = {
							title: marker.label,
							category:
								marker.category && marker.category !== 'default'
									? marker.category
									: entityMatch
									? entityMatch.type
									: 'Point of Interest',
							description: marker.description
								? marker.description
								: entityMatch
								? getAttributeValue(entityAttrs, ['summary', 'narrative']) || entityMatch.description
								: null,
							image: entityMatch ? resolveImageUrl(entityAttrs, 'background') : null,
						};

						const entityConfig = entityMatch ? getEntityConfig(entityMatch.type) : null;

						const handleWikiNav = (e) => {
							e.stopPropagation();
							if (entityMatch) {
								navigate(`/wiki/${entityMatch.type}/${entityMatch.id}`);
							}
						};

						return (
							<Marker
								key={`${marker.label}-${idx}`}
								position={[marker.lat, marker.lng]}
								icon={resolveMarkerIcon(marker)}>
								{marker.label && (
									<Popup className='custom-popup-clean' closeButton={false}>
										<div className='flex flex-col w-full font-sans bg-background rounded-lg overflow-hidden border border-border shadow-sm'>
											{displayData.image && (
												<div className='h-24 w-full relative bg-muted'>
													<img
														src={displayData.image}
														alt={displayData.title}
														className='w-full h-full object-cover m-0!'
													/>
													{/* FIX: Improved Gradient */}
													<div className='absolute inset-0 bg-gradient-to-t from-[var(--background)] via-[var(--background)]/80 via-30% to-transparent pointer-events-none' />
												</div>
											)}

											<div className={clsx('px-4 pb-3', displayData.image ? 'pt-2 -mt-8 relative z-10' : 'pt-4')}>
												<div className='flex items-start justify-between gap-2'>
													<div>
														<span
															className={clsx(
																'text-[10px] font-bold uppercase tracking-wider block mb-0.5',
																entityConfig ? entityConfig.tailwind.text : 'text-muted-foreground'
															)}>
															{displayData.category}
														</span>
														<h3 className='font-serif font-bold text-lg leading-tight text-foreground drop-shadow-sm m-0!'>
															{displayData.title}
														</h3>
													</div>
													{entityConfig && (
														<div
															className={clsx(
																'p-1.5 rounded-md border shrink-0 bg-background/80 backdrop-blur-sm',
																entityConfig.tailwind.border,
																entityConfig.tailwind.text
															)}>
															<entityConfig.icon size={14} />
														</div>
													)}
												</div>

												<div className='h-px w-full bg-border/50 my-3' />

												<div className='text-xs text-muted-foreground leading-relaxed max-h-32 overflow-y-auto custom-scrollbar'>
													{displayData.description || <span className='italic opacity-70'>No details available.</span>}
												</div>
											</div>

											{entityMatch && (
												<div className='bg-muted/50 p-2 border-t border-border'>
													<button
														onClick={handleWikiNav}
														className='w-full flex items-center justify-between px-3 py-1.5 rounded hover:bg-background text-muted-foreground hover:text-foreground transition-colors text-xs font-semibold group'>
														<span className='flex items-center gap-2'>
															<BookOpen size={12} /> View Encyclopedia
														</span>
														<ArrowRight size={12} className='opacity-0 group-hover:opacity-100 transition-opacity' />
													</button>
												</div>
											)}
										</div>
									</Popup>
								)}
							</Marker>
						);
					})}
				</MapContainer>

				<div
					className={clsx(
						'absolute z-[10060] transition-all duration-300',
						activeFullscreen ? 'top-[50%] right-4 lg:top-6 lg:right-6 pr-safe pt-safe' : 'top-4 right-4'
					)}>
					<button
						onClick={toggleFullscreen}
						className={clsx(
							'p-3 rounded-full border border-border shadow-2xl transition-all active:scale-90',
							'bg-background/95 backdrop-blur-md text-foreground hover:bg-primary hover:text-white'
						)}
						title={activeFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen'}>
						{activeFullscreen ? <Minimize size={20} strokeWidth={2.5} /> : <Maximize size={20} strokeWidth={2.5} />}
					</button>
				</div>
			</div>
		</div>
	);
};

--- END OF features\wiki\components\EntityMiniMap.jsx ---

--- FILE: features\wiki\components\EntitySidebar.jsx ---
import { useMemo } from 'react';
import { Tag, Network, Shield, Activity } from 'lucide-react';
import { clsx } from 'clsx';
import EntityIcon from '@/domain/entity/components/EntityIcon';
import EntityLink from '@/domain/entity/components/EntityLink';
import { capitalize, toTitleCase } from '@/shared/utils/textUtils';

// --- SUB-COMPONENTS ---
const AbilityGrid = ({ stats }) => (
	<div className='grid grid-cols-3 gap-2 mt-2 mb-4'>
		{stats.map((stat, i) => (
			<div
				key={i}
				className='bg-card/60 border border-border/80 rounded p-1.5 text-center flex flex-col items-center shadow-sm backdrop-blur-sm'>
				<span className='text-[9px] font-bold text-muted-foreground uppercase tracking-widest leading-none'>
					{stat.name}
				</span>
				<span className='text-lg font-bold text-foreground leading-none my-1 font-serif'>{stat.score}</span>
				<span className='text-[10px] font-medium text-muted-foreground bg-muted px-1.5 rounded-full'>{stat.mod}</span>
			</div>
		))}
	</div>
);

const TagList = ({ tags }) => (
	<div className='flex flex-wrap gap-1.5 mt-1 mb-3'>
		{tags.map((item, i) => (
			<span
				key={i}
				className='inline-flex items-center px-2 py-0.5 rounded text-[11px] font-semibold bg-muted text-card-foreground border border-border/60 shadow-sm'>
				{toTitleCase(item)}
			</span>
		))}
	</div>
);

const StandardTrait = ({ label, value, index }) => (
	<div
		className={clsx(
			'flex justify-between items-baseline px-3 py-2 border-b border-border/40 last:border-0',
			index % 2 === 0 ? 'bg-card/40' : 'bg-transparent'
		)}>
		<span className='text-[10px] font-bold uppercase tracking-widest text-muted-foreground/90 shrink-0 mr-4'>
			{label}
		</span>
		<span className='text-[13px] font-semibold text-foreground text-right leading-snug break-words'>
			{typeof value === 'string' ? toTitleCase(value) : value}
		</span>
	</div>
);

// --- HELPER: Connection Badge Colors ---
const getRoleStyle = (roleStr) => {
	// FIX: Standardized to generic style for all roles to ensure readability
	return 'bg-muted text-muted-foreground border-border/60';
};

// --- NEW COMPONENT: Type Divider ---
const TypeDivider = ({ label }) => (
	<div className='flex items-center gap-2 my-3'>
		<div className='h-px bg-muted flex-1' />
		<span className='text-[9px] font-bold text-muted-foreground uppercase tracking-widest'>{label}</span>
		<div className='h-px bg-muted flex-1' />
	</div>
);

// --- MAIN COMPONENT ---
export const EntitySidebar = ({ traits, connections }) => {
	const textTraits = traits.filter((t) => t.displayType === 'text');
	const specialTraits = traits.filter((t) => t.displayType !== 'text');

	// Group connections by Type Label
	const groupedConnections = useMemo(() => {
		if (!connections || connections.length === 0) return [];

		// 1. Sort by Type, then Name
		const sorted = [...connections].sort((a, b) => {
			const typeA = a.typeLabel || 'Other';
			const typeB = b.typeLabel || 'Other';
			const compareType = typeA.localeCompare(typeB);
			if (compareType !== 0) return compareType;
			return (a.name || '').localeCompare(b.name || '');
		});

		// 2. Group for rendering
		const groups = [];
		let currentType = null;
		let currentGroup = null;

		sorted.forEach((item) => {
			const type = item.typeLabel || 'Other';
			if (type !== currentType) {
				currentType = type;
				currentGroup = { type, items: [] };
				groups.push(currentGroup);
			}
			currentGroup.items.push(item);
		});

		return groups;
	}, [connections]);

	return (
		<div className='space-y-6 font-sans'>
			{/* 1. Standard Traits Table */}
			{textTraits.length > 0 && (
				<div className='bg-muted/30/50 border border-border/70 rounded-lg overflow-hidden'>
					{/* Header */}
					<div className='px-3 py-2 border-b border-border bg-muted/40 flex items-center gap-2'>
						<Tag size={12} className='text-primary-muted' />
						<h3 className='text-[11px] font-bold text-primary-muted uppercase tracking-widest'>Attributes</h3>
					</div>

					{/* Content */}
					<div className='flex flex-col'>
						{textTraits.map((prop, idx) => (
							<StandardTrait key={prop.key} label={prop.key} value={prop.value} index={idx} />
						))}
					</div>
				</div>
			)}

			{/* 2. Special Visual Blocks */}
			{specialTraits.length > 0 && (
				<div className='space-y-4 px-1'>
					{specialTraits.map((prop) => {
						if (prop.displayType === 'stat-grid') {
							return (
								<div key={prop.key}>
									<h3 className='text-[10px] font-bold text-muted-foreground uppercase tracking-wider mb-1 flex items-center gap-2 ml-1'>
										<Activity size={10} /> {prop.key}
									</h3>
									<AbilityGrid stats={prop.value} />
								</div>
							);
						}
						if (prop.displayType === 'tags') {
							return (
								<div key={prop.key}>
									<h3 className='text-[10px] font-bold text-muted-foreground uppercase tracking-wider mb-1 flex items-center gap-2 ml-1'>
										<Shield size={10} /> {prop.key}
									</h3>
									<TagList tags={prop.value} />
								</div>
							);
						}
						return null;
					})}
				</div>
			)}

			{/* 3. Connections (Grouped with Dividers) */}
			{groupedConnections.length > 0 && (
				<div>
					<h3 className='text-[10px] font-bold text-muted-foreground uppercase tracking-wider mb-2 flex items-center gap-2 px-1'>
						<Network size={10} /> Connections
					</h3>

					<div className='space-y-1'>
						{groupedConnections.map((group, gIdx) => (
							<div key={group.type}>
								<TypeDivider label={group.type} />

								<div className='space-y-2'>
									{group.items.map((rel, i) => (
										<EntityLink
											key={rel.id}
											id={rel.id}
											type={rel.typeLabel}
											inline={true}
											showIcon={false}
											className={clsx(
												'!flex !w-full !items-center !justify-between !p-2 !rounded-lg !border !bg-card/60 !transition-all !cursor-pointer !no-underline',
												'!border-border hover:!border-amber-300 hover:!shadow-sm hover:!bg-card',
												rel.theme.hover
											)}>
											<div className='flex items-center gap-2.5 flex-1 min-w-0'>
												<EntityIcon type={rel.typeLabel} size={14} className='opacity-80 group-hover:opacity-100' />
												<span className='text-sm font-semibold text-card-foreground truncate group-hover:text-foreground transition-colors'>
													{rel.name}
												</span>
											</div>
											<span
												className={clsx(
													'shrink-0 text-[9px] font-bold uppercase tracking-wider px-2 py-0.5 rounded border ml-2 max-w-[45%] truncate',
													getRoleStyle(rel.role)
												)}>
												{rel.role}
											</span>
										</EntityLink>
									))}
								</div>
							</div>
						))}
					</div>
				</div>
			)}
		</div>
	);
};

--- END OF features\wiki\components\EntitySidebar.jsx ---

--- FILE: features\wiki\components\QuestObjectives.jsx ---
import { useState } from 'react';
import {
	CheckCircle2,
	Circle,
	XCircle,
	Target,
	Calendar,
	ChevronDown,
	ChevronRight,
	CornerDownRight,
} from 'lucide-react';
import { clsx } from 'clsx';
import SmartMarkdown from '@/features/smart-text/SmartMarkdown';
import EntityLink from '@/domain/entity/components/EntityLink';

const QuestObjectiveItem = ({ obj }) => {
	const [isOpen, setIsOpen] = useState(false);

	const isCompleted = obj.status === 'completed';
	const isFailed = obj.status === 'failed';

	const hasUpdate = !!obj.objective_update;
	const hasSession = isCompleted && obj.completed_session_number;
	const hasContent = hasUpdate || (hasSession && obj.completed_session_title);

	const toggle = () => hasContent && setIsOpen(!isOpen);

	return (
		<div
			className={clsx(
				'transition-colors border-b border-border/40 last:border-0',
				isCompleted ? 'bg-emerald-500/10/10' : isFailed ? 'bg-red-500/10/10' : 'hover:bg-muted/30'
			)}>
			{/* --- MAIN ROW --- */}
			<div
				className={clsx(
					'flex items-start gap-3 px-3 py-2 cursor-pointer group',
					hasContent ? 'hover:bg-black/5' : 'cursor-default'
				)}
				onClick={toggle}>
				{/* Status Icon */}
				<div className='mt-1.5 shrink-0'>
					{isCompleted ? (
						<CheckCircle2 size={16} className='text-emerald-600' />
					) : isFailed ? (
						<XCircle size={16} className='text-red-500' />
					) : (
						<Circle size={16} className='text-muted-foreground/40' strokeWidth={2} />
					)}
				</div>

				{/* Text Content */}
				<div className='flex-1 min-w-0 pt-0.5'>
					<div className='flex items-center justify-between gap-2 mb-0.5'>
						{obj.objective_name && (
							<div className='text-[10px] font-bold text-muted-foreground/70 uppercase tracking-wide'>
								{obj.objective_name}
							</div>
						)}

						{/* Session Indicator Badge (Inline) */}
						{hasSession && (
							<div
								className='flex items-center gap-1 px-1.5 py-0.5 rounded text-[9px] font-bold uppercase tracking-wider bg-muted text-muted-foreground border border-border/60'
								title={`Completed in Session ${obj.completed_session_number - 1}`}>
								<Calendar size={10} />
								<span className='hidden sm:inline'>Session</span> {obj.completed_session_number - 1}
							</div>
						)}
					</div>

					<div
						className={clsx(
							'text-[13px] leading-snug font-medium transition-colors',
							isCompleted ? 'text-muted-foreground' : isFailed ? 'text-red-800/80' : 'text-foreground'
						)}>
						<SmartMarkdown components={{ p: 'span' }}>{obj.description}</SmartMarkdown>
					</div>
				</div>

				{/* Toggle Chevron */}
				{hasContent && (
					<button
						className={clsx(
							'shrink-0 text-muted-foreground/70 group-hover:text-foreground transition-colors mt-0.5',
							isOpen && 'text-foreground'
						)}>
						{isOpen ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
					</button>
				)}
			</div>

			{/* --- DROPDOWN CONTENT --- */}
			{isOpen && hasContent && (
				<div className='pl-9 pr-3 pb-2 -mt-1 animate-in slide-in-from-top-1 fade-in duration-200'>
					<div className='flex flex-col gap-1.5'>
						{/* Update Text */}
						{hasUpdate && (
							<div className='flex gap-2 items-start'>
								<CornerDownRight size={12} className='shrink-0 mt-1 text-primary opacity-60' />
								<span className='text-xs text-muted-foreground italic leading-relaxed'>
									<SmartMarkdown>{obj.objective_update}</SmartMarkdown>
								</span>
							</div>
						)}
					</div>
				</div>
			)}
		</div>
	);
};

export const QuestObjectives = ({ objectives }) => {
	if (!objectives || objectives.length === 0) return null;

	return (
		<div className='mb-8 not-prose border border-border rounded-lg overflow-hidden bg-muted/30/20'>
			<div className='px-3 py-2 border-b border-border bg-muted/50 flex items-center gap-2'>
				<h3 className='text-[10px] font-bold text-muted-foreground uppercase tracking-wider flex items-center gap-2 m-0'>
					<Target size={12} className='text-primary' /> Quest Objectives
				</h3>
				<span className='ml-auto text-[9px] font-bold bg-muted/80 px-1.5 py-0.5 rounded text-muted-foreground'>
					{objectives.filter((o) => o.status === 'completed').length} / {objectives.length}
				</span>
			</div>

			<div className='bg-background'>
				{objectives.map((obj, idx) => (
					<QuestObjectiveItem key={obj.id || idx} obj={obj} />
				))}
			</div>
		</div>
	);
};

--- END OF features\wiki\components\QuestObjectives.jsx ---

--- FILE: features\wiki\components\SessionMentions.jsx ---
import { clsx } from 'clsx';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import EntityLink from '@/domain/entity/components/EntityLink';
import EntityIcon from '@/domain/entity/components/EntityIcon';

const MentionGroup = ({ type, items }) => {
	const config = getEntityConfig(type);
	const Icon = config.icon;

	return (
		<div className='border border-border rounded-lg overflow-hidden bg-muted/30/30 flex flex-col'>
			{/* Header */}
			<div className='px-3 py-2 border-b border-border bg-muted/50 flex items-center justify-between shrink-0'>
				<div className='flex items-center gap-2'>
					<Icon size={12} className='text-muted-foreground' />
					<h3 className='text-[10px] font-bold text-muted-foreground uppercase tracking-widest m-0'>{config.labelPlural}</h3>
				</div>
				<span className='text-[9px] font-bold text-muted-foreground bg-muted/60 px-1.5 py-0.5 rounded-full'>
					{items.length}
				</span>
			</div>

			{/* List Container - Reverted to Vertical Column */}
			<div className='p-2'>
				<div className='flex flex-col gap-1.5'>
					{items.map((item) => (
						<EntityLink
							key={item.id}
							id={item.id}
							type={item.type}
							inline={true} // Use inline mode to get a cleaner DOM structure (A -> SPAN)
							showIcon={false} // We provide our own icon in the children for custom styling
							className={clsx(
								// Override generic InlineLink styles to make it look like a card
								'!block !w-full !no-underline !border',
								'!bg-card/60 !border-border/80 !rounded-md',
								'!px-2 !py-1.5',
								// Colors
								'!text-card-foreground hover:!text-foreground',
								// Hover states
								'hover:!bg-card hover:!border-amber-300 hover:!shadow-sm transition-all'
							)}>
							{/* Inner Layout Wrapper to handle Flex behavior correctly */}
							<span className='flex items-center gap-2.5 min-w-0'>
								<EntityIcon type={item.type} size={14} className='opacity-70 text-muted-foreground shrink-0' />
								<span className='text-[13px] font-semibold truncate'>{item.name}</span>
							</span>
						</EntityLink>
					))}
				</div>
			</div>
		</div>
	);
};

export const SessionMentions = ({ mentions }) => {
	if (!mentions || Object.keys(mentions).length === 0) {
		return (
			<div className='p-12 text-center text-muted-foreground italic border border-dashed border-border rounded-lg'>
				No linked entities found in this session.
			</div>
		);
	}

	const order = ['character', 'npc', 'location', 'faction', 'quest', 'encounter'];
	const orderedKeys = order.filter((k) => mentions[k]).concat(Object.keys(mentions).filter((k) => !order.includes(k)));

	return (
		<div className='columns-1 md:columns-2 xl:columns-3 gap-4'>
			{orderedKeys.map((key) => (
				<div key={key} className='break-inside-avoid mb-4'>
					<MentionGroup type={key} items={mentions[key]} />
				</div>
			))}
		</div>
	);
};

--- END OF features\wiki\components\SessionMentions.jsx ---

--- FILE: features\wiki\components\WikiEntryView.jsx ---
// features/entity-view/WikiEntityView.jsx
import { useEntityViewModel } from '@/features/wiki/useEntityView';
import { EntityHeader } from '@/features/wiki/components/EntityHeader';
import StandardLayout from '@/features/wiki/layouts/StandardLayout';
import SessionLayout from '@/features/wiki/layouts/SessionLayout';

export default function WikiEntityView({ entity }) {
	const viewModel = useEntityViewModel(entity);

	if (!viewModel) return null;

	// Determine layout based on entity type
	let LayoutComponent;
	if (entity?.type === 'session') {
		LayoutComponent = SessionLayout;
	} else {
		LayoutComponent = StandardLayout;
	}

	return (
		<div className='pb-16 animate-in fade-in duration-300 min-h-full'>
			{/* Universal Header */}
			<EntityHeader data={viewModel.header} />

			{/* Dynamic Layout */}
			<LayoutComponent viewModel={viewModel} />
		</div>
	);
}

--- END OF features\wiki\components\WikiEntryView.jsx ---

--- FILE: features\wiki\components\landing\EntityGridCard.jsx ---
import { Link } from 'react-router-dom';
import { clsx } from 'clsx';
import { resolveImageUrl, parseAttributes } from '@/shared/utils/imageUtils';
import { getStatusInfo } from '@/domain/entity/utils/statusUtils';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

// Helper: Description Extraction
const resolveDescription = (entity, attributes) => {
	if (entity.description && entity.description.length > 0) return entity.description;
	const text = getAttributeValue(attributes, [
		'summary',
		'narrative',
		'background',
		'description',
		'short_description',
		'appearance',
		'history',
		'role',
	]);
	return text || null;
};

export const EntityGridCard = ({ entity, config, context }) => {
	const attributes = parseAttributes(entity.attributes);
	const imageUrl = resolveImageUrl(attributes, 'background') || resolveImageUrl(attributes, 'icon');
	const status = getStatusInfo(entity);
	const description = resolveDescription(entity, attributes);

	// Status Logic
	const isActorOrQuest = ['npc', 'character', 'faction', 'quest'].includes(entity.type);
	const hasMeaningfulStatus = status.isDead || status.isFailed || status.rank === 1 || status.rank === 3;
	const showStatus = isActorOrQuest && hasMeaningfulStatus;

	// Determine Status Color
	let statusBorderClass = 'border-l-transparent';
	if (showStatus) {
		if (status.isDead || status.isFailed) statusBorderClass = 'border-l-red-500';
		else if (status.rank === 3) statusBorderClass = 'border-l-red-600';
		else if (status.rank === 1) statusBorderClass = 'border-l-emerald-500';
	}

	// Metadata Logic
	let footerLabel = entity.type;
	if (context === 'geo') {
		const role = getAttributeValue(attributes, ['role', 'occupation', 'class', 'monster type']);
		footerLabel = role || entity.type;
	} else {
		footerLabel = entity.meta?.region || entity.type;
	}

	return (
		<Link
			to={`/wiki/${entity.type}/${entity.id}`}
			className={clsx(
				'group flex bg-background border border-border rounded-lg overflow-hidden transition-all duration-200 h-20',
				'hover:shadow-sm hover:bg-muted/10',
				showStatus ? `border-l-[3px] ${statusBorderClass}` : 'border-l'
			)}>
			{/* Left: Image/Icon Square */}
			<div className='w-20 shrink-0 relative bg-muted/30 border-r border-border/50'>
				{imageUrl ? (
					<>
						<img
							src={imageUrl}
							alt={entity.name}
							className='w-full h-full object-cover transition-transform duration-700 group-hover:scale-105'
						/>
						<div className='absolute inset-0 bg-black/5 group-hover:bg-transparent transition-colors' />
					</>
				) : (
					<div className='w-full h-full flex items-center justify-center bg-muted'>
						{/* FIX: Removed 'mix-blend-multiply' to fix invisible icons in Dark Mode */}
						<config.icon size={28} className='text-muted-foreground/70' strokeWidth={1.5} />
					</div>
				)}
			</div>

			{/* Right: Content */}
			<div className='flex-1 px-3 py-2 flex flex-col min-w-0 justify-center'>
				<div className='flex items-center justify-between gap-2'>
					<h3 className='font-serif font-bold text-sm text-foreground group-hover:text-primary transition-colors truncate'>
						{entity.name}
					</h3>
				</div>

				<div className='text-[11px] text-muted-foreground truncate opacity-80 mt-0.5'>
					{description || <span className='opacity-50 italic'>{footerLabel}</span>}
				</div>
			</div>
		</Link>
	);
};

--- END OF features\wiki\components\landing\EntityGridCard.jsx ---

--- FILE: features\wiki\components\landing\EntityTableGroup.jsx ---
import { Link } from 'react-router-dom';
import { clsx } from 'clsx';
import { ArrowRight, CornerDownRight } from 'lucide-react';
import { getStatusInfo } from '@/domain/entity/utils/statusUtils';
import EntityBadge from '@/domain/entity/components/EntityBadge';
import { parseAttributes } from '@/shared/utils/imageUtils';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

export const EntityTableGroup = ({ title, parentTitle, link, items }) => {
	if (!items || items.length === 0) return null;

	return (
		<div className='mb-8 animate-in fade-in duration-500'>
			{/* Group Header */}
			<div className='flex items-center gap-2 border-b border-border/60 pb-2 mb-3'>
				{parentTitle && (
					// FIX: Increased opacity from /40 to /80 for visibility
					<div className='flex items-center gap-1 text-[10px] font-bold text-muted-foreground/80 uppercase tracking-widest'>
						{parentTitle}
						{/* FIX: Removed opacity-50 to make arrow visible */}
						<CornerDownRight size={10} className='translate-y-px text-muted-foreground' />
					</div>
				)}
				<h2 className='text-sm font-bold text-foreground flex items-center gap-2 uppercase tracking-wide'>
					{title}
					{link && (
						<Link
							to={link}
							className='text-muted-foreground/50 hover:text-primary transition-colors'
							title={`View ${title}`}>
							<ArrowRight size={12} />
						</Link>
					)}
				</h2>
				<span className='text-[9px] font-bold bg-muted px-1.5 py-px rounded text-muted-foreground/60 ml-auto'>
					{items.length}
				</span>
			</div>

			{/* Table Container */}
			<div className='bg-background border border-border rounded-lg overflow-hidden shadow-sm'>
				<table className='w-full text-left text-sm'>
					<thead className='bg-muted/50 text-[10px] uppercase font-bold text-muted-foreground tracking-wider border-b border-border'>
						<tr>
							<th className='px-4 py-2 w-[40%]'>Name</th>
							<th className='px-4 py-2 w-[20%]'>Status</th>
							<th className='px-4 py-2 hidden md:table-cell'>Details</th>
						</tr>
					</thead>
					<tbody className='divide-y divide-border/50'>
						{items.map((entity) => {
							const status = getStatusInfo(entity);
							const attributes = parseAttributes(entity.attributes);
							const role = getAttributeValue(attributes, ['role', 'occupation', 'class', 'type']) || entity.type;

							// Check if row needs highlighting
							const isSpecialStatus = status.isDead || status.isFailed || status.rank === 1 || status.rank === 3;

							return (
								<tr key={entity.id} className='group hover:bg-muted/30 transition-colors'>
									<td className='px-4 py-2.5'>
										<Link
											to={`/wiki/${entity.type}/${entity.id}`}
											className='flex items-center gap-3 font-serif font-bold text-foreground group-hover:text-primary transition-colors'>
											{/* Small colored indicator bar */}
											{isSpecialStatus && (
												<div
													className={clsx(
														'w-1 h-4 rounded-full shrink-0',
														status.isDead || status.isFailed
															? 'bg-red-500/100'
															: status.rank === 1
															? 'bg-emerald-500/100'
															: status.rank === 3
															? 'bg-red-600'
															: 'bg-gray-300'
													)}
												/>
											)}
											{entity.name}
										</Link>
									</td>
									<td className='px-4 py-2.5'>
										{status.display && (
											<span
												className={clsx(
													'inline-flex items-center text-[10px] uppercase font-bold px-1.5 py-0.5 rounded border',
													status.isDead || status.isFailed
														? 'bg-red-500/10 text-red-700 border-red-100'
														: 'bg-muted text-muted-foreground border-border'
												)}>
												{status.display}
											</span>
										)}
									</td>
									<td className='px-4 py-2.5 hidden md:table-cell'>
										<div className='flex items-center gap-2'>
											<EntityBadge type={entity.type} size='sm' variant='subtle' />
											<span className='text-xs text-muted-foreground truncate max-w-[200px]'>
												{role !== entity.type ? role : ''}
											</span>
										</div>
									</td>
								</tr>
							);
						})}
					</tbody>
				</table>
			</div>
		</div>
	);
};

--- END OF features\wiki\components\landing\EntityTableGroup.jsx ---

--- FILE: features\wiki\components\landing\Swimlane.jsx ---
import { Link } from 'react-router-dom';
import { ArrowRight, CornerDownRight } from 'lucide-react';
import { EntityGridCard } from './EntityGridCard';

export const Swimlane = ({ title, parentTitle, link, items, config, context }) => {
	if (!items || items.length === 0) return null;

	return (
		<div className='mb-8 last:mb-0 animate-in fade-in slide-in-from-bottom-3 duration-500'>
			{/* Header: Compact Visual Hierarchy */}
			<div className='flex items-center gap-2 border-b border-border/60 pb-1.5 mb-3 group/header'>
				{parentTitle && (
					// FIX: Increased visibility (was /40)
					<div className='flex items-center gap-1 text-[10px] font-bold text-muted-foreground/80 uppercase tracking-widest'>
						{parentTitle}
						<CornerDownRight size={10} className='translate-y-px text-muted-foreground' />
					</div>
				)}

				<h2 className='text-sm font-bold text-foreground flex items-center gap-2 uppercase tracking-wide'>
					{title}
					{link && (
						<Link
							to={link}
							className='text-muted-foreground/50 hover:text-accent transition-colors'
							title={`View ${title}`}>
							<ArrowRight size={12} />
						</Link>
					)}
				</h2>

				<span className='text-[9px] font-bold bg-muted px-1.5 py-px rounded text-muted-foreground/60 ml-auto'>
					{items.length}
				</span>
			</div>

			{/* Grid - Reverted to Standard Responsive Grid */}
			<div className='grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-3'>
				{items.map((entity) => (
					<EntityGridCard key={entity.id} entity={entity} config={config} context={context} />
				))}
			</div>
		</div>
	);
};

--- END OF features\wiki\components\landing\Swimlane.jsx ---

--- FILE: features\wiki\components\navigation\SidebarEmptyState.jsx ---
import { BookOpen } from 'lucide-react';
import EmptyState from '@/shared/components/ui/EmptyState'; // Adjust path

export const SidebarEmptyState = ({ label }) => {
	// Remove 's' from end for singular usage if needed, or just use as is
	const singular = label.endsWith('s') ? label.slice(0, -1) : label;

	return (
		<EmptyState
			icon={BookOpen}
			title={`No ${label} Yet`}
			description={`Create your first ${singular.toLowerCase()} to get started.`}
			className='py-8'
		/>
	);
};

--- END OF features\wiki\components\navigation\SidebarEmptyState.jsx ---

--- FILE: features\wiki\components\navigation\WikiSidebar.jsx ---
import { useState } from 'react';
import { clsx } from 'clsx';
import { PanelLeftClose, PanelLeftOpen } from 'lucide-react';
import { WikiSidebarHeader } from './WikiSidebarHeader';
import { WikiSidebarList } from './WikiSidebarList';

export const WikiSidebar = ({ navigation, className }) => {
	const [mobileOpen, setMobileOpen] = useState(false);
	const [desktopCollapsed, setDesktopCollapsed] = useState(false);

	return (
		<>
			{/* COLLAPSED STATE (Slim Bar) */}
			{desktopCollapsed && (
				<div className='hidden lg:flex flex-col h-full border-l border-border bg-muted/50 w-10 shrink-0 z-30 transition-all duration-300 lg:order-2 items-center'>
					<div className='h-14 w-full flex items-center justify-center border-b border-border/50'>
						<button
							onClick={() => setDesktopCollapsed(false)}
							className='p-1.5 text-muted-foreground hover:text-primary hover:bg-background rounded-md transition-colors'
							title='Expand Sidebar'>
							{/* Icon flipped for right-side sidebar */}
							<PanelLeftClose size={18} />
						</button>
					</div>
				</div>
			)}

			{/* FULL SIDEBAR */}
			<div
				className={clsx(
					'flex flex-col bg-muted border-b border-border',
					'sticky top-0 w-full z-30', // Mobile
					'lg:static lg:border-b-0 lg:h-full lg:transition-all lg:duration-300', // Desktop
					// Dynamic Width Logic:
					// If collapsed, width becomes 0 and overflow hidden to disappear
					desktopCollapsed
						? 'lg:w-0 lg:border-l-0 lg:overflow-hidden opacity-0 lg:opacity-100'
						: 'lg:w-72 lg:border-l lg:border-border',
					className
				)}>
				<WikiSidebarHeader
					config={navigation.config}
					search={navigation.search}
					onSearchChange={navigation.setSearch}
					onToggle={() => setMobileOpen(!mobileOpen)}
					isOpen={mobileOpen}
					// FIX: Pass toggle as a render prop to avoid layout overlap
					renderDesktopToggle={() => (
						<button
							onClick={() => setDesktopCollapsed(true)}
							className='text-muted-foreground hover:text-primary transition-colors p-0.5 rounded'
							title='Collapse Sidebar'>
							<PanelLeftOpen size={18} />
						</button>
					)}
				/>

				{/* Content Wrapper */}
				<div
					className={clsx(
						'grid transition-[grid-template-rows] duration-300 ease-[cubic-bezier(0.32,0.72,0,1)]',
						'lg:grid-rows-[1fr] lg:static lg:h-full',
						mobileOpen ? 'grid-rows-[1fr] border-b border-border shadow-xl' : 'grid-rows-[0fr]'
					)}>
					<div className='overflow-hidden'>
						<div
							className={clsx(
								'lg:h-full lg:overflow-y-auto',
								mobileOpen && 'max-h-[70dvh] overflow-y-auto custom-scrollbar'
							)}>
							<WikiSidebarList
								groups={navigation.groups}
								isLoading={navigation.isLoading}
								hasItems={navigation.hasItems}
								config={navigation.config}
								onItemClick={() => setMobileOpen(false)}
							/>
						</div>
					</div>
				</div>

				{/* Mobile Backdrop */}
				<div
					className={clsx(
						'fixed inset-0 top-[110px] bg-black/40 z-[-1] lg:hidden backdrop-blur-[1px] transition-opacity duration-300',
						mobileOpen ? 'opacity-100 pointer-events-auto' : 'opacity-0 pointer-events-none'
					)}
					onClick={() => setMobileOpen(false)}
					style={{ touchAction: 'none' }}
				/>
			</div>
		</>
	);
};

--- END OF features\wiki\components\navigation\WikiSidebar.jsx ---

--- FILE: features\wiki\components\navigation\WikiSidebarHeader.jsx ---
import { Search, ChevronDown, ChevronUp } from 'lucide-react';
import { clsx } from 'clsx';

export const WikiSidebarHeader = ({ config, search, onSearchChange, onToggle, isOpen, renderDesktopToggle }) => {
	const { Icon, label, textClass } = config;

	return (
		<div className='p-3 lg:p-4 bg-muted border-b border-border/50'>
			{/* Title Row - Clickable on mobile */}
			<div
				className='flex items-center justify-between cursor-pointer lg:cursor-default select-none h-8'
				onClick={onToggle}>
				<div className='flex items-center gap-3 min-w-0 w-full'>
					{Icon && <Icon size={18} className={clsx(textClass, 'shrink-0')} />}
					<h1 className='text-sm font-serif font-bold text-foreground capitalize tracking-wide truncate'>{label}</h1>

					{/* FIX: Render desktop toggle here to avoid overlap */}
					{renderDesktopToggle && <div className='hidden lg:block shrink-0 ml-auto mr-1'>{renderDesktopToggle()}</div>}
				</div>

				{/* Mobile Toggle Button - Larger Touch Target */}
				<button
					className='lg:hidden text-muted-foreground hover:text-foreground active:bg-black/10 p-2 -mr-2 rounded-md transition-colors'
					aria-label={isOpen ? 'Collapse' : 'Expand'}>
					{isOpen ? <ChevronUp size={20} /> : <ChevronDown size={20} />}
				</button>
			</div>

			{/* Search Bar */}
			<div className={clsx('mt-3 relative', !isOpen && 'hidden lg:block')}>
				<Search className='absolute left-3 top-2.5 text-muted-foreground/70' size={14} />
				<input
					type='text'
					placeholder='Filter list...'
					value={search}
					onChange={(e) => onSearchChange(e.target.value)}
					onClick={(e) => e.stopPropagation()}
					className='w-full bg-background border border-border rounded-md pl-9 pr-3 py-2 text-base lg:text-xs focus:ring-1 focus:ring-primary/50 focus:border-primary outline-none transition-shadow shadow-sm'
				/>
			</div>
		</div>
	);
};

--- END OF features\wiki\components\navigation\WikiSidebarHeader.jsx ---

--- FILE: features\wiki\components\navigation\WikiSidebarList.jsx ---
import LoadingSpinner from '@/shared/components/ui/LoadingSpinner';
import { SidebarEmptyState } from './SidebarEmptyState';
import { CollapsibleGroup } from './sidebar/CollapsibleGroup';
import { EntityListItem } from './sidebar/EntityListItem';
import { SidebarTreeItem } from './sidebar/SidebarTreeItem';

export const WikiSidebarList = ({ groups, isLoading, hasItems, config, onItemClick }) => {
	if (isLoading) {
		return (
			<div className='p-8 flex justify-center'>
				<LoadingSpinner size='sm' text='Loading...' />
			</div>
		);
	}

	if (!hasItems) {
		return <SidebarEmptyState label={config.label} />;
	}

	// Flatten check for empty search results
	const totalItems = groups.reduce((acc, g) => acc + g.items.length, 0);
	if (totalItems === 0) {
		return <div className='p-6 text-center text-xs text-muted-foreground/70 italic'>No matches found.</div>;
	}

	// Check if we have standard grouped data (multiple groups with titles)
	const isGrouped = !groups[0].isTree && (groups.length > 1 || (groups.length === 1 && groups[0].title !== null));

	return (
		<div className='lg:overflow-y-auto lg:h-full bg-muted py-1 custom-scrollbar'>
			{/* MODE 1: TREE (Recursive) */}
			{groups[0].isTree ? (
				<div className='px-1 space-y-0.5'>
					{groups[0].items.map((item) => (
						<SidebarTreeItem key={item.id} item={item} onItemClick={onItemClick} />
					))}
				</div>
			) : /* MODE 2: GROUPED (Collapsible Categories) */
			isGrouped ? (
				<div className='space-y-1'>
					{groups.map((group) => (
						<CollapsibleGroup key={group.id} group={group} onItemClick={onItemClick} />
					))}
				</div>
			) : (
				/* MODE 3: FLAT LIST */
				<div className='px-2 space-y-0.5'>
					{groups[0].items.map((item) => {
						const showStatus = ['npc', 'faction', 'quest'].includes(item.type);
						return <EntityListItem key={item.id} item={item} showStatus={showStatus} onItemClick={onItemClick} />;
					})}
				</div>
			)}
		</div>
	);
};

--- END OF features\wiki\components\navigation\WikiSidebarList.jsx ---

--- FILE: features\wiki\components\navigation\sidebar\CollapsibleGroup.jsx ---
import { useState } from 'react';
import { ChevronRight, ChevronDown } from 'lucide-react';
import { EntityListItem } from './EntityListItem';

export const CollapsibleGroup = ({ group, onItemClick }) => {
	const [isOpen, setIsOpen] = useState(true);

	// Determine if we should show status icons
	const showStatus = group.items.some((item) => ['npc', 'faction', 'quest'].includes(item.type));

	return (
		<div className='select-none'>
			{/* Group Header - Collapsible */}
			<button
				onClick={() => setIsOpen(!isOpen)}
				className='w-full flex items-center gap-1.5 px-2 py-1 text-[11px] font-semibold uppercase tracking-wider text-muted-foreground hover:text-foreground/80 hover:bg-black/5 transition-colors'>
				{isOpen ? <ChevronDown size={12} /> : <ChevronRight size={12} />}
				<span className='truncate'>{group.title}</span>
				<span className='ml-auto text-[10px] font-normal text-muted-foreground/70'>{group.items.length}</span>
			</button>

			{/* Items */}
			{isOpen && (
				<div className='space-y-0.5 pb-1'>
					{group.items.map((item) => (
						<EntityListItem key={item.id} item={item} showStatus={showStatus} onItemClick={onItemClick} />
					))}
				</div>
			)}
		</div>
	);
};

--- END OF features\wiki\components\navigation\sidebar\CollapsibleGroup.jsx ---

--- FILE: features\wiki\components\navigation\sidebar\EntityListItem.jsx ---
import { NavLink } from 'react-router-dom';
import { clsx } from 'clsx';
import { StatusIcon } from './StatusIcon';
import { PriorityIcon } from './PriorityIcon';
import EntityIcon from '@/domain/entity/components/EntityIcon';
import { resolveImageUrl } from '@/shared/utils/imageUtils';
import { resolveEntityIcon } from '@/domain/entity/config/entityIcons'; // Import Central Config

export const EntityListItem = ({ item, showStatus, onItemClick }) => {
	const isQuest = item.type === 'quest';
	const hasPriority = isQuest && item.meta.priority;

	const iconUrl = resolveImageUrl(item.attributes, 'icon');
	const hasCustomIcon = !!iconUrl;

	// Use Centralized Resolver
	const ResolvedIcon = resolveEntityIcon({ type: item.type, attributes: item.attributes });

	// Determine if we show the icon.
	const shouldShowIcon = hasCustomIcon || !['quest', 'faction'].includes(item.type);

	return (
		<NavLink
			to={item.path}
			onClick={onItemClick}
			className={({ isActive }) =>
				clsx(
					'group flex items-center w-full text-left pl-6 pr-2 py-1 text-[13px] transition-colors',
					// FIX: Replaced 'bg-accent/10' with 'bg-primary/10' and text color for visibility
					isActive
						? 'bg-primary/10 text-primary font-bold'
						: 'text-foreground/80 hover:bg-black/5 hover:text-foreground'
				)
			}>
			{shouldShowIcon && (
				<span
					className={clsx(
						'shrink-0 flex items-center justify-center mr-2',
						!hasCustomIcon && 'opacity-70 text-muted-foreground',
						// Ensure icon inherits color when active
						hasCustomIcon ? '' : 'group-[.active]:text-primary'
					)}>
					{hasCustomIcon ? (
						<EntityIcon type={item.type} customIconUrl={iconUrl} size={16} className='rounded-full object-cover' />
					) : (
						<ResolvedIcon size={14} />
					)}
				</span>
			)}

			{showStatus && (
				<span
					className={clsx(
						'flex-shrink-0 flex items-center justify-center opacity-70',
						hasPriority ? 'mr-1' : 'mr-2',
						!shouldShowIcon && 'ml-[-2px]'
					)}>
					<StatusIcon entity={item} />
				</span>
			)}

			{hasPriority && (
				<span className='mr-2 flex-shrink-0 flex items-center justify-center opacity-90'>
					<PriorityIcon priority={item.meta.priority} />
				</span>
			)}

			<span className='truncate flex-1'>{item.name}</span>
		</NavLink>
	);
};

--- END OF features\wiki\components\navigation\sidebar\EntityListItem.jsx ---

--- FILE: features\wiki\components\navigation\sidebar\PriorityIcon.jsx ---
import { ChevronUp, ChevronsUp, ChevronsDown, Minus, AlertCircle } from 'lucide-react';

export const PriorityIcon = ({ priority }) => {
	if (!priority) return null;
	const p = priority.toLowerCase();

	// Critical
	if (p.includes('critical')) {
		return <ChevronsUp size={14} className='text-orange-600' strokeWidth={3} />;
	}

	// High / Urgent
	if (p.includes('high')) {
		return <ChevronUp size={14} className='text-orange-600' strokeWidth={3} />;
	}

	// Low
	if (p.includes('low')) {
		return <ChevronsDown size={14} className='text-slate-400' strokeWidth={3} />;
	}

	// Medium / Normal
	if (p.includes('medium') || p.includes('normal')) {
		return <Minus size={14} className='text-blue-400' strokeWidth={3} />;
	}

	return null;
};

--- END OF features\wiki\components\navigation\sidebar\PriorityIcon.jsx ---

--- FILE: features\wiki\components\navigation\sidebar\SidebarTreeItem.jsx ---
import { useState } from 'react';
import { NavLink } from 'react-router-dom';
import { ChevronRight, ChevronDown } from 'lucide-react';
import { clsx } from 'clsx';
import EntityIcon from '@/domain/entity/components/EntityIcon';
import { StatusIcon } from './StatusIcon';
import { resolveImageUrl } from '@/shared/utils/imageUtils';
import { resolveEntityIcon } from '@/domain/entity/config/entityIcons'; // Import

export const SidebarTreeItem = ({ item, onItemClick }) => {
	const [isExpanded, setIsExpanded] = useState(true);
	const hasChildren = item.children && item.children.length > 0;
	const showStatus = ['npc', 'faction', 'quest'].includes(item.type);

	const iconUrl = resolveImageUrl(item.attributes, 'icon');
	const hasCustomIcon = !!iconUrl;

	// Use centralized resolver
	const ResolvedIcon = resolveEntityIcon({ type: item.type, attributes: item.attributes });

	return (
		<div className='select-none font-sans'>
			<div className='flex items-center w-full group py-0.5 hover:bg-black/5 rounded-sm transition-colors'>
				<button
					onClick={(e) => {
						e.preventDefault();
						e.stopPropagation();
						if (hasChildren) setIsExpanded(!isExpanded);
					}}
					className={clsx(
						'w-5 h-6 flex items-center justify-center shrink-0 text-muted-foreground/70 hover:text-foreground transition-colors cursor-pointer',
						!hasChildren && 'invisible pointer-events-none'
					)}>
					{isExpanded ? <ChevronDown size={10} /> : <ChevronRight size={10} />}
				</button>

				<NavLink
					to={item.path}
					onClick={onItemClick}
					className={({ isActive }) =>
						clsx(
							'flex-1 flex items-center gap-1.5 pr-2 text-[13px] truncate transition-colors rounded-r-sm',
							// FIX: Replaced 'text-accent' with 'text-primary' and background
							isActive ? 'text-primary font-bold bg-primary/10' : 'text-foreground/80'
						)
					}>
					<span
						className={clsx(
							'shrink-0 flex items-center justify-center',
							!hasCustomIcon && 'opacity-100',
							// Ensure icon inherits color when active
							!hasCustomIcon && (item.type === 'location' ? 'text-muted-foreground' : 'text-muted-foreground')
						)}>
						{hasCustomIcon ? (
							<EntityIcon type={item.type} customIconUrl={iconUrl} size={14} />
						) : (
							<ResolvedIcon size={14} strokeWidth={2} />
						)}
					</span>

					<span className='truncate'>{item.name}</span>
					{showStatus && (
						<span className='ml-auto opacity-70 flex items-center'>
							<StatusIcon entity={item} />
						</span>
					)}
				</NavLink>
			</div>
			{isExpanded && hasChildren && (
				<div className='ml-[9px] border-l border-border/60 pl-1'>
					{item.children.map((child) => (
						<SidebarTreeItem key={child.id} item={child} onItemClick={onItemClick} />
					))}
				</div>
			)}
		</div>
	);
};

--- END OF features\wiki\components\navigation\sidebar\SidebarTreeItem.jsx ---

--- FILE: features\wiki\components\navigation\sidebar\StatusIcon.jsx ---
import { getStatusIcon } from '@/domain/entity/utils/statusUtils';

/**
 * StatusIcon Component
 * Displays status/affinity icon for entities in sidebar
 *
 * @param {Object} entity - Entity with status/affinity
 */
export const StatusIcon = ({ entity }) => {
	// Prioritize affinity over status for NPCs/Factions
	const statusValue = entity.affinity && entity.affinity !== 'unknown' ? entity.affinity : entity.status;

	const { Icon, className } = getStatusIcon(statusValue, entity.type);

	return <Icon size={12} className={className} strokeWidth={2.5} />;
};

--- END OF features\wiki\components\navigation\sidebar\StatusIcon.jsx ---

--- FILE: features\wiki\config\groupingConfig.js ---
export const GROUPING_CONFIG = {
	location: {
		mode: 'tree',
		sortItems: (a, b) => a.name.localeCompare(b.name),
	},
	encounter: {
		mode: 'tree',
		sortItems: (a, b) => {
			// 1. Folders (Locations) first
			if (a.type !== b.type) {
				if (a.type === 'location') return -1;
				if (b.type === 'location') return 1;
			}
			// 2. Then Sort Encounters Alphabetically
			return a.name.localeCompare(b.name);
		},
	},
	npc: {
		mode: 'tree', // Changed from groupBy to tree
		sortItems: (a, b) => {
			// Locations (folders) should generally come first or sort A-Z
			if (a.type !== b.type) {
				// Locations first
				if (a.type === 'location') return -1;
				if (b.type === 'location') return 1;
			}

			// For NPCs: Rank by Affinity, then Name
			if (a.type === 'npc' && b.type === 'npc') {
				const rankDiff = a.meta.affinityRank - b.meta.affinityRank;
				if (rankDiff !== 0) return rankDiff;
			}

			return a.name.localeCompare(b.name);
		},
	},
	faction: {
		groupBy: (item) => {
			const rank = item.meta.affinityRank;
			if (rank === 1) return 'Allies';
			if (rank === 2) return 'Neutral';
			if (rank === 3) return 'Enemies';
			return 'Unknown';
		},
		sortGroups: ['Allies', 'Neutral', 'Enemies', 'Unknown'],
		sortItems: (a, b) => a.name.localeCompare(b.name),
	},
	quest: {
		groupBy: (item) => {
			const t = item.meta.questType.toLowerCase();
			if (t.includes('main')) return 'Main Quest';
			if (t.includes('personal')) return 'Personal Quest';
			return 'Side Quest';
		},
		sortGroups: ['Main Quest', 'Personal Quest', 'Side Quest'],
		sortItems: (a, b) => {
			const statusOrder = ['active', 'in progress', 'pending', 'completed', 'success', 'failed', 'abandoned'];
			const idxA = statusOrder.indexOf(a.meta.status);
			const idxB = statusOrder.indexOf(b.meta.status);
			const valA = idxA === -1 ? 99 : idxA;
			const valB = idxB === -1 ? 99 : idxB;
			if (valA !== valB) return valA - valB;
			return a.name.localeCompare(b.name);
		},
	},
};

--- END OF features\wiki\config\groupingConfig.js ---

--- FILE: features\wiki\config\viewStrategies.js ---
import { MapPin, Flag, Circle, Swords, Users, Archive, LayoutGrid, Folder } from 'lucide-react';

export const VIEW_STRATEGIES = {
	location: { mode: 'geo' },
	encounter: { mode: 'geo' },
	npc: { mode: 'geo' },
	faction: { mode: 'category' },
	quest: { mode: 'category' },
	character: { mode: 'flat' },
	item: { mode: 'flat' },
	session: { mode: 'flat' },
};

// Recursive Flattening with Deduplication
const flattenGeoTree = (nodes, targetType, parentName = 'Uncharted', visitedIds) => {
	let lanes = [];
	const directItems = [];

	nodes.forEach((node) => {
		// 1. Handle "Children" (Traverse deeper first)
		if (node.children && node.children.length > 0) {
			const childLanes = flattenGeoTree(node.children, targetType, node.name, visitedIds);

			// Check for direct items inside this folder
			const myContent = childLanes.find((l) => l.title === null);

			if (myContent && myContent.items.length > 0) {
				lanes.push({
					id: node.id,
					title: node.name,
					parentTitle: parentName,
					link: `/wiki/${node.type}/${node.id}`,
					items: myContent.items,
				});
			}
			lanes = [...lanes, ...childLanes.filter((l) => l.title !== null)];
		}

		// 2. Handle "Self" (Is this node a target item?)
		if (node.type === targetType) {
			if (!visitedIds.has(node.id)) {
				visitedIds.add(node.id);
				directItems.push(node);
			}
		}
	});

	if (directItems.length > 0) {
		lanes.push({ id: `misc-${parentName}`, title: null, parentTitle: parentName, link: null, items: directItems });
	}
	return lanes;
};

export const getSwimlanes = (groups, normalizedType) => {
	if (groups.length === 0) return [];

	const strategy = VIEW_STRATEGIES[normalizedType] || VIEW_STRATEGIES.location;

	// STRATEGY 1: GEOGRAPHICAL (Tree Unrolling)
	if (strategy.mode === 'geo' && groups[0].isTree) {
		const rootItems = groups[0].items;
		const visitedIds = new Set();

		const rawLanes = flattenGeoTree(rootItems, normalizedType, null, visitedIds);

		const rootLane = rawLanes.find((l) => l.title === null);
		const otherLanes = rawLanes.filter((l) => l.title !== null);

		if (rootLane) {
			otherLanes.push({ ...rootLane, title: 'Uncharted / General', id: 'root-ungrouped' });
		}
		return otherLanes;
	}

	// STRATEGY 2: CATEGORICAL (Flat Groups)
	if (strategy.mode === 'category') {
		return groups.map((g) => ({
			id: g.id,
			title: g.title || 'Other',
			link: null,
			items: g.items,
		}));
	}

	// STRATEGY 3: FLAT (One big group)
	if (strategy.mode === 'flat') {
		const allItems = groups.flatMap((g) => g.items).sort((a, b) => a.name.localeCompare(b.name));
		return [
			{
				id: 'all',
				title: 'All Entries',
				link: null,
				items: allItems,
			},
		];
	}

	return [];
};

export const getStrategyMode = (type) => {
	return VIEW_STRATEGIES[type]?.mode || 'flat';
};

--- END OF features\wiki\config\viewStrategies.js ---

--- FILE: features\wiki\hooks\useEntityContent.js ---
import { useMemo } from 'react';
import { isSession } from '@/domain/entity/utils/entityUtils';
import { transformEvents } from '@/features/wiki/utils/eventMapper';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';
import { resolveImageUrl } from '@/shared/utils/imageUtils';

/**
 * Helper: Extract and group mentioned entities from events and direct relationships
 */
const extractMentions = (entity) => {
	const mentionsMap = new Map();

	// 1. Gather from direct relationships
	if (entity.relationships) {
		entity.relationships.forEach((rel) => {
			if (!rel.entity_id) return;
			mentionsMap.set(rel.entity_id, {
				id: rel.entity_id,
				name: rel.entity_name,
				type: rel.entity_type,
			});
		});
	}

	// 2. Gather from Events (tags)
	if (entity.events) {
		entity.events.forEach((evt) => {
			if (evt.relationships) {
				evt.relationships.forEach((rel) => {
					if (!rel.entity_id) return;
					mentionsMap.set(rel.entity_id, {
						id: rel.entity_id,
						name: rel.entity_name,
						type: rel.entity_type,
					});
				});
			}
		});
	}

	// 3. Group by Type
	const groups = {
		character: [],
		npc: [],
		location: [],
		faction: [],
		quest: [],
		encounter: [],
		other: [],
	};

	mentionsMap.forEach((item) => {
		const type = item.type?.toLowerCase() || 'other';
		if (groups[type]) {
			groups[type].push(item);
		} else {
			groups.other.push(item);
		}
	});

	// 4. Sort each group alphabetically
	Object.keys(groups).forEach((key) => {
		groups[key].sort((a, b) => a.name.localeCompare(b.name));
	});

	// 5. Remove empty groups
	Object.keys(groups).forEach((key) => {
		if (groups[key].length === 0) delete groups[key];
	});

	return groups;
};

export const useEntityContent = (entity, attributes, sections) => {
	return useMemo(() => {
		if (!entity) return null;

		const entityIsSession = isSession(entity);
		const entityIsQuest = entity.type === 'quest';
		const entityIsEncounter = entity.type === 'encounter';

		// Determine main summary
		let mainSummary = attributes.Summary || entity.summary;
		if (!mainSummary && !entityIsSession) {
			mainSummary = entity.description;
		}

		// --- NEW: TACTICAL MAP RESOLUTION ---
		// We look for common map keys and use resolveImageUrl to handle path cleaning/BaseURL
		const mapImageUrl = resolveImageUrl(attributes, 'any');
		// Note: resolveImageUrl(attributes, 'any') checks background_image, image, icon etc.
		// To be specific to your "crazy idea", let's do a manual check for map-specific keys first:
		const specificMapPath = getAttributeValue(attributes, ['map_image', 'tactical_map', 'map']);
		const finalMapUrl = specificMapPath ? `${import.meta.env.BASE_URL}${specificMapPath.replace(/^\//, '')}` : null;

		// 2. NEW: Resolve Tactical Map Markers
		const rawMarkers = getAttributeValue(attributes, 'map_markers');
		let parsedMarkers = [];
		if (rawMarkers) {
			try {
				// Parse the JSON string stored in the attribute
				parsedMarkers = typeof rawMarkers === 'string' ? JSON.parse(rawMarkers) : rawMarkers;
			} catch (e) {
				console.warn('Failed to parse map_markers JSON', e);
			}
		}

		// Process events
		const events = transformEvents(entity.events);

		// Process Mentions (for Sessions)
		const mentions = entityIsSession ? extractMentions(entity) : null;

		// NEW: Extract Level Up
		const levelUp = getAttributeValue(attributes, ['level_up', 'Level Up', 'levelup']);

		return {
			objectives: entityIsQuest ? entity.objectives || [] : null,
			combatRounds: entityIsEncounter ? entity.combatRounds : null,
			narrative: entityIsSession ? entity.description || '' : null,
			summary: mainSummary || '',
			sections: sections || [],
			history: events,
			mentions,
			levelUp,
			mapImageUrl: finalMapUrl,
			mapMarkers: parsedMarkers,
		};
	}, [entity, attributes, sections]);
};

--- END OF features\wiki\hooks\useEntityContent.js ---

--- FILE: features\wiki\hooks\useEntityFetching.js ---
import { useQuery } from '@tanstack/react-query';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { getEntities } from '@/domain/entity/api/entityService';

/**
 * Fetches entity data for a given type
 * Handles query invalidation and error states
 */
export function useEntityFetching(type) {
	const { campaignId } = useCampaign();
	const normalizedType = type === 'sessions' ? 'session' : type;

	const {
		data: entities,
		isLoading,
		error,
	} = useQuery({
		queryKey: ['entities', campaignId, normalizedType],
		queryFn: async () => {
			// Special Case: For NPCs and Encounters, we need Locations too
			// to build the tree (Region -> City -> Entity)
			if (normalizedType === 'npc' || normalizedType === 'encounter') {
				const [mainEntities, locations] = await Promise.all([
					getEntities(campaignId, normalizedType),
					getEntities(campaignId, 'location'),
				]);
				// Merge them (ensure uniqueness just in case, though types differ)
				return [...mainEntities, ...locations];
			}
			return getEntities(campaignId, normalizedType);
		},
		enabled: !!campaignId && !!normalizedType,
		staleTime: 1000 * 60 * 5, // 5 minutes
	});

	return {
		entities: entities || [],
		isLoading,
		error,
	};
}

--- END OF features\wiki\hooks\useEntityFetching.js ---

--- FILE: features\wiki\hooks\useEntityGrouping.js ---
import { useMemo } from 'react';
import { GROUPING_CONFIG } from '@/features/wiki/config/groupingConfig';
import { transformEntityToViewModel } from '@/features/wiki/utils/wikiUtils';

// --- TREE BUILDER HELPER ---
const buildTree = (items, sortFn) => {
	const idMap = new Map();
	const roots = [];

	// 1. Initialize map
	items.forEach((item) => {
		idMap.set(item.id, { ...item, children: [] });
	});

	// 2. Build Hierarchy
	items.forEach((item) => {
		const node = idMap.get(item.id);
		const parentId = item.meta.parentId;

		if (parentId && idMap.has(parentId)) {
			const parent = idMap.get(parentId);
			parent.children.push(node);
		} else {
			roots.push(node);
		}
	});

	// 3. Prune Empty Folders (Recursive)
	const prune = (nodes) => {
		// Generalize: If the list contains ANYTHING that isn't a location (e.g. NPC, Encounter),
		// then we assume 'locations' are acting as folders and should be pruned if empty.
		// If the list is ONLY locations, we are in the Location Wiki, so we keep everything.
		const hasMixedTypes = items.some((i) => i.type !== 'location');

		if (!hasMixedTypes) return nodes; // Don't prune if we are just listing locations

		return nodes.filter((node) => {
			if (node.children.length > 0) {
				node.children = prune(node.children);
			}

			// If it's a location (folder) and has no children after pruning, remove it
			if (node.type === 'location' && node.children.length === 0) {
				return false;
			}
			return true;
		});
	};

	let finalRoots = prune(roots);

	// 4. Recursive Sort
	const sortRecursive = (nodes) => {
		if (sortFn) nodes.sort(sortFn);
		nodes.forEach((node) => {
			if (node.children.length > 0) {
				sortRecursive(node.children);
			}
		});
	};

	sortRecursive(finalRoots);
	return finalRoots;
};

// ... (rest of the file remains unchanged) ...
export function useEntityGrouping(entities, type, searchQuery = '') {
	// ... existing implementation ...
	return useMemo(() => {
		if (!entities || entities.length === 0) return [];

		// 1. Filter by search
		const filtered = searchQuery
			? entities.filter((e) => e.name.toLowerCase().includes(searchQuery.toLowerCase()))
			: entities;

		// 2. Transform to view model
		const items = filtered.map((entity) => transformEntityToViewModel(entity, type));

		const strategy = GROUPING_CONFIG[type];

		// --- STRATEGY 1: TREE (Nested) ---
		if (strategy?.mode === 'tree') {
			const treeRoots = buildTree(items, strategy.sortItems);
			return [
				{
					id: 'root',
					title: null,
					items: treeRoots,
					isTree: true,
				},
			];
		}

		// --- STRATEGY 2: GROUPED (Flat Categories) ---
		if (strategy && strategy.groupBy) {
			const grouped = {};
			items.forEach((item) => {
				const groupKey = strategy.groupBy(item) || 'Other';
				if (!grouped[groupKey]) grouped[groupKey] = [];
				grouped[groupKey].push(item);
			});

			let groupKeys = Object.keys(grouped);

			if (typeof strategy.sortGroups === 'function') {
				groupKeys.sort(strategy.sortGroups);
			} else if (Array.isArray(strategy.sortGroups)) {
				groupKeys.sort((a, b) => {
					const idxA = strategy.sortGroups.indexOf(a);
					const idxB = strategy.sortGroups.indexOf(b);
					const valA = idxA === -1 ? 999 : idxA;
					const valB = idxB === -1 ? 999 : idxB;
					return valA - valB || a.localeCompare(b);
				});
			} else if (strategy.sortGroups === 'alpha') {
				groupKeys.sort();
			}

			return groupKeys.map((key) => {
				const groupItems = grouped[key];
				if (typeof strategy.sortItems === 'function') {
					groupItems.sort(strategy.sortItems);
				} else {
					groupItems.sort((a, b) => a.name.localeCompare(b.name));
				}
				return {
					id: key,
					title: key,
					items: groupItems,
				};
			});
		}

		// --- STRATEGY 3: DEFAULT (Flat A-Z) ---
		return [
			{
				id: 'all',
				title: null,
				items: items.sort((a, b) => a.name.localeCompare(b.name)),
			},
		];
	}, [entities, type, searchQuery]);
}

--- END OF features\wiki\hooks\useEntityGrouping.js ---

--- FILE: features\wiki\hooks\useEntityHeader.js ---
/**
 * useEntityHeader Hook
 * Builds header view model from entity data
 */

import { useMemo } from 'react';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import { resolveImageUrl } from '@/shared/utils/imageUtils';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';
import { extractHeaderTags } from '@/features/wiki/utils/attributeMapper';
import { capitalize } from '@/shared/utils/textUtils';

/**
 * Build header view model
 * @param {Object} entity - Raw entity data
 * @param {Object} attributes - Parsed attributes
 * @returns {Object} Header view model
 */
export const useEntityHeader = (entity, attributes) => {
	return useMemo(() => {
		if (!entity) return null;

		const config = getEntityConfig(entity.type);

		// Resolve images
		const headerBackgroundUrl = resolveImageUrl(attributes, 'background');
		const avatarUrl = resolveImageUrl(attributes, 'icon');

		// Resolve status
		let statusRaw = entity.status || getAttributeValue(attributes, ['status']);
		if (Array.isArray(statusRaw)) {
			statusRaw = statusRaw.join(', ');
		}
		if (statusRaw && typeof statusRaw !== 'string') {
			statusRaw = String(statusRaw);
		}

		// Resolve Priority (New)
		const priorityRaw = getAttributeValue(attributes, ['priority', 'Priority']);

		// Extract extra tags (session-specific)
		const extraTags = extractHeaderTags(attributes, entity.type);

		return {
			title: entity.name,
			typeLabel: entity.type?.toUpperCase(),
			imageUrl: headerBackgroundUrl,
			avatarUrl: avatarUrl,
			status: {
				hasStatus: !!statusRaw,
				label: statusRaw ? capitalize(statusRaw) : '',
				isDead: statusRaw?.toLowerCase() === 'dead' || statusRaw?.toLowerCase() === 'failed',
			},
			priority: priorityRaw ? capitalize(priorityRaw) : null,
			extraTags,
			theme: {
				...config.tailwind,
				Icon: config.icon,
			},
		};
	}, [entity, attributes]);
};

--- END OF features\wiki\hooks\useEntityHeader.js ---

--- FILE: features\wiki\hooks\useEntitySidebar.js ---
/**
 * useEntitySidebar Hook
 * Builds sidebar view model from entity data
 */

import { useMemo } from 'react';
import { transformRelationships } from '@/features/wiki/utils/relationshipMapper';

/**
 * Build sidebar view model
 * @param {Object} entity - Raw entity data
 * @param {Array} traits - Traits from attribute transform
 * @returns {Object} Sidebar view model
 */
export const useEntitySidebar = (entity, traits) => {
	return useMemo(() => {
		if (!entity) return null;

		const connections = transformRelationships(entity.relationships, 50);

		return {
			traits: traits || [],
			connections,
		};
	}, [entity, traits]);
};

--- END OF features\wiki\hooks\useEntitySidebar.js ---

--- FILE: features\wiki\layouts\SessionLayout.jsx ---
import { useMemo } from 'react';
import { useSearchParams } from 'react-router-dom'; // CHANGED: Replaces useState
import { BookOpen, History, Network } from 'lucide-react';
import TabContainer from '@/shared/components/layout/TabContainer';
import { EntityBody, EntityHistory } from '@/features/wiki/components/EntityBody';
import { SessionMentions } from '@/features/wiki/components/SessionMentions';
import { TableOfContents } from '@/features/table-of-contents/TableOfContents';
import { extractHeaders } from '@/shared/utils/markdownUtils';
import { ThreeColumnLayout } from '@/shared/components/layout/SplitView';

export default function SessionLayout({ viewModel }) {
	// CHANGED: Use URL params for state
	const [searchParams, setSearchParams] = useSearchParams();
	const activeTab = searchParams.get('tab') || 'narrative';

	const setActiveTab = (tabId) => {
		setSearchParams(
			(prev) => {
				prev.set('tab', tabId);
				return prev;
			},
			{ replace: true }
		); // replace prevents cluttering history stack
	};

	if (!viewModel) return null;

	const tocItems = useMemo(() => {
		if (viewModel.content.narrative) {
			return extractHeaders(viewModel.content.narrative);
		}
		return [];
	}, [viewModel.content.narrative]);

	const renderNarrative = () => (
		<ThreeColumnLayout
			left={null}
			center={
				<div className='max-w-3xl mx-auto px-4 sm:px-6 py-10'>
					<EntityBody
						summary={viewModel.content.narrative}
						sections={[]}
						history={null}
						levelUp={viewModel.content.levelUp}
					/>
				</div>
			}
			right={
				tocItems.length > 0 ? (
					<TableOfContents
						items={tocItems}
						className='ml-4'
						visibilityClass='hidden min-[1650px]:block'
						mobileToggleClass='min-[1650px]:hidden'
					/>
				) : null
			}
		/>
	);

	const renderMentions = () => (
		<div className='max-w-7xl mx-auto px-4 sm:px-6 py-10'>
			<SessionMentions mentions={viewModel.content.mentions} />
		</div>
	);

	const renderTimeline = () => (
		<div className='max-w-3xl mx-auto px-4 sm:px-6 py-10'>
			<EntityHistory events={viewModel.content.history} fullHeight={true} />
		</div>
	);

	return (
		<>
			<TabContainer
				tabs={[
					{
						id: 'narrative',
						label: 'Narrative',
						icon: BookOpen,
						content: renderNarrative(),
					},
					{
						id: 'mentions',
						label: 'Mentions',
						icon: Network,
						content: renderMentions(),
					},
					{
						id: 'events',
						label: 'Timeline',
						icon: History,
						content: renderTimeline(),
					},
				]}
				defaultTab={activeTab} // CHANGED
				sticky
				onChange={setActiveTab} // CHANGED
			/>

			{tocItems.length > 0 && activeTab === 'narrative' && (
				<div className='xl:hidden'>
					<TableOfContents items={tocItems} />
				</div>
			)}
		</>
	);
}

--- END OF features\wiki\layouts\SessionLayout.jsx ---

--- FILE: features\wiki\layouts\StandardLayout.jsx ---
import { Drawer } from 'vaul';
import { Info, X } from 'lucide-react';
import { EntitySidebar } from '@/features/wiki/components/EntitySidebar';
import { EntityBody } from '@/features/wiki/components/EntityBody';

export default function StandardLayout({ viewModel }) {
	if (!viewModel) return null;

	return (
		<div className='w-full px-4 sm:px-6 py-10'>
			<div className='max-w-6xl mx-auto'>
				<div className='grid grid-cols-1 lg:grid-cols-[260px_1fr] xl:grid-cols-[280px_1fr] gap-4 lg:gap-6 xl:gap-8'>
					{/* --- DESKTOP SIDEBAR (Hidden on Mobile) --- */}
					<div className='hidden lg:block lg:order-first min-w-0'>
						<EntitySidebar traits={viewModel.sidebar.traits} connections={viewModel.sidebar.connections} />
					</div>

					{/* --- MAIN CONTENT --- */}
					<div className='min-w-0 pb-20'>
						<EntityBody
							summary={viewModel.content.summary}
							sections={viewModel.content.sections}
							history={viewModel.content.history}
							objectives={viewModel.content.objectives}
							combatRounds={viewModel.content.combatRounds}
							mapImageUrl={viewModel.content.mapImageUrl}
							mapMarkers={viewModel.content.mapMarkers}
						/>
					</div>
				</div>
			</div>

			{/* --- MOBILE BOTTOM SHEET --- */}
			<div className='lg:hidden'>
				<Drawer.Root shouldScaleBackground>
					<Drawer.Trigger asChild>
						<button className='fixed bottom-6 right-6 z-50 flex items-center gap-2 px-4 py-3 bg-background text-foreground border border-border rounded-full shadow-2xl font-bold text-xs uppercase tracking-wider active:scale-95 transition-transform'>
							<Info size={18} />
							<span>Info</span>
						</button>
					</Drawer.Trigger>

					<Drawer.Portal>
						<Drawer.Overlay className='fixed inset-0 bg-black/40 z-50 backdrop-blur-[2px]' />
						<Drawer.Content className='bg-background flex flex-col rounded-t-[10px] h-[85vh] mt-24 fixed bottom-0 left-0 right-0 z-50 focus:outline-none border-t border-border'>
							{/* Drag Handle */}
							<div className='p-4 bg-muted/50 rounded-t-[10px] flex-shrink-0'>
								<div className='mx-auto w-12 h-1.5 flex-shrink-0 rounded-full bg-gray-300 mb-4' />
								<div className='flex justify-between items-center'>
									{/* CHANGED: Used Drawer.Title instead of h2 for accessibility */}
									<Drawer.Title className='font-serif font-bold text-xl'>Details & Stats</Drawer.Title>
									<Drawer.Close className='p-2 bg-muted rounded-full text-muted-foreground'>
										<X size={16} />
									</Drawer.Close>
								</div>
							</div>

							{/* Content */}
							<div className='p-4 bg-background flex-1 overflow-y-auto custom-scrollbar'>
								<EntitySidebar traits={viewModel.sidebar.traits} connections={viewModel.sidebar.connections} />
							</div>
						</Drawer.Content>
					</Drawer.Portal>
				</Drawer.Root>
			</div>
		</div>
	);
}

--- END OF features\wiki\layouts\StandardLayout.jsx ---

--- FILE: features\wiki\pages\WikiDetailPage.jsx ---
import { useParams } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { getWikiEntry } from '@/features/wiki/api/wikiService';
import { transformWikiEntry } from '@/features/wiki/utils/wikiEntryMapper'; // Import transform
import WikiEntityView from '@/features/wiki/components/WikiEntryView';
import LoadingSpinner from '@/shared/components/ui/LoadingSpinner';

export default function WikiEntryPage() {
	const { type, entityId } = useParams();
	const normalizedType = type === 'sessions' ? 'session' : type;

	const {
		data: entity,
		isLoading,
		error,
	} = useQuery({
		queryKey: ['entry', normalizedType, entityId],
		queryFn: () => getWikiEntry(entityId, normalizedType),
		select: (res) => transformWikiEntry(res.data, res.type, res.additional),
		enabled: !!entityId && !!normalizedType,
		retry: 1,
	});

	if (isLoading) return <LoadingSpinner className='h-full min-h-[50vh]' text='Loading Entry...' />;
	if (error)
		return (
			<div className='p-8 text-center text-red-600'>
				<p>Failed to load entry</p>
			</div>
		);

	return <WikiEntityView entity={entity} />;
}

--- END OF features\wiki\pages\WikiDetailPage.jsx ---

--- FILE: features\wiki\pages\WikiLandingPage.jsx ---
import { useParams } from 'react-router-dom';
import { Search, Folder, LayoutGrid, List } from 'lucide-react';
import { useState, useMemo } from 'react';
import { useEntityFetching } from '@/features/wiki/hooks/useEntityFetching';
import { useEntityGrouping } from '@/features/wiki/hooks/useEntityGrouping';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import { getSwimlanes, getStrategyMode } from '@/features/wiki/config/viewStrategies';
import { Swimlane } from '../components/landing/Swimlane';
import { EntityTableGroup } from '../components/landing/EntityTableGroup';
import LoadingSpinner from '@/shared/components/ui/LoadingSpinner';
import { clsx } from 'clsx';

export default function WikiLandingPage() {
	const { type } = useParams();
	const normalizedType = type === 'sessions' ? 'session' : type;

	const { entities, isLoading } = useEntityFetching(normalizedType);
	const [viewMode, setViewMode] = useState('grid');
	const [search, setSearch] = useState('');

	const config = getEntityConfig(normalizedType);
	const mode = getStrategyMode(normalizedType);
	const groups = useEntityGrouping(entities, normalizedType, search);
	const swimlanes = useMemo(() => getSwimlanes(groups, normalizedType), [groups, normalizedType]);

	if (isLoading) return <LoadingSpinner text={`Loading ${config.labelPlural}...`} />;

	const totalCount = swimlanes.reduce((acc, lane) => acc + lane.items.length, 0);

	return (
		// OPTIMIZATION: Removed fixed p-12, used responsive padding
		<div className='p-4 md:p-8 lg:p-12 max-w-[1920px] mx-auto min-h-full pb-safe'>
			{/* Header */}
			<div className='flex flex-col gap-6 mb-6 border-b border-border pb-6'>
				{/* Top Row: Title */}
				<div className='flex items-center gap-4'>
					<div
						className={clsx(
							'p-3 rounded-xl border shadow-sm bg-background hidden md:block',
							config.tailwind.border,
							config.tailwind.text
						)}>
						<config.icon size={32} strokeWidth={1.5} />
					</div>
					<div>
						<h1 className='text-2xl md:text-3xl font-serif font-bold text-foreground capitalize leading-none mb-1'>
							{config.labelPlural}
						</h1>
						<p className='text-xs md:text-sm text-muted-foreground font-medium'>{totalCount} entries found</p>
					</div>
				</div>

				{/* Controls Area - Stacks on mobile, Row on desktop */}
				<div className='flex flex-col sm:flex-row gap-3 w-full'>
					{/* Search Bar - Full width on mobile */}
					<div className='relative flex-1 order-2 sm:order-1'>
						<Search size={16} className='absolute left-3 top-3 text-muted-foreground' />
						<input
							type='text'
							placeholder={`Search ${config.labelPlural}...`}
							value={search}
							onChange={(e) => setSearch(e.target.value)}
							// text-base on mobile prevents zoom
							className='w-full pl-10 pr-4 py-2.5 bg-background border border-border rounded-lg text-base sm:text-sm focus:ring-2 focus:ring-accent/20 focus:border-accent outline-none shadow-sm transition-all'
						/>
					</div>

					{/* View Toggle - Beside search on desktop, Top on mobile */}
					<div className='flex bg-muted p-1 rounded-lg border border-border/50 shrink-0 self-start order-1 sm:order-2'>
						<button
							onClick={() => setViewMode('grid')}
							className={clsx(
								'p-2 sm:p-1.5 rounded-md transition-all flex-1 sm:flex-none flex justify-center',
								viewMode === 'grid'
									? 'bg-background text-foreground shadow-sm ring-1 ring-black/5'
									: 'text-muted-foreground hover:text-foreground'
							)}
							title='Grid View'>
							<LayoutGrid size={18} />
						</button>
						<button
							onClick={() => setViewMode('table')}
							className={clsx(
								'p-2 sm:p-1.5 rounded-md transition-all flex-1 sm:flex-none flex justify-center',
								viewMode === 'table'
									? 'bg-background text-foreground shadow-sm ring-1 ring-black/5'
									: 'text-muted-foreground hover:text-foreground'
							)}
							title='Table View'>
							<List size={18} />
						</button>
					</div>
				</div>
			</div>

			{/* CONTENT */}
			<div className='pb-20'>
				{viewMode === 'grid' ? (
					swimlanes.map((lane) => (
						<Swimlane
							key={lane.id}
							title={lane.title}
							parentTitle={lane.parentTitle}
							link={lane.link}
							items={lane.items}
							config={config}
							context={mode}
						/>
					))
				) : (
					<div className='max-w-5xl mx-auto'>
						{swimlanes.map((lane) => (
							<EntityTableGroup
								key={lane.id}
								title={lane.title}
								parentTitle={lane.parentTitle}
								link={lane.link}
								items={lane.items}
							/>
						))}
					</div>
				)}

				{totalCount === 0 && (
					<div className='text-center py-20 opacity-40 flex flex-col items-center gap-4 border-2 border-dashed border-border rounded-xl mt-4'>
						<Folder size={48} strokeWidth={1} />
						<p className='text-lg font-serif text-muted-foreground'>No entries found.</p>
					</div>
				)}
			</div>
		</div>
	);
}

--- END OF features\wiki\pages\WikiLandingPage.jsx ---

--- FILE: features\wiki\utils\attributeMapper.js ---
/**
 * Attribute Transform Functions
 * Pure functions for processing entity attributes into view model format
 */

import {
	parseAttributeValue,
	parseAbilityScores,
	parseTagList,
	isIgnoredAttribute,
	isNarrativeAttribute,
	isListAttribute,
} from '@/domain/entity/utils/attributeParser';

/**
 * Determine if an attribute should go to sidebar or main content
 * @param {string} key - Attribute key
 * @param {*} value - Attribute value
 * @returns {'sidebar'|'main'|'ignore'}
 */
const getAttributeDestination = (key, value) => {
	const normalizedKey = key.toLowerCase();

	if (isIgnoredAttribute(normalizedKey)) {
		return 'ignore';
	}

	// Special widgets always go to sidebar
	if (
		['abilities', 'stats', 'ability score', 'saving throw', 'saves', 'skills', 'languages', 'proficiencies'].includes(
			normalizedKey
		)
	) {
		return 'sidebar';
	}

	// Lists always go to main content
	if (isListAttribute(normalizedKey) && Array.isArray(value)) {
		return 'main';
	}

	// Narrative text goes to main
	if (isNarrativeAttribute(normalizedKey)) {
		return 'main';
	}

	// Long text goes to main
	if (typeof value === 'string' && value.length > 100) {
		return 'main';
	}

	// Everything else to sidebar
	return 'sidebar';
};

/**
 * Process special widget attributes (ability scores, tags)
 * @param {string} key - Attribute key
 * @param {*} value - Raw attribute value
 * @returns {Object|null} Processed trait or null
 */
const processSpecialWidget = (key, value) => {
	const normalizedKey = key.toLowerCase();

	// Ability scores / stats
	if (['abilities', 'stats'].includes(normalizedKey)) {
		const strVal = parseAttributeValue(value);
		return {
			key,
			value: parseAbilityScores(strVal),
			displayType: 'stat-grid',
		};
	}

	// Tag lists
	if (['ability score', 'saving throw', 'saves', 'skills', 'languages', 'proficiencies'].includes(normalizedKey)) {
		const strVal = parseAttributeValue(value);
		return {
			key,
			value: parseTagList(strVal),
			displayType: 'tags',
		};
	}

	return null;
};

/**
 * Transform attributes into sidebar traits and main content sections
 * @param {Object} attributes - Parsed attributes object
 * @param {string} entityDescription - Entity description (to avoid duplication)
 * @returns {{traits: Array, sections: Array}}
 */
export const transformAttributes = (attributes, entityDescription = '') => {
	const traits = [];
	const sections = [];

	Object.entries(attributes).forEach(([key, rawVal]) => {
		// 1. Check for special widgets first
		const widget = processSpecialWidget(key, rawVal);
		if (widget) {
			traits.push(widget);
			return;
		}

		// 2. Parse value
		const displayVal = parseAttributeValue(rawVal, key);
		if (!displayVal) return;

		// 3. Skip if it's the same as description
		const normalizedKey = key.toLowerCase();
		if (normalizedKey === 'description' && displayVal === entityDescription) {
			return;
		}

		// 4. Determine destination
		const destination = getAttributeDestination(key, displayVal);
		if (destination === 'ignore') return;

		// 5. Route to appropriate collection
		if (destination === 'main') {
			// Lists stay as arrays
			if (isListAttribute(normalizedKey) && Array.isArray(displayVal)) {
				sections.push({
					key,
					value: displayVal,
					displayType: 'list',
				});
			} else {
				// Join arrays into text for narrative
				const textValue = Array.isArray(displayVal) ? displayVal.join('\n\n') : displayVal;
				sections.push({
					key,
					value: textValue,
					displayType: 'narrative',
				});
			}
		} else {
			// Sidebar trait
			const textValue = Array.isArray(displayVal) ? displayVal.join(', ') : displayVal;
			traits.push({
				key,
				value: textValue,
				displayType: 'text',
			});
		}
	});

	return { traits, sections };
};

/**
 * Extract extra tags for entity header (session-specific)
 * @param {Object} attributes - Parsed attributes
 * @param {string} entityType - Entity type
 * @returns {string[]}
 */
export const extractHeaderTags = (attributes, entityType) => {
	const tags = [];

	if (entityType === 'session') {
		if (attributes.Session) {
			tags.push(`Session ${attributes.Session}`);
		}
		if (attributes.Date) {
			tags.push(attributes.Date);
		}
	}

	return tags;
};

--- END OF features\wiki\utils\attributeMapper.js ---

--- FILE: features\wiki\utils\eventMapper.js ---
/**
 * Event Transform Functions
 * Pure functions for processing entity events/history into view model format
 */

/**
 * Parse events from various formats
 * @param {Array|Object} events - Raw events data
 * @returns {Array}
 */
export const parseEvents = (events) => {
	if (!events) return [];

	// Already an array
	if (Array.isArray(events)) {
		return events;
	}

	// Object grouped by type (flatten it)
	if (typeof events === 'object') {
		return Object.values(events).flat();
	}

	return [];
};

/**
 * Transform events into history view model
 * Includes deduplication to prevent React key errors
 * @param {Array|Object} events - Raw events
 * @returns {Array}
 */
export const transformEvents = (events) => {
	const parsed = parseEvents(events);

	// 1. Deduplicate by ID using a Map
	const uniqueEventsMap = new Map();
	parsed.forEach((evt) => {
		if (evt && evt.id) {
			uniqueEventsMap.set(evt.id, evt);
		} else if (evt) {
			// Handle events without IDs (fallback)
			uniqueEventsMap.set(Math.random().toString(), evt);
		}
	});

	// 2. Transform values
	return Array.from(uniqueEventsMap.values()).map((event) => ({
		id: event.id || Math.random().toString(),
		title: event.title || 'Untitled Event',
		description: event.description || '',
		session_number: event.session_number,
		order: event.order || event.event_order || 0,
	}));
};

--- END OF features\wiki\utils\eventMapper.js ---

--- FILE: features\wiki\utils\relationshipMapper.js ---
/**
 * Relationship Transform Functions
 * Pure functions for processing entity relationships into view model format
 */

import { getEntityConfig } from '@/domain/entity/config/entityConfig';

/**
 * Parse relationships from various formats
 * @param {string|Array|Object} relationships - Raw relationships data
 * @returns {Array}
 */
export const parseRelationships = (relationships) => {
	if (!relationships) return [];

	// Already an array
	if (Array.isArray(relationships)) {
		return relationships;
	}

	// String (JSON)
	if (typeof relationships === 'string') {
		try {
			return JSON.parse(relationships);
		} catch {
			return [];
		}
	}

	// Object (convert to array)
	if (typeof relationships === 'object') {
		return Object.values(relationships);
	}

	return [];
};

/**
 * Transform relationships into connection view models
 * @param {Array} relationships - Parsed relationships
 * @param {number} maxConnections - Maximum connections to show (default 8)
 * @returns {Array}
 */
export const transformRelationships = (relationships, maxConnections = 8) => {
	const parsed = parseRelationships(relationships);

	return parsed
		.map((rel) => {
			const config = getEntityConfig(rel.entity_type);

			return {
				id: rel.entity_id || Math.random().toString(),
				name: rel.entity_name,
				typeLabel: rel.entity_type,
				role: formatRelationshipType(rel.type),
				theme: {
					...config.tailwind,
					Icon: config.icon,
				},
			};
		})
		.slice(0, maxConnections);
};

/**
 * Format relationship type for display
 * @param {string} type - Raw relationship type
 * @returns {string}
 */
const formatRelationshipType = (type) => {
	if (!type) return 'related';
	return type.toLowerCase().replace(/_/g, ' ');
};

--- END OF features\wiki\utils\relationshipMapper.js ---

--- FILE: features\wiki\utils\wikiEntryMapper.js ---
import { getAttributeValue, parseAttributes } from '@/domain/entity/utils/attributeParser'; // Imported here
import { resolveImageUrl } from '@/shared/utils/imageUtils';

const extractSessionMeta = (session, attributes = []) => {
	// REUSE: Use our upgraded utility instead of manual reduce
	const attrs = parseAttributes(attributes);

	const sessionNumber = getAttributeValue(attrs, ['session_number', 'Session', 'session']) || 999;
	const sessionDate = getAttributeValue(attrs, ['session_date', 'Date', 'date']) || '';

	return {
		...session,
		session_number: Number(sessionNumber),
		session_date: sessionDate,
		attributes: attrs,
	};
};

export const transformWikiEntry = (data, type, additionalData = {}) => {
	if (type === 'session') {
		const meta = extractSessionMeta(data, additionalData.attributes || []);
		const sortedEvents = (data.events || []).sort((a, b) => (a.event_order || 0) - (b.event_order || 0));

		const eventRelMap = additionalData.eventRelMap || new Map();
		sortedEvents.forEach((evt) => {
			evt.relationships = eventRelMap.get(evt.id) || [];
		});

		return {
			id: data.id,
			name: data.title,
			type: 'session',
			description: getAttributeValue(meta.attributes, 'Summary') || data.narrative,
			attributes: {
				...meta.attributes,
				Session: meta.session_number,
				Date: meta.session_date,
			},
			relationships: additionalData.sessionRelationships || [],
			events: sortedEvents || [],
		};
	}

	// Standard Entity Transformation
	let entity = { ...data };

	// Quest Objectives
	if (type === 'quest' && additionalData.objectives) {
		entity.objectives = additionalData.objectives.map((obj) => ({
			...obj,
			completed_session_number: obj.session?.session_number || null,
			completed_session_title: obj.session?.title || null,
		}));
	}

	// NEW: Encounter Actions Transformation
	if (type === 'encounter' && additionalData.encounterActions) {
		const actions = additionalData.encounterActions.map((action) => {
			// 1. Resolve Actor Icon
			const actorAttrs = parseAttributes(action.actor?.attributes);
			const actorIcon = resolveImageUrl(actorAttrs, 'icon');

			// 2. Resolve Target Icon (NEW)
			const targetAttrs = parseAttributes(action.target?.attributes);
			const targetIcon = resolveImageUrl(targetAttrs, 'icon');

			const targetName = action.target_name || action.target?.name;
			const targetId = action.target?.id;
			const targetType = action.target?.type || 'default';

			return {
				id: action.id,
				round: action.round_number,
				order: action.action_order,
				type: action.action_type,
				isFriendly: action.is_friendly,
				description: action.action_description,
				result: action.result,
				effect: action.effect,
				actor: {
					id: action.actor?.id,
					name: action.actor_name || action.actor?.name || 'Unknown',
					type: action.actor?.type || 'default',
					iconUrl: actorIcon, // Pass Resolved Icon
				},
				target: targetName
					? {
							id: targetId,
							name: targetName,
							type: targetType,
							iconUrl: targetIcon, // Pass Resolved Icon
					  }
					: null,
			};
		});

		// ... grouping logic
		const rounds = {};
		actions.forEach((action) => {
			if (!rounds[action.round]) rounds[action.round] = [];
			rounds[action.round].push(action);
		});

		entity.combatRounds = rounds;
	}

	// Event Processing
	let events = entity.events;
	if (events && typeof events === 'object' && !Array.isArray(events)) {
		events = Object.values(events).flat();
	}

	if (events && Array.isArray(events) && events.length > 0 && additionalData.sessionMap) {
		events = events.map((event) => ({
			...event,
			session_number:
				event.session_id && additionalData.sessionMap.has(event.session_id)
					? additionalData.sessionMap.get(event.session_id) - 1
					: null,
		}));

		events.sort((a, b) => {
			if (a.session_number !== b.session_number) {
				if (a.session_number == null) return 1;
				if (b.session_number == null) return -1;
				return a.session_number - b.session_number;
			}
			return (a.order || 0) - (b.order || 0);
		});
		entity.events = events;
	}

	return entity;
};

--- END OF features\wiki\utils\wikiEntryMapper.js ---

--- FILE: features\wiki\utils\wikiUtils.js ---
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';
import { getAffinityRank } from '@/domain/entity/utils/statusUtils';
import { getParentId } from '@/domain/entity/utils/entityUtils';

// ... (Rest of file remains unchanged) ...
export function transformEntityToViewModel(entity, type) {
	// ... existing implementation ...
	// (This function calls getParentId internally, so no changes needed inside it)
	// Context type (e.g. 'npc' or 'location')
	const contextType = type === 'sessions' ? 'session' : type;

	// Actual entity type (e.g. 'location' inside 'npc' view)
	const actualType = entity.type || contextType;

	// Extract raw values
	const statusRaw = getAttributeValue(entity.attributes, ['status', 'Quest Status']) || entity.status || 'unknown';
	const affinityRaw = getAttributeValue(entity.attributes, ['affinity', 'disposition']);

	const status = statusRaw.toLowerCase();
	const affinity = affinityRaw ? affinityRaw.toLowerCase() : 'unknown';

	// Determine effective sorting rank
	const effectiveSortString = affinity !== 'unknown' ? affinity : status;
	const affinityRank = getAffinityRank(effectiveSortString);

	// Extract Region & Quest Type
	const region = getAttributeValue(entity.attributes, ['region', 'parent location']) || 'Uncharted';
	const questType = getAttributeValue(entity.attributes, ['Quest Type', 'Type']) || 'Side Quest';

	// Extract Priority for Quests
	const priority = getAttributeValue(entity.attributes, ['Priority', 'priority']) || null;

	// Extract Parent ID using the smarter logic
	const parentId = getParentId(entity);

	return {
		id: entity.id,
		name: entity.name,
		path: entity.id,
		type: actualType,

		status,
		affinity,
		attributes: entity.attributes || {},
		relationships: entity.relationships,

		meta: {
			status,
			affinity,
			affinityRank,
			region,
			questType,
			priority,
			parentId,
		},
	};
}

--- END OF features\wiki\utils\wikiUtils.js ---

--- FILE: shared\api\supabaseClient.js ---
import { createClient } from '@supabase/supabase-js';

// 1. Load variables from .env
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

// 2. Safety Check (Helps debug if .env is missing)
if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
	console.error(
		'ðŸš¨ Supabase Critical Error: Missing environment variables.\n' +
			'Please check that your .env file exists and contains VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY.'
	);
}

// 3. Initialize and Export the Client
export const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

--- END OF shared\api\supabaseClient.js ---

--- FILE: shared\components\ErrorBoundary.jsx ---
import { Component } from 'react';
import { AlertTriangle, RefreshCw } from 'lucide-react';
import Button from './ui/Button';

class ErrorBoundary extends Component {
	constructor(props) {
		super(props);
		this.state = { hasError: false, error: null };
	}

	static getDerivedStateFromError(error) {
		return { hasError: true, error };
	}

	componentDidCatch(error, errorInfo) {
		console.error('Error caught by boundary:', error, errorInfo);
	}

	handleReset = () => {
		this.setState({ hasError: false, error: null });
		window.location.reload();
	};

	render() {
		if (this.state.hasError) {
			return (
				<div className='min-h-screen flex items-center justify-center bg-muted p-4'>
					<div className='max-w-md w-full text-center'>
						<div className='mb-6 inline-flex items-center justify-center w-16 h-16 rounded-full bg-red-100'>
							<AlertTriangle className='w-8 h-8 text-red-600' />
						</div>
						<h1 className='text-2xl font-serif font-bold text-foreground mb-3'>Something went wrong</h1>
						<p className='text-muted-foreground mb-6'>Don't worry, your data is safe. Try refreshing the page to continue.</p>
						{process.env.NODE_ENV === 'development' && this.state.error && (
							<details className='mb-6 text-left bg-red-500/10 border border-red-200 rounded-lg p-4'>
								<summary className='cursor-pointer font-semibold text-red-900 mb-2'>Error Details</summary>
								<pre className='text-xs text-red-800 overflow-auto'>{this.state.error.toString()}</pre>
							</details>
						)}
						<Button onClick={this.handleReset} icon={RefreshCw}>
							Reload Application
						</Button>
					</div>
				</div>
			);
		}

		return this.props.children;
	}
}

export default ErrorBoundary;

--- END OF shared\components\ErrorBoundary.jsx ---

--- FILE: shared\components\layout\CollapsibleSection.jsx ---
import { useState } from 'react';
import { ChevronDown, ChevronRight } from 'lucide-react';
import { clsx } from 'clsx';

/**
 * CollapsibleSection Component
 * Expandable/collapsible content section
 *
 * @param {string} title - Section title
 * @param {React.ReactNode} children - Section content
 * @param {boolean} defaultOpen - Initial state (default true)
 * @param {React.Component} icon - Optional icon component
 * @param {string} size - Title size: 'sm', 'md', 'lg' (default 'md')
 * @param {string} variant - Style variant: 'default', 'bordered', 'card' (default 'default')
 * @param {string} className - Additional classes
 */
export default function CollapsibleSection({
	title,
	children,
	defaultOpen = true,
	icon: Icon = null,
	size = 'md',
	variant = 'default',
	className = '',
	...props
}) {
	const [isOpen, setIsOpen] = useState(defaultOpen);

	const sizeClasses = {
		sm: 'text-xs',
		md: 'text-sm',
		lg: 'text-base',
	};

	const variantClasses = {
		default: '',
		bordered: 'border border-border rounded-lg p-3',
		card: 'bg-background border border-border rounded-lg shadow-sm',
	};

	const headerPadding = variant === 'card' ? 'p-3' : '';
	const contentPadding = variant === 'card' ? 'p-3 pt-0' : '';

	return (
		<div className={clsx(variantClasses[variant], className)} {...props}>
			{/* Header */}
			<button
				onClick={() => setIsOpen(!isOpen)}
				className={clsx(
					'w-full flex items-center gap-2 font-semibold uppercase tracking-wider text-muted-foreground',
					'hover:text-foreground/80 transition-colors select-none',
					sizeClasses[size],
					headerPadding
				)}>
				{isOpen ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
				{Icon && <Icon size={14} className='opacity-70' />}
				<span className='flex-1 text-left truncate'>{title}</span>
			</button>

			{/* Content */}
			{isOpen && <div className={contentPadding}>{children}</div>}
		</div>
	);
}

/**
 * CollapsibleList Component
 * List of collapsible sections with consistent styling
 *
 * @param {Array<{title: string, content: ReactNode, icon?: Component}>} sections - Section definitions
 * @param {string} variant - Style variant (default 'default')
 * @param {string} className - Additional classes
 */
export function CollapsibleList({ sections, variant = 'default', className = '', ...props }) {
	return (
		<div className={clsx('space-y-2', className)} {...props}>
			{sections.map((section, index) => (
				<CollapsibleSection
					key={section.id || index}
					title={section.title}
					icon={section.icon}
					variant={variant}
					defaultOpen={section.defaultOpen !== false}>
					{section.content}
				</CollapsibleSection>
			))}
		</div>
	);
}

--- END OF shared\components\layout\CollapsibleSection.jsx ---

--- FILE: shared\components\layout\SplitView.jsx ---
import { clsx } from 'clsx';

/**
 * SplitView Component
 * Responsive 2-column layout pattern
 *
 * @param {React.ReactNode} sidebar - Sidebar content
 * @param {React.ReactNode} main - Main content
 * @param {string} sidebarPosition - 'left' or 'right' (default 'left')
 * @param {string} sidebarWidth - Sidebar width class (default 'lg:w-64')
 * @param {boolean} stickyHeader - Make sidebar sticky (default false)
 * @param {string} className - Additional container classes
 */
export default function SplitView({
	sidebar,
	main,
	sidebarPosition = 'left',
	sidebarWidth = 'lg:w-64',
	stickyHeader = false,
	className = '',
	...props
}) {
	const sidebarClasses = clsx(
		'min-w-0',
		sidebarWidth,
		stickyHeader && 'lg:sticky lg:top-0 lg:self-start lg:max-h-screen lg:overflow-y-auto'
	);

	const mainClasses = 'flex-1 min-w-0';

	return (
		<div className={clsx('flex flex-col lg:flex-row gap-4 lg:gap-6', className)} {...props}>
			{sidebarPosition === 'left' && <aside className={sidebarClasses}>{sidebar}</aside>}

			<main className={mainClasses}>{main}</main>

			{sidebarPosition === 'right' && <aside className={clsx(sidebarClasses, 'lg:order-2')}>{sidebar}</aside>}
		</div>
	);
}

/**
 * ThreeColumnLayout Component
 * For pages with sidebar, main content, and ToC/meta panel
 *
 * @param {React.ReactNode} left - Left sidebar
 * @param {React.ReactNode} center - Main content
 * @param {React.ReactNode} right - Right panel (ToC, etc.)
 * @param {string} className - Additional container classes
 */
export function ThreeColumnLayout({ left, center, right, className = '', ...props }) {
	return (
		<div
			className={clsx('grid grid-cols-1 xl:grid-cols-[1fr_48rem_1fr] gap-6 max-w-[1920px] mx-auto', className)}
			{...props}>
			{/* Left Gutter (Hidden on smaller screens) */}
			<div className='hidden xl:block' aria-hidden='true'>
				{left}
			</div>

			{/* Center Content */}
			<div className='min-w-0'>{center}</div>

			{/* Right Panel */}
			<div className='hidden xl:block'>{right}</div>
		</div>
	);
}

--- END OF shared\components\layout\SplitView.jsx ---

--- FILE: shared\components\layout\TabContainer.jsx ---
import { useState } from 'react';
import { clsx } from 'clsx';

/**
 * TabButton Component
 * Individual tab button
 */
function TabButton({ active, label, onClick, icon: Icon }) {
	return (
		<button
			onClick={onClick}
			className={clsx(
				'px-4 py-2 text-sm font-medium transition-all border-b-2 cursor-pointer',
				active
					? 'border-amber-600 text-amber-600 bg-amber-500/10/30'
					: 'border-transparent text-muted-foreground hover:text-foreground/80 hover:bg-muted/30'
			)}>
			<span className='flex items-center gap-2'>
				{Icon && <Icon size={14} />}
				{label}
			</span>
		</button>
	);
}

/**
 * TabContainer Component
 * Reusable tab navigation system
 *
 * @param {Array<{id: string, label: string, icon?: Component, content: ReactNode}>} tabs - Tab definitions
 * @param {string} defaultTab - Default active tab ID
 * @param {string} className - Additional container classes
 * @param {boolean} sticky - Make tab bar sticky (default true)
 * @param {Function} onChange - Callback when tab changes
 */
export default function TabContainer({
	tabs,
	defaultTab = null,
	className = '',
	sticky = true,
	onChange = null,
	...props
}) {
	const [activeTab, setActiveTab] = useState(defaultTab || tabs[0]?.id);

	const handleTabChange = (tabId) => {
		setActiveTab(tabId);
		if (onChange) onChange(tabId);
	};

	const activeTabContent = tabs.find((t) => t.id === activeTab)?.content;

	return (
		<div className={clsx('flex flex-col', className)} {...props}>
			{/* Tab Bar */}
			<div
				className={clsx(
					'bg-background/95 backdrop-blur shadow-sm border-b border-border z-20',
					sticky && 'sticky top-0'
				)}>
				<div className='max-w-screen-2xl mx-auto px-6 flex justify-center'>
					{tabs.map((tab) => (
						<TabButton
							key={tab.id}
							active={activeTab === tab.id}
							label={tab.label}
							icon={tab.icon}
							onClick={() => handleTabChange(tab.id)}
						/>
					))}
				</div>
			</div>

			{/* Tab Content */}
			<div className='flex-1 min-h-0'>{activeTabContent}</div>
		</div>
	);
}

/**
 * TabPanel Component
 * Wrapper for individual tab content
 *
 * @param {React.ReactNode} children - Panel content
 * @param {string} className - Additional classes
 */
export function TabPanel({ children, className = '', ...props }) {
	return (
		<div className={clsx('p-6', className)} {...props}>
			{children}
		</div>
	);
}

--- END OF shared\components\layout\TabContainer.jsx ---

--- FILE: shared\components\markdown\MarkdownRenderer.jsx ---
import ReactMarkdown from 'react-markdown';
import { generateId, extractText } from '@/shared/utils/textUtils';

/**
 * HeadingRenderer Component
 * Automatically adds IDs to headings for anchor links
 */
function HeadingRenderer({ level, children }) {
	const text = extractText(children);
	const id = generateId(text);
	const Tag = `h${level}`;
	return <Tag id={id}>{children}</Tag>;
}

/**
 * MarkdownRenderer Component
 * Pre-configured ReactMarkdown with sensible defaults
 *
 * @param {string} children - Markdown text
 * @param {Object} components - Custom component overrides
 * @param {boolean} addHeadingIds - Auto-generate heading IDs (default true)
 * @param {string} className - Additional CSS classes
 */
export default function MarkdownRenderer({
	children,
	components = {},
	addHeadingIds = true,
	className = '',
	...props
}) {
	// Safety check
	let safeText = children;
	if (Array.isArray(children)) {
		safeText = children.join('');
	} else if (typeof children !== 'string' && children !== null && children !== undefined) {
		safeText = String(children);
	}

	// Build component overrides
	const defaultComponents = {
		// Auto-add IDs to headings
		...(addHeadingIds && {
			h1: (props) => <HeadingRenderer level={1} {...props} />,
			h2: (props) => <HeadingRenderer level={2} {...props} />,
			h3: (props) => <HeadingRenderer level={3} {...props} />,
		}),
		// External links open in new tab
		a: ({ href, children }) => {
			if (href && !href.startsWith('#') && !href.startsWith('/')) {
				return (
					<a href={href} target='_blank' rel='noopener noreferrer'>
						{children}
					</a>
				);
			}
			return <a href={href}>{children}</a>;
		},
	};

	return (
		<ReactMarkdown className={className} components={{ ...defaultComponents, ...components }} {...props}>
			{safeText}
		</ReactMarkdown>
	);
}

/**
 * InlineMarkdown Component
 * For rendering markdown inside inline contexts (no block elements)
 *
 * @param {string} children - Markdown text
 */
export function InlineMarkdown({ children, ...props }) {
	return (
		<MarkdownRenderer
			components={{
				p: 'span',
				h1: 'strong',
				h2: 'strong',
				h3: 'strong',
				ul: 'span',
				ol: 'span',
				li: 'span',
			}}
			addHeadingIds={false}
			{...props}>
			{children}
		</MarkdownRenderer>
	);
}

--- END OF shared\components\markdown\MarkdownRenderer.jsx ---

--- FILE: shared\components\markdown\MarkdownWithToC.jsx ---
import { useMemo } from 'react';
import { extractHeaders } from '@/shared/utils/markdownUtils';
import { TableOfContents } from '@/features/table-of-contents/TableOfContents';
import MarkdownRenderer from './MarkdownRenderer';

/**
 * MarkdownWithToC Component
 * Renders markdown with automatic Table of Contents generation
 *
 * @param {string} children - Markdown text
 * @param {boolean} showToC - Show table of contents (default true)
 * @param {number} tocMaxDepth - Maximum heading depth for ToC (default 3)
 * @param {string} layout - Layout mode: 'split' or 'top' (default 'split')
 * @param {string} className - Additional classes for markdown container
 */
export default function MarkdownWithToC({
	children,
	showToC = true,
	tocMaxDepth = 3,
	layout = 'split',
	className = '',
	components = {},
	...props
}) {
	// Extract headers for ToC
	const tocItems = useMemo(() => {
		if (!showToC || !children) return [];
		const headers = extractHeaders(children);
		return headers.filter((h) => h.depth <= tocMaxDepth);
	}, [children, showToC, tocMaxDepth]);

	// No ToC needed
	if (!showToC || tocItems.length === 0) {
		return (
			<MarkdownRenderer className={className} components={components} {...props}>
				{children}
			</MarkdownRenderer>
		);
	}

	// Top layout: ToC above content
	if (layout === 'top') {
		return (
			<div>
				<div className='mb-6'>
					<TableOfContents items={tocItems} />
				</div>
				<MarkdownRenderer className={className} components={components} {...props}>
					{children}
				</MarkdownRenderer>
			</div>
		);
	}

	// Split layout: ToC on side
	return (
		<div className='grid grid-cols-1 xl:grid-cols-[1fr_240px] gap-8'>
			{/* Content */}
			<div className='min-w-0'>
				<MarkdownRenderer className={className} components={components} {...props}>
					{children}
				</MarkdownRenderer>
			</div>

			{/* ToC Sidebar */}
			<div className='hidden xl:block'>
				<TableOfContents items={tocItems} />
			</div>

			{/* Mobile ToC */}
			<div className='xl:hidden'>
				<TableOfContents items={tocItems} />
			</div>
		</div>
	);
}

--- END OF shared\components\markdown\MarkdownWithToC.jsx ---

--- FILE: shared\components\ui\Breadcrumbs.jsx ---
import React from 'react';
import { Link, useLocation } from 'react-router-dom'; // Added useLocation
import { ChevronRight, Home } from 'lucide-react';
import { clsx } from 'clsx';
import { useBreadcrumbs } from '@/shared/hooks/useBreadcrumbs';

export default function Breadcrumbs({ className }) {
	const crumbs = useBreadcrumbs();
	const location = useLocation();

	// 1. Explicitly exclude full-screen "World" views where overlays distract
	const BLACKLISTED_ROUTES = ['/timeline', '/relationships', '/atlas'];
	const isBlacklisted = BLACKLISTED_ROUTES.some((route) => location.pathname.startsWith(route));

	if (isBlacklisted) return null;

	// 2. Hide on "Landing Pages" (Depth check)
	// If we only have "Home > [Category]", the Page Title serves as the breadcrumb.
	// We only want to show this when deep navigating (e.g., "Home > Locations > Brindol")
	if (crumbs.length <= 2) return null;

	return (
		<nav
			className={clsx(
				'inline-flex items-center gap-1 px-3 py-1.5 rounded-full',
				'bg-background/60 backdrop-blur-md border border-border/50 shadow-sm',
				'text-xs font-medium text-muted-foreground',
				'transition-all hover:bg-background/90 hover:shadow-md hover:border-border',
				className
			)}
			aria-label='Breadcrumb'>
			<ol className='flex items-center gap-1.5'>
				{crumbs.map((crumb, index) => {
					const Icon = crumb.icon;
					const isFirst = index === 0;

					return (
						<li key={crumb.path} className='flex items-center'>
							{!isFirst && <ChevronRight size={10} className='text-muted-foreground/60 mx-0.5 shrink-0' />}

							{crumb.isCurrent ? (
								<span
									className={clsx('flex items-center gap-1.5 truncate max-w-[200px]', 'text-foreground font-semibold')}>
									{Icon && <Icon size={12} />}
									{crumb.label}
								</span>
							) : (
								<Link
									to={crumb.path}
									className='flex items-center gap-1.5 hover:text-primary transition-colors truncate max-w-[150px]'>
									{isFirst ? <Home size={12} /> : Icon && <Icon size={12} />}
									<span className={isFirst ? 'sr-only' : ''}>{crumb.label}</span>
								</Link>
							)}
						</li>
					);
				})}
			</ol>
		</nav>
	);
}

--- END OF shared\components\ui\Breadcrumbs.jsx ---

--- FILE: shared\components\ui\Button.jsx ---
import { clsx } from 'clsx';

export default function Button({
	children,
	variant = 'primary',
	size = 'md',
	icon: Icon,
	fullWidth = false,
	disabled = false,
	className,
	...props
}) {
	const baseStyles =
		'inline-flex items-center justify-center gap-2 font-medium rounded-lg transition-all focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed';

	const variants = {
		primary: 'bg-amber-600 text-white hover:bg-amber-700 focus:ring-amber-500',
		secondary: 'bg-muted text-foreground hover:bg-gray-200 focus:ring-gray-500',
		ghost: 'bg-transparent text-foreground/80 hover:bg-muted focus:ring-gray-500',
		danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500',
	};

	const sizes = {
		sm: 'px-3 py-1.5 text-sm',
		md: 'px-4 py-2 text-sm',
		lg: 'px-6 py-3 text-base',
	};

	return (
		<button
			className={clsx(baseStyles, variants[variant], sizes[size], fullWidth && 'w-full', className)}
			disabled={disabled}
			{...props}>
			{Icon && <Icon size={16} />}
			{children}
		</button>
	);
}

--- END OF shared\components\ui\Button.jsx ---

--- FILE: shared\components\ui\Card.jsx ---
import { clsx } from 'clsx';

export function Card({ children, className, padding = true, hover = false, ...props }) {
	return (
		<div
			className={clsx(
				// Use semantic variable --card instead of hardcoded white
				'bg-card text-foreground border border-border rounded-lg shadow-sm',
				padding && 'p-4',
				hover && 'transition-shadow hover:shadow-md',
				className
			)}
			{...props}>
			{children}
		</div>
	);
}

export function CardHeader({ children, className }) {
	return <div className={clsx('border-b border-border pb-3 mb-3', className)}>{children}</div>;
}

export function CardTitle({ children, className }) {
	return <h3 className={clsx('text-lg font-serif font-semibold text-foreground', className)}>{children}</h3>;
}

export function CardContent({ children, className }) {
	return <div className={className}>{children}</div>;
}

--- END OF shared\components\ui\Card.jsx ---

--- FILE: shared\components\ui\DevAdminButton.jsx ---
import React from 'react';
import { Link } from 'react-router-dom';
import { Database, Wrench } from 'lucide-react';

export default function DevAdminButton() {
	// CRITICAL: This ensures it never renders in Production (GitHub Pages)
	if (!import.meta.env.DEV) return null;

	return (
		<Link
			to='/dm'
			className='fixed bottom-6 right-6 z-50 flex items-center gap-2 px-4 py-1 bg-muted  rounded-full shadow-xl hover:bg-background hover:scale-105 transition-all border border-stone-300'
			title='Open DM Console (Dev Mode Only)'>
			<Wrench size={14} />
			<span className='hidden md:inline'>Dev</span>
		</Link>
	);
}

--- END OF shared\components\ui\DevAdminButton.jsx ---

--- FILE: shared\components\ui\Drawer.jsx ---
import { createPortal } from 'react-dom';
import { X } from 'lucide-react';
import { clsx } from 'clsx';
import { useEffect, useState } from 'react';

/**
 * Reusable Mobile Drawer with 60fps hardware-accelerated transitions
 */
export const Drawer = ({ isOpen, onClose, title, children, position = 'right', className }) => {
	const [isVisible, setIsVisible] = useState(false);

	useEffect(() => {
		if (isOpen) {
			setIsVisible(true);
			document.body.classList.add('drawer-open');
		} else {
			// Wait for animation to finish before unmounting DOM
			const timer = setTimeout(() => {
				setIsVisible(false);
				document.body.classList.remove('drawer-open');
			}, 350); // Slightly longer than CSS duration to ensure completion
			return () => clearTimeout(timer);
		}
		return () => document.body.classList.remove('drawer-open');
	}, [isOpen]);

	if (!isVisible && !isOpen) return null;

	// Slide directions
	const positionClasses = {
		right: 'right-0 top-0 bottom-0 border-l',
		left: 'left-0 top-0 bottom-0 border-r',
	};

	// Transform values
	const transforms = {
		right: isOpen ? 'translate-x-0' : 'translate-x-full',
		left: isOpen ? 'translate-x-0' : '-translate-x-full',
	};

	return createPortal(
		<div className='fixed inset-0 z-[10050] isolate'>
			{/* Backdrop - Fades in/out */}
			<div
				className={clsx(
					'absolute inset-0 bg-black/20 backdrop-blur-[2px] transition-opacity duration-300 ease-in-out',
					isOpen ? 'opacity-100' : 'opacity-0'
				)}
				onClick={onClose}
				aria-hidden='true'
			/>

			{/* Panel - Slides with Physics Easing */}
			<div
				className={clsx(
					'absolute w-80 bg-background shadow-2xl border-border flex flex-col pb-safe',
					// Hardware acceleration hints
					'will-change-transform transition-transform duration-300',
					// iOS-like spring easing (cubic-bezier)
					'ease-[cubic-bezier(0.32,0.72,0,1)]',
					positionClasses[position],
					transforms[position],
					className
				)}>
				{/* Header */}
				<div className='p-4 pt-[calc(1rem+env(safe-area-inset-top))] border-b border-border flex items-center justify-between bg-muted shrink-0'>
					<span className='text-sm font-serif font-bold text-foreground'>{title}</span>
					<button
						onClick={onClose}
						className='p-2 -mr-2 hover:bg-background/50 rounded-full transition-colors active:scale-95 text-muted-foreground'
						aria-label='Close Sidebar'>
						<X size={20} />
					</button>
				</div>

				{/* Content */}
				<div className='flex-1 overflow-y-auto custom-scrollbar p-0'>{children}</div>
			</div>
		</div>,
		document.body
	);
};

--- END OF shared\components\ui\Drawer.jsx ---

--- FILE: shared\components\ui\EmptyState.jsx ---
import { clsx } from 'clsx';

export default function EmptyState({ icon: Icon, title, description, action, className }) {
	return (
		<div className={clsx('flex flex-col items-center justify-center p-8 text-center', className)}>
			{Icon && (
				<div className='mb-4 rounded-full bg-muted p-4'>
					<Icon className='w-8 h-8 text-muted-foreground/70' strokeWidth={1.5} />
				</div>
			)}
			{title && <h3 className='text-lg font-serif font-semibold text-foreground mb-2'>{title}</h3>}
			{description && <p className='text-sm text-muted-foreground max-w-sm mb-6'>{description}</p>}
			{action && <div>{action}</div>}
		</div>
	);
}

--- END OF shared\components\ui\EmptyState.jsx ---

--- FILE: shared\components\ui\LoadingSpinner.jsx ---
import { Loader2 } from 'lucide-react';
import { clsx } from 'clsx';

export default function LoadingSpinner({ size = 'md', text = 'Loading...', className }) {
	const sizes = {
		sm: 'w-4 h-4',
		md: 'w-8 h-8',
		lg: 'w-12 h-12',
	};

	return (
		<div className={clsx('flex flex-col items-center justify-center gap-3', className)}>
			<Loader2 className={clsx(sizes[size], 'animate-spin text-amber-600')} />
			{text && <p className='text-sm text-muted-foreground font-medium'>{text}</p>}
		</div>
	);
}

--- END OF shared\components\ui\LoadingSpinner.jsx ---

--- FILE: shared\components\ui\SectionDivider.jsx ---
import { Diamond } from 'lucide-react';

export const SectionDivider = () => (
	<div className='flex items-center gap-4 my-6 opacity-80 select-none'>
		<div className='h-px bg-border flex-1' />
		<div className='flex-shrink-0 text-primary/40'>
			<Diamond size={10} fill='currentColor' />
		</div>
		<div className='h-px bg-border flex-1' />
	</div>
);

--- END OF shared\components\ui\SectionDivider.jsx ---

--- FILE: shared\hooks\useBreadcrumbs.js ---
import { useLocation } from 'react-router-dom';
import { useMemo } from 'react';
import { useEntityIndex } from '@/features/smart-text/useEntityIndex';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import { capitalize } from '@/shared/utils/textUtils';

const ROUTE_LABELS = {
	dm: 'DM Console',
	manage: 'Manage',
	atlas: 'Atlas',
	timeline: 'Timeline',
	relationships: 'Graph',
	wiki: 'Wiki',
};

export function useBreadcrumbs() {
	const location = useLocation();
	const { map: entityMap } = useEntityIndex(); // DESTRUCTURED: Use Map

	const breadcrumbs = useMemo(() => {
		const pathnames = location.pathname.split('/').filter((x) => x);
		const crumbs = [];

		crumbs.push({
			label: 'Home',
			path: '/',
			isCurrent: pathnames.length === 0,
		});

		const isWiki = pathnames[0] === 'wiki';
		const SKIP_SEGMENTS = ['manage', 'wiki'];

		let currentPath = '';

		for (let i = 0; i < pathnames.length; i++) {
			const segment = pathnames[i];
			currentPath += `/${segment}`;

			if (SKIP_SEGMENTS.includes(segment)) continue;

			const isLast = i === pathnames.length - 1;
			const isUUID = /^[0-9a-fA-F-]{36}$/.test(segment);

			if (isWiki && isUUID) {
				// OPTIMIZATION: O(1) Lookup
				const targetEntity = entityMap.get(segment);

				if (targetEntity) {
					const hierarchyStack = [];
					let current = targetEntity;
					const visited = new Set([current.id]);

					// Fast recursive climb using Map
					while (current.parentId) {
						const parent = entityMap.get(current.parentId);
						if (!parent || visited.has(parent.id)) break;

						visited.add(parent.id);
						hierarchyStack.unshift(parent);
						current = parent;
					}

					hierarchyStack.forEach((ancestor) => {
						crumbs.push({
							label: ancestor.name,
							path: `/wiki/${ancestor.type}/${ancestor.id}`,
							isCurrent: false,
							icon: null,
						});
					});

					crumbs.push({
						label: targetEntity.name,
						path: currentPath,
						isCurrent: isLast,
					});
				} else {
					crumbs.push({ label: 'Unknown Entity', path: currentPath, isCurrent: isLast });
				}
			} else if (segment === 'new') {
				crumbs.push({ label: 'Create New', path: currentPath, isCurrent: isLast });
			} else if (getEntityConfig(segment).type !== 'default') {
				const config = getEntityConfig(segment);
				crumbs.push({
					label: config.labelPlural,
					path: currentPath,
					isCurrent: isLast,
					icon: config.icon,
				});
			} else {
				const label = ROUTE_LABELS[segment] || capitalize(segment.replace(/_/g, ' '));
				crumbs.push({ label, path: currentPath, isCurrent: isLast });
			}
		}

		return crumbs;
	}, [location.pathname, entityMap]);

	return breadcrumbs;
}

--- END OF shared\hooks\useBreadcrumbs.js ---

--- FILE: shared\hooks\useTheme.js ---
import { useState, useEffect } from 'react';

export const THEMES = {
	// LIGHT: 'light',
	DARK: 'dark', // RE-ENABLED
	DND: 'dnd',
};

export function useTheme() {
	const [theme, setTheme] = useState(() => {
		const stored = localStorage.getItem('app-theme');
		return stored || THEMES.LIGHT;
	});

	useEffect(() => {
		const root = window.document.documentElement;
		Object.values(THEMES).forEach((t) => root.removeAttribute('data-theme'));

		if (theme !== THEMES.LIGHT) {
			root.setAttribute('data-theme', theme);
		}

		localStorage.setItem('app-theme', theme);
	}, [theme]);

	const cycleTheme = () => {
		const themes = Object.values(THEMES);
		const currentIndex = themes.indexOf(theme);
		const nextIndex = (currentIndex + 1) % themes.length;
		setTheme(themes[nextIndex]);
	};

	return { theme, setTheme, cycleTheme };
}

--- END OF shared\hooks\useTheme.js ---

--- FILE: shared\utils\imageUtils.js ---
/**
 * Centralized image URL resolution
 * Used by: EntityViewModel, EntityIndex, TooltipCard
 */

const IMAGE_KEYS = {
	background: ['background_image', 'background', 'Background', 'Background_image'],
	icon: ['icon', 'Icon', 'token', 'Token', 'portrait', 'Portrait'],
	any: ['background_image', 'background', 'image', 'Image', 'portrait', 'Portrait', 'icon', 'Icon'],
};

/**
 * Extract value from nested attribute structure
 */
const extractValue = (val) => {
	if (!val) return null;
	if (typeof val === 'string') return val;
	if (Array.isArray(val)) return val[0]?.value || val[0];
	if (typeof val === 'object' && val.value) return val.value;
	return null;
};

/**
 * Resolve image URL from attributes object
 * @param {Object} attributes - Entity attributes
 * @param {'background' | 'icon' | 'any'} type - Type of image to find
 * @returns {string|null} - Resolved URL or null
 */
export const resolveImageUrl = (attributes, type = 'any') => {
	if (!attributes) return null;

	const keys = IMAGE_KEYS[type] || IMAGE_KEYS.any;

	for (const key of keys) {
		const val = attributes[key] || attributes[key.toLowerCase()];
		const rawUrl = extractValue(val);

		if (rawUrl) {
			// Clean path and prepend base URL
			const cleanPath = rawUrl
				.trim()
				.replace(/(\.\.\/)+/g, '')
				.replace(/^\//, '');

			return `${import.meta.env.BASE_URL}${cleanPath}`;
		}
	}

	return null;
};

/**
 * Safe attribute parser
 */
export const parseAttributes = (attrs) => {
	if (!attrs) return {};
	if (typeof attrs === 'object') return attrs;
	try {
		return JSON.parse(attrs);
	} catch {
		return {};
	}
};

--- END OF shared\utils\imageUtils.js ---

--- FILE: shared\utils\markdownUtils.js ---
/**
 * Markdown-specific Utilities
 * Header extraction, ToC generation, etc.
 */

import { generateId } from '@/shared/utils/textUtils';

/**
 * Extract headers from markdown text
 * @param {string} markdown - Markdown text
 * @returns {Array<{depth: number, text: string, id: string}>}
 */
export const extractHeaders = (markdown) => {
	if (!markdown) return [];

	const regex = /^(#{1,3})\s+(.+)$/gm;
	const headers = [];
	let match;

	while ((match = regex.exec(markdown)) !== null) {
		headers.push({
			depth: match[1].length, // 1, 2, or 3
			text: match[2].trim(),
			id: generateId(match[2]),
		});
	}

	return headers;
};

/**
 * Generate Table of Contents from markdown
 * @param {string} markdown - Markdown text
 * @param {number} maxDepth - Maximum heading depth (default 3)
 * @returns {Array<{depth: number, text: string, id: string}>}
 */
export const generateToC = (markdown, maxDepth = 3) => {
	const headers = extractHeaders(markdown);
	return headers.filter((h) => h.depth <= maxDepth);
};

/**
 * Convert markdown to plain text (strips formatting)
 * @param {string} markdown - Markdown text
 * @returns {string}
 */
export const markdownToText = (markdown) => {
	if (!markdown) return '';

	return markdown
		.replace(/#{1,6}\s+/g, '') // Headers
		.replace(/\*\*(.+?)\*\*/g, '$1') // Bold
		.replace(/\*(.+?)\*/g, '$1') // Italic
		.replace(/\[(.+?)\]\(.+?\)/g, '$1') // Links
		.replace(/`(.+?)`/g, '$1') // Code
		.replace(/^>\s+/gm, '') // Blockquotes
		.replace(/^[-*+]\s+/gm, '') // Lists
		.replace(/^\d+\.\s+/gm, '') // Ordered lists
		.trim();
};

/**
 * Extract excerpt from markdown (first paragraph)
 * @param {string} markdown - Markdown text
 * @param {number} maxLength - Maximum length (default 200)
 * @returns {string}
 */
export const extractExcerpt = (markdown, maxLength = 200) => {
	if (!markdown) return '';

	// Remove headers
	const withoutHeaders = markdown.replace(/^#{1,6}\s+.+$/gm, '');

	// Get first paragraph
	const paragraphs = withoutHeaders
		.split(/\n\n+/)
		.map((p) => p.trim())
		.filter(Boolean);

	if (paragraphs.length === 0) return '';

	const firstPara = markdownToText(paragraphs[0]);

	if (firstPara.length <= maxLength) return firstPara;
	return firstPara.slice(0, maxLength).trim() + '...';
};

/**
 * Count words in markdown (excluding formatting)
 * @param {string} markdown - Markdown text
 * @returns {number}
 */
export const countMarkdownWords = (markdown) => {
	const plainText = markdownToText(markdown);
	if (!plainText) return 0;
	return plainText.trim().split(/\s+/).length;
};

/**
 * Parse markdown frontmatter (YAML at start of document)
 * @param {string} markdown - Markdown with frontmatter
 * @returns {{frontmatter: Object, content: string}}
 */
export const parseFrontmatter = (markdown) => {
	if (!markdown) return { frontmatter: {}, content: '' };

	const frontmatterRegex = /^---\n([\s\S]*?)\n---\n([\s\S]*)$/;
	const match = markdown.match(frontmatterRegex);

	if (!match) {
		return { frontmatter: {}, content: markdown };
	}

	// Simple YAML parser (key: value pairs only)
	const frontmatterText = match[1];
	const frontmatter = {};

	frontmatterText.split('\n').forEach((line) => {
		const colonIndex = line.indexOf(':');
		if (colonIndex > 0) {
			const key = line.slice(0, colonIndex).trim();
			const value = line.slice(colonIndex + 1).trim();
			frontmatter[key] = value;
		}
	});

	return {
		frontmatter,
		content: match[2],
	};
};

/**
 * Add IDs to headers in markdown (for anchor links)
 * @param {string} markdown - Original markdown
 * @returns {string} Markdown with header IDs
 */
export const addHeaderIds = (markdown) => {
	if (!markdown) return '';

	return markdown.replace(/^(#{1,6})\s+(.+)$/gm, (match, hashes, text) => {
		const id = generateId(text);
		return `${hashes} ${text} {#${id}}`;
	});
};

--- END OF shared\utils\markdownUtils.js ---

--- FILE: shared\utils\textUtils.js ---
/**
 * Text Processing Utilities
 * String manipulation, sanitization, and formatting
 */

/**
 * Truncate text to a maximum length with ellipsis
 * @param {string} text - Text to truncate
 * @param {number} maxLength - Maximum length
 * @returns {string}
 */
export const truncate = (text, maxLength = 100) => {
	if (!text || text.length <= maxLength) return text;
	return text.slice(0, maxLength).trim() + '...';
};

/**
 * Sanitize text for safe display
 * @param {string} text - Text to sanitize
 * @returns {string}
 */
export const sanitizeText = (text) => {
	if (!text) return '';
	return String(text).trim();
};

/**
 * Convert text to URL-safe slug
 * @param {string} text - Text to convert
 * @returns {string}
 */
export const slugify = (text) => {
	if (!text) return '';

	return text
		.toString()
		.toLowerCase()
		.trim()
		.replace(/\s+/g, '-') // Replace spaces with -
		.replace(/[^\w-]+/g, '') // Remove non-word chars
		.replace(/--+/g, '-') // Replace multiple - with single -
		.replace(/^-+/, '') // Trim - from start
		.replace(/-+$/, ''); // Trim - from end
};

/**
 * Generate a unique ID from text (for headings, anchors)
 * @param {string} text - Text to convert
 * @returns {string}
 */
export const generateId = (text) => {
	if (!text) return '';

	return text
		.toString()
		.toLowerCase()
		.trim()
		.replace(/\s+/g, '-')
		.replace(/[^\w-]+/g, '')
		.replace(/--+/g, '-');
};

/**
 * Extract plain text from children (for React components)
 * @param {*} children - React children
 * @returns {string}
 */
export const extractText = (children) => {
	if (typeof children === 'string') return children;
	if (Array.isArray(children)) return children.map(extractText).join('');
	if (children?.props?.children) return extractText(children.props.children);
	return '';
};

/**
 * Capitalize first letter of string
 * @param {string} text - Text to capitalize
 * @returns {string}
 */
export const capitalize = (text) => {
	if (!text) return '';
	return text.charAt(0).toUpperCase() + text.slice(1);
};

/**
 * Convert snake_case or kebab-case to Title Case
 * @param {string} text - Text to convert
 * @returns {string}
 */
export const toTitleCase = (text) => {
	if (!text) return '';

	return text
		.replace(/[_-]/g, ' ')
		.split(' ')
		.map((word) => capitalize(word))
		.join(' ');
};

/**
 * Count words in text
 * @param {string} text - Text to count
 * @returns {number}
 */
export const wordCount = (text) => {
	if (!text) return 0;
	return text.trim().split(/\s+/).length;
};

/**
 * Estimate reading time in minutes
 * @param {string} text - Text to analyze
 * @param {number} wordsPerMinute - Reading speed (default 200)
 * @returns {number}
 */
export const estimateReadingTime = (text, wordsPerMinute = 200) => {
	const words = wordCount(text);
	return Math.ceil(words / wordsPerMinute);
};

/**
 * Escape special regex characters
 * @param {string} str - String to escape
 * @returns {string}
 */
export const escapeRegex = (str) => {
	return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};

/**
 * Strip markdown formatting (basic)
 * @param {string} text - Markdown text
 * @returns {string} Plain text
 */
export const stripMarkdown = (text) => {
	if (!text) return '';

	return text
		.replace(/#{1,6}\s+/g, '') // Headers
		.replace(/\*\*(.+?)\*\*/g, '$1') // Bold
		.replace(/\*(.+?)\*/g, '$1') // Italic
		.replace(/\[(.+?)\]\(.+?\)/g, '$1') // Links
		.replace(/`(.+?)`/g, '$1') // Code
		.replace(/^>\s+/gm, '') // Blockquotes
		.trim();
};

/**
 * Check if text contains markdown formatting
 * @param {string} text - Text to check
 * @returns {boolean}
 */
export const hasMarkdown = (text) => {
	if (!text) return false;

	const markdownPatterns = [
		/#{1,6}\s+/, // Headers
		/\*\*.*?\*\*/, // Bold
		/\*.*?\*/, // Italic
		/\[.*?\]\(.*?\)/, // Links
		/`.*?`/, // Code
		/^>\s+/m, // Blockquotes
		/^[-*+]\s+/m, // Lists
		/^\d+\.\s+/m, // Ordered lists
	];

	return markdownPatterns.some((pattern) => pattern.test(text));
};

--- END OF shared\utils\textUtils.js ---

--- FILE: shared\utils\theme\colorUtils.js ---
/**
 * Color and Theme Utilities
 * Color manipulation, hex/rgb conversion, opacity
 */

/**
 * Convert hex color to RGB
 * @param {string} hex - Hex color (e.g., "#ff0000" or "ff0000")
 * @returns {{r: number, g: number, b: number}|null}
 */
export const hexToRgb = (hex) => {
	if (!hex) return null;

	// Remove # if present
	const cleanHex = hex.replace('#', '');

	// Validate hex
	if (!/^[0-9A-F]{6}$/i.test(cleanHex)) return null;

	return {
		r: parseInt(cleanHex.slice(0, 2), 16),
		g: parseInt(cleanHex.slice(2, 4), 16),
		b: parseInt(cleanHex.slice(4, 6), 16),
	};
};

/**
 * Convert RGB to hex
 * @param {number} r - Red (0-255)
 * @param {number} g - Green (0-255)
 * @param {number} b - Blue (0-255)
 * @returns {string} Hex color
 */
export const rgbToHex = (r, g, b) => {
	const toHex = (n) => {
		const hex = Math.max(0, Math.min(255, Math.round(n))).toString(16);
		return hex.length === 1 ? '0' + hex : hex;
	};

	return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
};

/**
 * Add opacity to hex color
 * @param {string} hex - Hex color
 * @param {number} opacity - Opacity (0-1)
 * @returns {string} rgba() string
 */
export const hexWithOpacity = (hex, opacity) => {
	const rgb = hexToRgb(hex);
	if (!rgb) return hex;

	return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
};

/**
 * Lighten a hex color by percentage
 * @param {string} hex - Hex color
 * @param {number} percent - Percentage to lighten (0-100)
 * @returns {string} New hex color
 */
export const lightenColor = (hex, percent) => {
	const rgb = hexToRgb(hex);
	if (!rgb) return hex;

	const amount = (percent / 100) * 255;

	return rgbToHex(rgb.r + amount, rgb.g + amount, rgb.b + amount);
};

/**
 * Darken a hex color by percentage
 * @param {string} hex - Hex color
 * @param {number} percent - Percentage to darken (0-100)
 * @returns {string} New hex color
 */
export const darkenColor = (hex, percent) => {
	const rgb = hexToRgb(hex);
	if (!rgb) return hex;

	const amount = (percent / 100) * 255;

	return rgbToHex(rgb.r - amount, rgb.g - amount, rgb.b - amount);
};

/**
 * Get contrasting text color (black or white) for background
 * @param {string} hex - Background hex color
 * @returns {string} '#000000' or '#ffffff'
 */
export const getContrastColor = (hex) => {
	const rgb = hexToRgb(hex);
	if (!rgb) return '#000000';

	// Calculate relative luminance
	const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;

	return luminance > 0.5 ? '#000000' : '#ffffff';
};

/**
 * Check if a color is light or dark
 * @param {string} hex - Hex color
 * @returns {'light'|'dark'}
 */
export const getColorBrightness = (hex) => {
	return getContrastColor(hex) === '#000000' ? 'light' : 'dark';
};

/**
 * Generate color palette from base color
 * @param {string} hex - Base hex color
 * @returns {Object} Palette with shades
 */
export const generatePalette = (hex) => {
	return {
		50: lightenColor(hex, 45),
		100: lightenColor(hex, 40),
		200: lightenColor(hex, 30),
		300: lightenColor(hex, 20),
		400: lightenColor(hex, 10),
		500: hex,
		600: darkenColor(hex, 10),
		700: darkenColor(hex, 20),
		800: darkenColor(hex, 30),
		900: darkenColor(hex, 40),
	};
};

/**
 * Parse CSS color value (hex, rgb, rgba)
 * @param {string} color - CSS color string
 * @returns {{r: number, g: number, b: number, a: number}|null}
 */
export const parseColor = (color) => {
	if (!color) return null;

	// Hex
	if (color.startsWith('#')) {
		const rgb = hexToRgb(color);
		return rgb ? { ...rgb, a: 1 } : null;
	}

	// RGB/RGBA
	const rgbaMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
	if (rgbaMatch) {
		return {
			r: parseInt(rgbaMatch[1]),
			g: parseInt(rgbaMatch[2]),
			b: parseInt(rgbaMatch[3]),
			a: rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1,
		};
	}

	return null;
};

--- END OF shared\utils\theme\colorUtils.js ---

--- FILE: shared\utils\theme\cssUtils.js ---
/**
 * CSS Variable Utilities
 * Read and write CSS custom properties
 */

/**
 * Get CSS variable value from document root
 * @param {string} name - Variable name (with or without --)
 * @returns {string} Variable value
 */
export const getCSSVariable = (name) => {
	const varName = name.startsWith('--') ? name : `--${name}`;
	return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
};

/**
 * Set CSS variable on document root
 * @param {string} name - Variable name (with or without --)
 * @param {string} value - Variable value
 */
export const setCSSVariable = (name, value) => {
	const varName = name.startsWith('--') ? name : `--${name}`;
	document.documentElement.style.setProperty(varName, value);
};

/**
 * Get all theme CSS variables
 * @returns {Object} Theme variables
 */
export const getThemeVariables = () => {
	return {
		background: getCSSVariable('--background'),
		foreground: getCSSVariable('--foreground'),
		muted: getCSSVariable('--muted'),
		mutedForeground: getCSSVariable('--muted-foreground'),
		border: getCSSVariable('--border'),
		accent: getCSSVariable('--accent'),
		accentForeground: getCSSVariable('--accent-foreground'),
	};
};

/**
 * Apply theme variables
 * @param {Object} theme - Theme variable object
 */
export const applyTheme = (theme) => {
	Object.entries(theme).forEach(([key, value]) => {
		// Convert camelCase to kebab-case
		const cssKey = key.replace(/([A-Z])/g, '-$1').toLowerCase();
		setCSSVariable(cssKey, value);
	});
};

/**
 * Get current theme mode (light/dark/dnd)
 * @returns {string} Theme mode
 */
export const getCurrentTheme = () => {
	return document.documentElement.getAttribute('data-theme') || 'light';
};

/**
 * Set theme mode
 * @param {string} theme - Theme name (light/dark/dnd)
 */
export const setTheme = (theme) => {
	if (theme === 'light') {
		document.documentElement.removeAttribute('data-theme');
	} else {
		document.documentElement.setAttribute('data-theme', theme);
	}
	localStorage.setItem('app-theme', theme);
};

/**
 * Get stored theme preference
 * @returns {string} Stored theme or 'light'
 */
export const getStoredTheme = () => {
	return localStorage.getItem('app-theme') || 'light';
};

/**
 * Check if system prefers dark mode
 * @returns {boolean}
 */
export const prefersDarkMode = () => {
	return window.matchMedia('(prefers-color-scheme: dark)').matches;
};

/**
 * Get optimal theme based on preference and system
 * @returns {string} Theme name
 */
export const getOptimalTheme = () => {
	const stored = getStoredTheme();
	if (stored !== 'auto') return stored;

	return prefersDarkMode() ? 'dark' : 'light';
};

--- END OF shared\utils\theme\cssUtils.js ---

