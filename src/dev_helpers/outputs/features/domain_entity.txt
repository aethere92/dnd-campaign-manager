================================================================
PARTIAL BUNDLE: DOMAIN ENTITY
================================================================

### PROJECT MAP (FILE STRUCTURE)
./
  main.jsx
  todo.md
  app/
    App.jsx
    AppRoutes.jsx
    components/
      RouteLoading.jsx
    styles/
      global.css
  domain/
    entity/
      api/
        entityService.js
      components/
        EntityBadge.jsx
        EntityIcon.jsx
        EntityLink.jsx
        EntityStatusIcon.jsx
      config/
        entityColors.js
        entityConfig.js
        entityIcons.js
        entityStyles.js
        entityTypes.js
      utils/
        attributeParser.js
        entityUtils.js
        statusUtils.js
  features/
    admin/
      api/
        adminService.js
      components/
        AdminForm.jsx
        AdminFormStyles.js
        AdvancedFilter.jsx
        EncounterManager.jsx
        EntitySearch.jsx
        EventTagger.jsx
        ImageLibraryModal.jsx
        MarkdownEditor.jsx
        MarkdownEditorImpl.jsx
        QuestObjectiveManager.jsx
        RelationshipManager.jsx
        SessionEventManager.jsx
        SmartColorPicker.jsx
        SmartImageInput.jsx
        TacticalMapManager.jsx
        atlas/
          AtlasForms.jsx
          editor/
            AtlasEditor.jsx
            AtlasEditorContext.jsx
            components/
              EditorLayerList.jsx
              EditorMapEvents.jsx
              EditorSidebar.jsx
              EditorToolbar.jsx
              VertexHandle.jsx
            layers/
              EditAreasLayer.jsx
              EditMarkersLayer.jsx
              EditOverlaysLayer.jsx
              EditPathsLayer.jsx
      config/
        adminStrategies.js
        imageManifest.json
      layouts/
        AdminLayout.jsx
      pages/
        BulkReplaceTool.jsx
        EntityEditorPage.jsx
        EntityListPage.jsx
        MapManagerPage.jsx
        MapMigrationTool.jsx
        SplitPaneManager.jsx
      utils/
        filterUtils.js
    atlas/
      MapPage.jsx
      useMapData.js
      api/
        mapService.js
      components/
        AtlasSidebar.jsx
        MapCanvas.jsx
        MapTools.jsx
        MapZoomHandler.jsx
        useMapCanvasViewModel.js
        __MapLayerControl.jsx
        layers/
          MapAreas.jsx
          MapMarkers.jsx
          MapOverlays.jsx
          MapRecaps.jsx
      config/
        mapConfig.js
      context/
        AtlasContext.jsx
      data/
        modularize.js
        refactor.js
        campaign_02/
          index.js
          faerun/
            index.js
      utils/
        mapNavigation.js
        markerUtils.js
    campaign/
      CampaignContext.jsx
      useCampaignData.js
      useCampaignPersistence.js
      useCampaignSelection.js
      api/
        campaignService.js
      components/
        CampaignCard.jsx
        CampaignSelect.jsx
    dashboard/
      DashboardPage.jsx
      api/
        dashboardService.js
      components/
        ActiveThreads.jsx
        ArchiveTree.jsx
        CampaignHeader.jsx
        CurrentArcMetadata.jsx
        CurrentStoryStack.jsx
        InsightsGrid.jsx
        PartyWidget.jsx
        QuickInsights.jsx
    graph/
      GraphPage.jsx
      useGraphView.js
      api/
        graphService.js
      components/
        CytoscapeCanvas.jsx
        GraphLegend.jsx
      config/
        graphStyles.js
      utils/
        graphMapper.js
    navigation/
      MainLayout.jsx
      useNavigation.js
      components/
        Sidebar.jsx
        SidebarFooter.jsx
        SidebarHeader.jsx
        SidebarNav.jsx
      config/
        navConfig.js
    search/
      GlobalSearch.jsx
      SearchContext.jsx
      useGlobalSearch.js
      api/
        searchService.js
      components/
        SearchFooter.jsx
        SearchModal.jsx
        SearchResultItem.jsx
        SearchResults.jsx
        SearchTrigger.jsx
      utils/
        searchMapper.js
    smart-text/
      SmartMarkdown.jsx
      useEntityIndex.js
      useSmartText.js
      components/
        EntityEmbed.jsx
        SmartEntityLink.jsx
    smart-tooltip/
      TooltipContainer.jsx
      TooltipContext.jsx
      useSmartPosition.js
      useTooltipState.js
      components/
        TooltipCard.jsx
      config/
        tooltipProfiles.js
    table-of-contents/
      TableOfContents.jsx
      components/
        TocItem.jsx
        TocMobileDrawer.jsx
      hooks/
        useTocObserver.js
        useTocScroll.js
    timeline/
      TimelinePage.jsx
      useTimelineView.js
      api/
        timelineService.js
      components/
        TimelineArcHeader.jsx
        TimelineEvent.jsx
        TimelineSession.jsx
      utils/
        eventStyles.js
    wiki/
      useEntityView.js
      useWikiNavigation.js
      WikiLayout.jsx
      api/
        wikiService.js
      components/
        EncounterTimeline.jsx
        EntityBody.jsx
        EntityHeader.jsx
        EntityHistory.jsx
        EntityLocalGraph.jsx
        EntityMiniMap.jsx
        EntitySidebar.jsx
        QuestObjectives.jsx
        SessionMentions.jsx
        WikiEntryView.jsx
        character/
          CharacterSidebar.jsx
          CharacterStats.jsx
          RelationshipNetwork.jsx
        landing/
          EntityGridCard.jsx
          EntityPosterCard.jsx
          EntityTableGroup.jsx
          Swimlane.jsx
        navigation/
          SidebarEmptyState.jsx
          WikiSidebar.jsx
          WikiSidebarHeader.jsx
          WikiSidebarList.jsx
          sidebar/
            CollapsibleGroup.jsx
            EntityListItem.jsx
            PriorityIcon.jsx
            SidebarTreeItem.jsx
            StatusIcon.jsx
      config/
        groupingConfig.js
        viewStrategies.js
      hooks/
        useEntityContent.js
        useEntityFetching.js
        useEntityGrouping.js
        useEntityHeader.js
        useEntitySidebar.js
      layouts/
        CharacterLayout.jsx
        SessionLayout.jsx
        StandardLayout.jsx
      pages/
        WikiDetailPage.jsx
        WikiLandingPage.jsx
      utils/
        attributeMapper.js
        eventMapper.js
        relationshipMapper.js
        wikiEntryMapper.js
        wikiUtils.js
  shared/
    api/
      supabaseClient.js
    components/
      ErrorBoundary.jsx
      layout/
        CollapsibleSection.jsx
        SplitView.jsx
        TabContainer.jsx
      markdown/
        MarkdownRenderer.jsx
        MarkdownWithToC.jsx
      ui/
        Breadcrumbs.jsx
        Button.jsx
        Card.jsx
        DevAdminButton.jsx
        Drawer.jsx
        EmptyState.jsx
        HighlightBadge.jsx
        LoadingSpinner.jsx
        SectionDivider.jsx
    hooks/
      useBreadcrumbs.js
      useTheme.js
    utils/
      imageUtils.js
      markdownUtils.js
      textUtils.js
      theme/
        colorUtils.js
        cssUtils.js

================================================================
### SOURCE CODE
================================================================

--- FILE: domain\entity\api\entityService.js ---
import { supabase } from '@/shared/api/supabaseClient';
import { getCampaigns } from '@/features/campaign/api/campaignService';

// --- API METHODS ---

export const getSessions = async (campaignId) => {
	// OPTIMIZATION: Use the pre-aggregated view
	const { data, error } = await supabase
		.from('view_campaign_timeline')
		.select('*')
		.eq('campaign_id', campaignId)
		.order('session_number', { ascending: true });

	if (error) throw error;

	// Map View structure to Domain structure
	return (data || []).map((s) => ({
		id: s.session_id,
		name: s.session_title,
		type: 'session',
		session_number: s.session_number,
		session_date: s.session_date,
		narrative: s.session_narrative,
		// Ensure generic attributes object exists for compatibility
		attributes: {
			session_number: s.session_number,
			session_date: s.session_date,
		},
	}));
};

const getCompleteEntities = async (campaignId, type) => {
	// Uses the detailed view for full entity pages
	const { data, error } = await supabase
		.from('entity_complete_view')
		.select('id, name, type, description, attributes, relationships')
		.eq('campaign_id', campaignId)
		.eq('type', type)
		.order('name');

	if (error) throw error;
	return data;
};

/**
 * Fetch Narrative Arcs and their links to Sessions
 * Used for organizing the Wiki Swimlanes
 */
export const getCampaignArcs = async (campaignId) => {
	// 1. Fetch the Pre-Calculated View
	const { data: arcs, error: arcError } = await supabase
		.from('view_narrative_arc_summary')
		.select('*')
		.eq('campaign_id', campaignId) // Ensure your view handles campaign_id or filter via join if needed
		.order('order', { ascending: true });

	if (arcError) throw arcError;

	// 2. Fetch the Session Links (needed for grouping logic in JS)
	const { data: rels, error: relError } = await supabase
		.from('entity_relationships')
		.select('from_entity_id, to_entity_id')
		.eq('relationship_type', 'part_of')
		.in(
			'to_entity_id',
			arcs.map((a) => a.id)
		); // Only get links for these arcs

	if (relError) throw relError;

	return { arcs, rels };
};

export const getEntities = async (campaignId, type) => {
	const strategy = entityStrategies[type] || entityStrategies.default;
	return strategy(campaignId, type);
};

export const getGraphData = async (campaignId) => {
	// OPTIMIZATION: Use the graph-specific view (Nodes + Adjacency List)
	const { data, error } = await supabase.from('view_campaign_graph').select('*').eq('campaign_id', campaignId);

	if (error) {
		console.error('Graph Fetch Error:', error);
		return [];
	}
	return data || [];
};

export const getEntityIndex = async (campaignId) => {
	// OPTIMIZATION: Use lightweight index view (No heavy JSON joins)
	const { data, error } = await supabase
		.from('view_entity_index')
		.select('*') // Selects: id, name, type, description, icon_url, status, affinity
		.eq('campaign_id', campaignId);

	if (error) return [];

	// Remap flat columns to expected 'attributes' object for UI compatibility
	return data
		.map((e) => ({
			...e,
			attributes: {
				icon: e.icon_url,
				status: e.status,
				affinity: e.affinity,
				background_image: e.background_image,
				aliases: e.aliases,
			},
		}))
		.sort((a, b) => b.name.length - a.name.length);
};

// --- WIKI ENTRY STRATEGIES ---

const fetchSessionWikiEntry = async (id) => {
	// 1. Fetch Core Data + Events + Mentions via View
	// The view_campaign_timeline has everything we need for the session structure
	const { data: timelineData, error } = await supabase
		.from('view_campaign_timeline')
		.select('*')
		.eq('session_id', id)
		.single();

	if (error) throw error;

	// 2. Fetch Direct Session Relationships (not event-tied)
	// We still need the generic relationships for the sidebar
	const { data: directRels } = await supabase
		.from('entity_relationships')
		.select(`target:entities!to_entity_id ( id, name, type ), relationship_type`)
		.eq('from_entity_id', id);

	const sessionRelationships = (directRels || []).map((rel) => ({
		entity_id: rel.target.id,
		entity_name: rel.target.name,
		entity_type: rel.target.type,
		type: rel.relationship_type,
	}));

	// 3. Transform Event Tags to Mention Map
	// The view returns events with 'tags'. We need to flatten this for the UI.
	const eventRelMap = new Map();
	(timelineData.events || []).forEach((event) => {
		if (event.tags && event.tags.length > 0) {
			eventRelMap.set(
				event.id,
				event.tags.map((tag) => ({
					entity_id: tag.entity_id,
					entity_name: tag.name,
					entity_type: tag.type,
					type: 'mention',
				}))
			);
		}
	});

	return {
		data: {
			id: timelineData.session_id,
			title: timelineData.session_title,
			narrative: timelineData.session_narrative,
			events: timelineData.events, // Pre-sorted and aggregated
			attributes: {
				session_number: timelineData.session_number,
				session_date: timelineData.session_date,
			},
		},
		type: 'session',
		additional: { eventRelMap, sessionRelationships },
	};
};

const fetchEncounterWikiEntry = async (id, entityData) => {
	// OPTIMIZATION: Use the Hydrated View
	const { data: actions, error } = await supabase
		.from('view_encounter_actions_hydrated')
		.select('*')
		.eq('encounter_id', id)
		.order('round_number', { ascending: true })
		.order('action_order', { ascending: true });

	if (error) console.error('Encounter Actions Fetch Error:', error);

	return {
		data: entityData,
		type: 'encounter',
		additional: { encounterActions: actions || [] },
	};
};

const fetchQuestWikiEntry = async (id, entityData) => {
	// OPTIMIZATION: Single query with nested select for Session Attributes
	const { data: objectives, error } = await supabase
		.from('quest_objectives')
		.select(
			`
            *,
            session:sessions (
                id, 
                title,
                attributes
            )
        `
		)
		.eq('quest_id', id)
		.order('order_index', { ascending: true });

	if (error) console.error('Quest Objectives Error:', error);

	// Client-side cleanup: Extract session_number from JSONB
	const processedObjectives = (objectives || []).map((obj) => {
		if (obj.session) {
			const attrs = obj.session.attributes || {};
			obj.session.session_number = attrs.session_number || attrs.session;
		}
		return obj;
	});

	return {
		data: entityData,
		type: 'quest',
		additional: { objectives: processedObjectives },
	};
};

// Main Entry Point
export const getWikiEntry = async (id, type) => {
	// Strategy: Session is unique because it comes from a different base table/view
	if (type === 'session') {
		return fetchSessionWikiEntry(id);
	}

	// Standard Entities: Fetch Core Data first
	const { data, error } = await supabase.from('entity_complete_view').select('*').eq('id', id).single();
	if (error) throw error;

	// Strategy Pattern for Additional Data
	if (type === 'encounter') return fetchEncounterWikiEntry(id, data);
	if (type === 'quest') return fetchQuestWikiEntry(id, data);

	// Default
	return { data, type, additional: {} };
};

export const getTooltipData = async (id, type) => {
	if (type === 'session') {
		const { data } = await supabase.from('sessions').select('title, narrative').eq('id', id).single();
		return {
			name: data.title,
			type: 'session',
			description: data.narrative,
			attributes: {},
		};
	}

	// Lightweight fetch for tooltip
	const { data, error } = await supabase
		.from('entity_complete_view') // Could optimize to view_entity_index if attributes aren't needed
		.select('name, type, description, attributes')
		.eq('id', id)
		.single();

	if (error) throw error;
	return data;
};

const entityStrategies = {
	session: getSessions,
	quest: getCompleteEntities,
	default: getCompleteEntities,
	campaign: async () => getCampaigns(),
};

--- END OF domain\entity\api\entityService.js ---

--- FILE: domain\entity\components\EntityBadge.jsx ---
import { clsx } from 'clsx';
import { getEntityLabel } from '@/domain/entity/config/entityTypes';
import { getEntityStyles } from '@/domain/entity/config/entityStyles';

/**
 * EntityBadge Component
 * Displays a colored type badge for an entity
 *
 * @param {string} type - Entity type
 * @param {string} label - Optional custom label (defaults to type label)
 * @param {string} size - Badge size: 'sm', 'md', 'lg' (default 'md')
 * @param {string} variant - Style variant: 'solid', 'outline', 'subtle' (default 'solid')
 * @param {string} className - Additional CSS classes
 */
export default function EntityBadge({ type, label = null, size = 'md', variant = 'solid', className = '', ...props }) {
	const styles = getEntityStyles(type);
	const displayLabel = label || getEntityLabel(type);

	const sizeClasses = {
		sm: 'text-[9px] px-1.5 py-0.5',
		md: 'text-[10px] px-2 py-0.5',
		lg: 'text-xs px-2.5 py-1',
	};

	const variantClasses = {
		solid: clsx(styles.bg, styles.text, styles.border, 'border'),
		outline: clsx('bg-transparent', styles.text, styles.border, 'border'),
		subtle: clsx(styles.bg, styles.text, 'border-transparent border'),
	};

	return (
		<span
			className={clsx(
				'inline-flex items-center font-bold uppercase tracking-wider rounded shrink-0',
				sizeClasses[size],
				variantClasses[variant],
				className
			)}
			{...props}>
			{displayLabel}
		</span>
	);
}

--- END OF domain\entity\components\EntityBadge.jsx ---

--- FILE: domain\entity\components\EntityIcon.jsx ---
import { clsx } from 'clsx';
import { getEntityIcon } from '@/domain/entity/config/entityIcons';
import { getEntityStyles } from '@/domain/entity/config/entityStyles';

/**
 * EntityIcon Component
 * Renders an entity icon with optional custom image override
 * STRICTLY uses <span> to ensure hydration safety inside <p> tags.
 */
export default function EntityIcon({
	type,
	customIconUrl = null,
	size = 16,
	className = '',
	showBackground = false,
	inline = false,
	...props
}) {
	const Icon = getEntityIcon(type);
	const styles = getEntityStyles(type);

	// FIX: Always use 'span' to avoid "div descendant of p" hydration errors
	const Container = 'span';

	// 1. Custom Image Case
	if (customIconUrl) {
		return (
			<Container
				className={clsx(
					'inline-flex items-center justify-center overflow-hidden shrink-0 select-none bg-muted',
					showBackground && clsx('rounded-lg border', styles.bg, styles.border),
					className
				)}
				style={{ width: size, height: size }}
				{...props}>
				<img
					src={customIconUrl}
					alt=''
					className='w-full h-full object-cover'
					draggable={false}
					onError={(e) => {
						e.target.style.display = 'none';
						e.target.parentElement.classList.add('fallback-icon');
					}}
				/>
			</Container>
		);
	}

	// 2. Background/Frame Case
	if (showBackground) {
		return (
			<Container
				className={clsx(
					'inline-flex items-center justify-center rounded-lg border p-1.5 shrink-0 select-none',
					styles.bg,
					styles.border,
					styles.text,
					className
				)}
				style={{ width: size, height: size }}
				{...props}>
				<Icon size={size * 0.75} strokeWidth={2} />
			</Container>
		);
	}

	// 3. Simple Icon Case (SVG is safe in <p>)
	return <Icon size={size} className={clsx(styles.text, className)} strokeWidth={2} {...props} />;
}

--- END OF domain\entity\components\EntityIcon.jsx ---

--- FILE: domain\entity\components\EntityLink.jsx ---
import { useNavigate } from 'react-router-dom';
import { clsx } from 'clsx';
import { useTooltip } from '@/features/smart-tooltip/TooltipContext';
import { getEntityStyles } from '@/domain/entity/config/entityStyles';
import EntityIcon from './EntityIcon';

export default function EntityLink({
	id,
	type,
	children,
	customIconUrl = null,
	showIcon = true,
	className = '',
	inline = false,
	...props
}) {
	const navigate = useNavigate();
	const { openTooltip, closeTooltip } = useTooltip();
	const styles = getEntityStyles(type);

	const handleMouseEnter = (e) => {
		// Desktop only: Hover to open
		if (window.matchMedia('(hover: hover)').matches) {
			openTooltip(e, id, type);
		}
	};

	// FIX: Guard closeTooltip so mobile touch emulation doesn't auto-close it
	const handleMouseLeave = () => {
		if (window.matchMedia('(hover: hover)').matches) {
			closeTooltip();
		}
	};

	const handleClick = (e) => {
		e.preventDefault();

		if (window.matchMedia('(hover: hover)').matches) {
			// Desktop: Click to navigate
			navigate(`/wiki/${type}/${id}`);
			closeTooltip();
		} else {
			// Mobile: Tap to open tooltip (Sticky mode = true)
			openTooltip(e, id, type, true);
		}
	};

	const commonProps = {
		href: `/wiki/${type}/${id}`,
		onClick: handleClick,
		onMouseEnter: handleMouseEnter,
		onMouseLeave: handleMouseLeave, // Use the guarded handler
		...props,
	};

	if (inline) {
		return (
			<a
				className={clsx(
					'inline-flex items-center gap-1.5 font-semibold no-underline transition-colors',
					'border-b border-dashed border-transparent hover:border-current cursor-pointer align-middle',
					styles.text,
					styles.hover,
					className
				)}
				{...commonProps}>
				{showIcon && (
					<EntityIcon
						type={type}
						customIconUrl={customIconUrl}
						size={14}
						inline={true}
						className='self-center rounded-full'
					/>
				)}
				{children}
			</a>
		);
	}

	return (
		<a
			className={clsx(
				'flex items-center gap-2 px-3 py-2 rounded-lg transition-all cursor-pointer',
				'hover:shadow-sm',
				styles.bg,
				styles.hover,
				styles.border,
				'border',
				className
			)}
			{...commonProps}>
			{showIcon && <EntityIcon type={type} customIconUrl={customIconUrl} size={18} inline={false} />}
			<span className={clsx('font-semibold text-sm', styles.text)}>{children}</span>
		</a>
	);
}

--- END OF domain\entity\components\EntityLink.jsx ---

--- FILE: domain\entity\components\EntityStatusIcon.jsx ---
import { clsx } from 'clsx';
import { getStatusIcon } from '@/domain/entity/utils/statusUtils';

/**
 * EntityStatusIcon Component
 * Smart status indicator based on entity type and status/affinity
 *
 * @param {Object} entity - Entity object with type and status/affinity
 * @param {number} size - Icon size (default 12)
 * @param {string} className - Additional CSS classes
 */
export default function EntityStatusIcon({ entity, size = 12, className = '', ...props }) {
	if (!entity) return null;

	// Determine which status to show (affinity takes priority for NPCs/factions)
	const statusValue = entity.affinity || entity.status;
	if (!statusValue || statusValue === 'unknown') return null;

	const { Icon, className: statusClass } = getStatusIcon(statusValue, entity.type);

	return <Icon size={size} className={clsx(statusClass, className)} strokeWidth={2.5} {...props} />;
}

/**
 * EntityStatusBadge Component
 * Status indicator with text label
 *
 * @param {Object} entity - Entity object
 * @param {string} className - Additional CSS classes
 */
export function EntityStatusBadge({ entity, className = '', ...props }) {
	if (!entity) return null;

	const statusValue = entity.affinity || entity.status;
	if (!statusValue || statusValue === 'unknown') return null;

	const { Icon, className: statusClass } = getStatusIcon(statusValue, entity.type);

	return (
		<span
			className={clsx('inline-flex items-center gap-1.5 text-xs font-semibold px-2 py-1 rounded-md border', className)}
			{...props}>
			<Icon size={12} className={statusClass} strokeWidth={2.5} />
			<span className='capitalize'>{statusValue}</span>
		</span>
	);
}

--- END OF domain\entity\components\EntityStatusIcon.jsx ---

--- FILE: domain\entity\config\entityColors.js ---
/**
 * Entity Color Palettes
 * Hex colors for each entity type
 */

import { ENTITY_TYPES } from './entityTypes';

/**
 * Primary color for each entity type (hex)
 */
export const ENTITY_COLORS = {
	[ENTITY_TYPES.SESSION]: '#64748b', // slate-500
	[ENTITY_TYPES.CHARACTER]: '#ef4444', // red-500
	[ENTITY_TYPES.NPC]: '#d97706', // amber-600
	[ENTITY_TYPES.LOCATION]: '#10b981', // emerald-500
	[ENTITY_TYPES.QUEST]: '#3b82f6', // blue-500
	[ENTITY_TYPES.FACTION]: '#a855f7', // purple-500
	[ENTITY_TYPES.ENCOUNTER]: '#f97316', // orange-500
	[ENTITY_TYPES.ITEM]: '#06b6d4', // cyan-500
	[ENTITY_TYPES.DEFAULT]: '#6b7280', // gray-500
};

/**
 * Get primary color for entity type
 * @param {string} type - Entity type
 * @returns {string} Hex color
 */
export const getEntityColor = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	return ENTITY_COLORS[normalized] || ENTITY_COLORS[ENTITY_TYPES.DEFAULT];
};

/**
 * Extended color palette for each type (for future use)
 * Includes lighter/darker shades
 */
export const ENTITY_COLOR_PALETTES = {
	[ENTITY_TYPES.SESSION]: {
		50: '#f8fafc',
		100: '#f1f5f9',
		500: '#64748b',
		700: '#334155',
		900: '#0f172a',
	},
	[ENTITY_TYPES.CHARACTER]: {
		50: '#fef2f2',
		100: '#fee2e2',
		500: '#ef4444',
		700: '#b91c1c',
		900: '#7f1d1d',
	},
	[ENTITY_TYPES.NPC]: {
		50: '#fffbeb',
		100: '#fef3c7',
		500: '#d97706',
		700: '#a16207',
		900: '#78350f',
	},
	[ENTITY_TYPES.LOCATION]: {
		50: '#ecfdf5',
		100: '#d1fae5',
		500: '#10b981',
		700: '#047857',
		900: '#064e3b',
	},
	[ENTITY_TYPES.QUEST]: {
		50: '#eff6ff',
		100: '#dbeafe',
		500: '#3b82f6',
		700: '#1d4ed8',
		900: '#1e3a8a',
	},
	[ENTITY_TYPES.FACTION]: {
		50: '#faf5ff',
		100: '#f3e8ff',
		500: '#a855f7',
		700: '#7e22ce',
		900: '#581c87',
	},
	[ENTITY_TYPES.ENCOUNTER]: {
		50: '#fff7ed',
		100: '#ffedd5',
		500: '#f97316',
		700: '#c2410c',
		900: '#7c2d12',
	},
	[ENTITY_TYPES.ITEM]: {
		// <--- ADDED
		50: '#ecfeff',
		100: '#cffafe',
		500: '#06b6d4',
		700: '#0e7490',
		900: '#164e63',
	},
	[ENTITY_TYPES.DEFAULT]: {
		50: '#f9fafb',
		100: '#f3f4f6',
		500: '#6b7280',
		700: '#374151',
		900: '#111827',
	},
};

/**
 * Get color palette for entity type
 * @param {string} type - Entity type
 * @returns {Object} Color palette
 */
export const getEntityPalette = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	return ENTITY_COLOR_PALETTES[normalized] || ENTITY_COLOR_PALETTES[ENTITY_TYPES.DEFAULT];
};

--- END OF domain\entity\config\entityColors.js ---

--- FILE: domain\entity\config\entityConfig.js ---
/**
 * Entity Configuration Orchestrator
 * Combines all entity config modules into a unified API
 * This replaces the old monolithic entityConfig.jsx
 */

import { ENTITY_TYPES, getEntityLabel } from './entityTypes';
import { getEntityIcon } from './entityIcons';
import { getEntityColor, getEntityPalette } from './entityColors';
import { getEntityStyles, getEntityPreset, buildEntityClassName } from './entityStyles';

/**
 * Get complete configuration for an entity type
 * @param {string} type - Entity type
 * @returns {Object} Complete entity config
 */
export const getEntityConfig = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;

	return {
		type: normalized,
		label: getEntityLabel(normalized),
		labelPlural: getEntityLabel(normalized, true),
		icon: getEntityIcon(normalized),
		color: getEntityColor(normalized),
		palette: getEntityPalette(normalized),
		tailwind: getEntityStyles(normalized),
	};
};

/**
 * LEGACY EXPORT: Full config map for backwards compatibility
 * TODO: Gradually migrate consumers to use getEntityConfig() instead
 */
export const ENTITY_CONFIG = Object.values(ENTITY_TYPES).reduce((acc, type) => {
	acc[type] = getEntityConfig(type);
	return acc;
}, {});

// Re-export everything for convenience
export { ENTITY_TYPES, getEntityLabel } from './entityTypes';
export { getEntityIcon } from './entityIcons';
export { getEntityColor, getEntityPalette } from './entityColors';
export { getEntityStyles, getEntityPreset, buildEntityClassName } from './entityStyles';

--- END OF domain\entity\config\entityConfig.js ---

--- FILE: domain\entity\config\entityIcons.js ---
import {
	User,
	MapPin,
	Scroll,
	Sword,
	Flag,
	Crown,
	BookOpen,
	Calendar,
	Trees,
	Castle,
	Ship,
	Landmark,
	Globe,
	Home,
	Mountain,
	Gem,
} from 'lucide-react';
import { ENTITY_TYPES } from './entityTypes';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

export const ENTITY_ICONS = {
	[ENTITY_TYPES.SESSION]: Calendar,
	[ENTITY_TYPES.CHARACTER]: User,
	[ENTITY_TYPES.NPC]: Crown,
	[ENTITY_TYPES.LOCATION]: MapPin,
	[ENTITY_TYPES.QUEST]: Scroll,
	[ENTITY_TYPES.FACTION]: Flag,
	[ENTITY_TYPES.ENCOUNTER]: Sword,
	[ENTITY_TYPES.ITEM]: Gem,
	[ENTITY_TYPES.DEFAULT]: BookOpen,
};

// Location specific mappings
const LOCATION_TYPE_ICONS = {
	building: Home,
	ship: Ship,
	landmark: Landmark,
	dungeon: Mountain,
	cave: Mountain,
	region: MapPin,
	city: Castle,
	forest: Trees,
	realm: Globe,
};

export const getEntityIcon = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	return ENTITY_ICONS[normalized] || ENTITY_ICONS[ENTITY_TYPES.DEFAULT];
};

/**
 * Advanced resolution that looks at attributes for finer detail
 */
export const resolveEntityIcon = (entity) => {
	const type = entity.type?.toLowerCase();

	if (type === 'location') {
		const locType = getAttributeValue(entity.attributes, 'type')?.toLowerCase();
		return LOCATION_TYPE_ICONS[locType] || ENTITY_ICONS.location;
	}

	return getEntityIcon(type);
};

--- END OF domain\entity\config\entityIcons.js ---

--- FILE: domain\entity\config\entityStyles.js ---
import { ENTITY_TYPES } from './entityTypes';

/**
 * Tailwind class maps
 * CHANGED: Replaced 'slate' with 'muted-foreground' or 'foreground' to respect the active theme.
 */
const ENTITY_TAILWIND_CLASSES = {
	[ENTITY_TYPES.SESSION]: {
		text: 'text-[var(--entity-session,theme(colors.slate.500))] font-medium',
		bg: 'bg-muted/50',
		border: 'border-border',
		hover: 'hover:bg-muted',
	},
	[ENTITY_TYPES.CHARACTER]: {
		text: 'text-[var(--entity-character,theme(colors.red.500))]',
		bg: 'bg-red-500/10',
		border: 'border-red-500/20',
		hover: 'hover:bg-red-500/10',
	},
	[ENTITY_TYPES.NPC]: {
		text: 'text-[var(--entity-npc,theme(colors.amber.500))]',
		bg: 'bg-amber-500/10',
		border: 'border-amber-500/20',
		hover: 'hover:bg-amber-500/10',
	},
	[ENTITY_TYPES.LOCATION]: {
		text: 'text-[var(--entity-location,theme(colors.emerald.500))]', // Will use moss green on D&D theme
		bg: 'bg-emerald-500/10',
		border: 'border-emerald-500/20',
		hover: 'hover:bg-emerald-500/10',
	},
	[ENTITY_TYPES.QUEST]: {
		text: 'text-[var(--entity-quest,theme(colors.blue.500))]',
		bg: 'bg-blue-500/10',
		border: 'border-blue-500/20',
		hover: 'hover:bg-blue-500/10',
	},
	[ENTITY_TYPES.FACTION]: {
		text: 'text-[var(--entity-faction,theme(colors.purple.500))]',
		bg: 'bg-purple-500/10',
		border: 'border-purple-500/20',
		hover: 'hover:bg-purple-500/10',
	},
	[ENTITY_TYPES.ENCOUNTER]: {
		text: 'text-[var(--entity-encounter,theme(colors.orange.500))]',
		bg: 'bg-orange-500/10',
		border: 'border-orange-500/20',
		hover: 'hover:bg-orange-500/10',
	},
	[ENTITY_TYPES.ITEM]: {
		text: 'text-[var(--entity-item,theme(colors.cyan.600))] dark:text-[var(--entity-item,theme(colors.cyan.400))]',
		bg: 'bg-cyan-500/10',
		border: 'border-cyan-500/20',
		hover: 'hover:bg-cyan-500/10',
	},
	[ENTITY_TYPES.DEFAULT]: {
		text: 'text-muted-foreground',
		bg: 'bg-muted',
		border: 'border-border',
		hover: 'hover:bg-muted/80',
	},
};

export const getEntityStyles = (type) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	return ENTITY_TAILWIND_CLASSES[normalized] || ENTITY_TAILWIND_CLASSES[ENTITY_TYPES.DEFAULT];
};

export const buildEntityClassName = (type, variants = [], additional = '') => {
	const styles = getEntityStyles(type);
	const variantList = Array.isArray(variants) ? variants : [variants];
	const classes = variantList
		.map((variant) => styles[variant])
		.filter(Boolean)
		.join(' ');
	return additional ? `${classes} ${additional}` : classes;
};

// Priority Badges - Using semantic opacity for better dark/light compatibility
export const getPriorityStyles = (priority) => {
	const p = priority?.toLowerCase() || '';
	if (p.includes('high') || p.includes('urgent') || p.includes('critical')) {
		return 'border-orange-500/30 text-orange-700 dark:text-orange-400 bg-orange-500/10';
	}
	if (p.includes('medium') || p.includes('normal')) {
		return 'border-blue-500/30 text-blue-700 dark:text-blue-400 bg-blue-500/10';
	}
	if (p.includes('low')) {
		return 'border-border text-muted-foreground bg-muted/50';
	}
	return 'border-border text-muted-foreground bg-muted/30';
};

export const ENTITY_CLASS_PRESETS = {
	iconBadge: (type) => {
		const styles = getEntityStyles(type);
		return `${styles.bg} ${styles.border} ${styles.text} rounded-lg p-2 border`;
	},
	typeBadge: (type) => {
		const styles = getEntityStyles(type);
		return `${styles.bg} ${styles.text} ${styles.border} text-xs font-bold uppercase tracking-wider px-2 py-0.5 rounded border`;
	},
	card: (type) => {
		const styles = getEntityStyles(type);
		// Force bg-card to ensure cards are readable on all themes
		return `bg-card border-border border rounded-lg p-4 ${styles.hover} transition-colors`;
	},
	link: (type) => {
		const styles = getEntityStyles(type);
		return `${styles.text} transition-colors font-semibold hover:underline`;
	},
};

export const getEntityPreset = (preset, type) => {
	const presetFn = ENTITY_CLASS_PRESETS[preset];
	return presetFn ? presetFn(type) : '';
};

--- END OF domain\entity\config\entityStyles.js ---

--- FILE: domain\entity\config\entityTypes.js ---
/**
 * Entity Type Definitions
 * Central source of truth for entity types
 */

/**
 * All valid entity types in the system
 */
export const ENTITY_TYPES = {
	SESSION: 'session',
	CHARACTER: 'character',
	NPC: 'npc',
	LOCATION: 'location',
	QUEST: 'quest',
	FACTION: 'faction',
	ENCOUNTER: 'encounter',
	ITEM: 'item',
	DEFAULT: 'default',
};

/**
 * Entity type labels (for display)
 */
export const ENTITY_LABELS = {
	[ENTITY_TYPES.SESSION]: 'Session',
	[ENTITY_TYPES.CHARACTER]: 'Character',
	[ENTITY_TYPES.NPC]: 'NPC',
	[ENTITY_TYPES.LOCATION]: 'Location',
	[ENTITY_TYPES.QUEST]: 'Quest',
	[ENTITY_TYPES.FACTION]: 'Faction',
	[ENTITY_TYPES.ENCOUNTER]: 'Encounter',
	[ENTITY_TYPES.ITEM]: 'Item',
	[ENTITY_TYPES.DEFAULT]: 'Entity',
};

/**
 * Pluralized entity labels (for navigation, headers)
 */
export const ENTITY_LABELS_PLURAL = {
	[ENTITY_TYPES.SESSION]: 'Sessions',
	[ENTITY_TYPES.CHARACTER]: 'Characters',
	[ENTITY_TYPES.NPC]: 'NPCs',
	[ENTITY_TYPES.LOCATION]: 'Locations',
	[ENTITY_TYPES.QUEST]: 'Quests',
	[ENTITY_TYPES.FACTION]: 'Factions',
	[ENTITY_TYPES.ENCOUNTER]: 'Encounters',
	[ENTITY_TYPES.ITEM]: 'Items',
	[ENTITY_TYPES.DEFAULT]: 'Entities',
};

/**
 * Get label for entity type
 * @param {string} type - Entity type
 * @param {boolean} plural - Return plural form
 * @returns {string}
 */
export const getEntityLabel = (type, plural = false) => {
	const normalized = type?.toLowerCase() || ENTITY_TYPES.DEFAULT;
	const labels = plural ? ENTITY_LABELS_PLURAL : ENTITY_LABELS;
	return labels[normalized] || labels[ENTITY_TYPES.DEFAULT];
};

--- END OF domain\entity\config\entityTypes.js ---

--- FILE: domain\entity\utils\attributeParser.js ---
/**
 * Attribute Parsing Utilities
 * Safe parsing and extraction of entity attributes
 */

/**
 * Parse attributes safely from JSON string, Object, or DB Row Array
 * @param {string|Object|Array} attrs - Raw attributes
 * @returns {Object} Parsed attributes object { key: value }
 */
export const parseAttributes = (attrs) => {
	if (!attrs) return {};

	// 1. Handle JSON String
	if (typeof attrs === 'string') {
		try {
			return JSON.parse(attrs);
		} catch {
			console.warn('Failed to parse attributes string:', attrs);
			return {};
		}
	}

	// 2. Handle DB Row Array: [{ name: 'icon', value: '...' }, ...]
	// This is common when joining tables (e.g. encounter_actions -> actor -> attributes)
	if (Array.isArray(attrs)) {
		// Check if it looks like a Name/Value pair list
		if (attrs.length > 0 && 'name' in attrs[0] && 'value' in attrs[0]) {
			return attrs.reduce((acc, curr) => {
				if (curr.name) acc[curr.name] = curr.value;
				return acc;
			}, {});
		}
		// Otherwise return as-is (might be a simple list attribute value)
		return {};
	}

	// 3. Already an Object
	return attrs;
};

// ... (Keep getAttributeValue and rest of file exactly as is) ...
export const getAttributeValue = (attributes, keys) => {
	if (!attributes) return null;

	// Normalize keys to array
	const keyList = Array.isArray(keys) ? keys : [keys];

	for (const key of keyList) {
		// Try exact match
		let val = attributes[key];

		// Try lowercase match
		if (!val) {
			val = attributes[key.toLowerCase()];
		}

		// Try capitalized match
		if (!val) {
			val = attributes[key.charAt(0).toUpperCase() + key.slice(1)];
		}

		if (!val) continue;

		// Unwrap nested structures
		if (typeof val === 'string') return val;
		if (Array.isArray(val) && val[0]?.value) return val[0].value;
		if (Array.isArray(val) && val[0]) return String(val[0]);
		if (typeof val === 'object' && val.value) return val.value;

		// Fallback: stringify
		return String(val);
	}

	return null;
};

// ... (Keep rest of file) ...
export const parseAttributeValue = (val, key) => {
	if (val === null || val === undefined) return null;

	// 1. Already an array - clean it
	if (Array.isArray(val)) {
		return val.map((item) => (typeof item === 'object' && item.value ? item.value : item));
	}

	// 2. Check if this should be a list based on key name
	const listKeys = ['feature', 'features', 'traits', 'inventory', 'loot', 'spells'];
	if (typeof val === 'string' && listKeys.includes(key?.toLowerCase())) {
		return val
			.split(',')
			.map((s) => s.trim())
			.filter(Boolean);
	}

	// 3. Unwrap objects
	if (typeof val === 'object' && val.value) {
		return val.value;
	}

	// 4. Return as string
	return String(val);
};

export const parseAbilityScores = (val) => {
	if (!val || typeof val !== 'string') return [];

	return val.split(',').map((s) => {
		const parts = s.trim().split(' ');
		const name = parts[0];
		const score = parts.find((p) => /^\d+$/.test(p)) || '';
		const mod = parts.find((p) => p.includes('('))?.replace(/[()]/g, '') || '';

		return { name, score, mod };
	});
};

export const parseTagList = (val) => {
	if (!val) return [];
	if (Array.isArray(val)) return val.map(String);

	return String(val)
		.split(',')
		.map((s) => s.trim())
		.filter(Boolean);
};

export const isIgnoredAttribute = (key) => {
	const ignoredKeys = [
		'image',
		'portrait',
		'icon',
		'token',
		'session',
		'date',
		'summary',
		'background_image',
		'background',
		'is_active',
		'map_image',
		'map_markers',
		'aliases',
	];

	return ignoredKeys.includes(key.toLowerCase());
};

export const isNarrativeAttribute = (key) => {
	const narrativeKeys = [
		'background',
		'personality',
		'history',
		'bio',
		'biography',
		'goals',
		'ideals',
		'bonds',
		'flaws',
		'notes',
		'gm notes',
		'description',
		'appearance',
		'tactics',
		'narrative',
	];

	return narrativeKeys.includes(key.toLowerCase());
};

export const isListAttribute = (key) => {
	const listKeys = ['feature', 'features', 'traits', 'inventory', 'loot', 'spells'];
	return listKeys.includes(key.toLowerCase());
};

export const getAttributeDisplayType = (key, value) => {
	const normalizedKey = key.toLowerCase();

	// Special widgets
	if (['abilities', 'stats'].includes(normalizedKey)) {
		return 'stat-grid';
	}

	if (['ability score', 'saving throw', 'saves', 'skills', 'languages', 'proficiencies'].includes(normalizedKey)) {
		return 'tags';
	}

	// Force list display
	if (isListAttribute(key) && Array.isArray(value)) {
		return 'list';
	}

	// Narrative text
	if (isNarrativeAttribute(key)) {
		return 'narrative';
	}

	// Long text becomes narrative
	if (typeof value === 'string' && value.length > 100) {
		return 'narrative';
	}

	// Default
	return 'text';
};

--- END OF domain\entity\utils\attributeParser.js ---

--- FILE: domain\entity\utils\entityUtils.js ---
/**
 * Entity Type Utilities
 * Pure functions for entity type checking and normalization
 */

/**
 * Normalize entity type string
 * @param {string} type - Raw type string
 * @returns {string} Normalized type
 */
export const normalizeEntityType = (type) => {
	if (!type) return 'default';
	const normalized = type.toLowerCase().trim();
	// Handle plurals
	return normalized === 'sessions' ? 'session' : normalized;
};

/**
 * Check if entity type is a specific value
 * @param {Object} entity - Entity object
 * @param {string} type - Type to check
 * @returns {boolean}
 */
export const isEntityType = (entity, type) => {
	return normalizeEntityType(entity?.type) === normalizeEntityType(type);
};

/**
 * Check if entity is a session
 */
export const isSession = (entity) => isEntityType(entity, 'session');

/**
 * Check if entity is a quest
 */
export const isQuest = (entity) => isEntityType(entity, 'quest');

/**
 * Check if entity is an NPC
 */
export const isNPC = (entity) => isEntityType(entity, 'npc');

/**
 * Check if entity is a location
 */
export const isLocation = (entity) => isEntityType(entity, 'location');

/**
 * Check if entity type should show status icons
 * @param {string} type - Entity type
 * @returns {boolean}
 */
export const shouldShowStatus = (type) => {
	const normalized = normalizeEntityType(type);
	return ['npc', 'faction', 'quest'].includes(normalized);
};

/**
 * Get entity display name
 * Handles different name fields across entity types
 * @param {Object} entity - Entity object
 * @returns {string}
 */
export const getEntityName = (entity) => {
	if (!entity) return 'Unknown';

	// Sessions use 'title'
	if (isSession(entity)) {
		return entity.title || entity.name || 'Untitled Session';
	}

	// Quests use 'title'
	if (isQuest(entity)) {
		return entity.title || entity.name || 'Untitled Quest';
	}

	// Everyone else uses 'name'
	return entity.name || 'Unnamed';
};

/**
 * Get entity description
 * Handles different description fields
 * @param {Object} entity - Entity object
 * @returns {string|null}
 */
export const getEntityDescription = (entity) => {
	if (!entity) return null;

	// Try description first
	if (entity.description) return entity.description;

	// Sessions might use summary
	if (isSession(entity)) {
		return entity?.summary || entity.narrative || null;
	}

	// Characters might use background
	if (isEntityType(entity, 'character')) {
		return entity.background || entity.short_description || null;
	}

	return null;
};

/**
 * Get entity icon initial (first letter)
 * @param {Object} entity - Entity object
 * @returns {string}
 */
export const getEntityInitial = (entity) => {
	const name = getEntityName(entity);
	return (name[0] || 'E').toUpperCase();
};

/**
 * Check if entity is marked as dead/inactive
 * @param {Object} entity - Entity object
 * @returns {boolean}
 */
export const isEntityDead = (entity) => {
	const status = entity.status?.toLowerCase();
	return status === 'dead' || status === 'deceased' || status === 'inactive';
};

/**
 * Check if entity/quest is completed
 * @param {Object} entity - Entity object
 * @returns {boolean}
 */
export const isEntityCompleted = (entity) => {
	const status = entity.status?.toLowerCase();
	return ['completed', 'finished', 'done', 'success'].some((k) => status?.includes(k));
};

/**
 * Check if entity/quest has failed
 * @param {Object} entity - Entity object
 * @returns {boolean}
 */
export const isEntityFailed = (entity) => {
	const status = entity.status?.toLowerCase();
	return ['failed', 'failure', 'abandoned'].some((k) => status?.includes(k));
};

/**
 * Determine the parent ID of an entity based on its relationships.
 * Prioritizes explicit parent relationships, then location containers.
 * @param {Object} entity - Entity object with relationships array
 * @returns {string|null} ID of the parent entity
 */
export const getParentId = (entity) => {
	const relationships = entity.relationships;
	if (!relationships || !Array.isArray(relationships)) return null;

	// 1. Check for explicit parent (Location hierarchy: Location -> Parent Location)
	const parentRel = relationships.find(
		(r) =>
			(r.type === 'parent_location' || r.type === 'parent') && (r.direction === 'outgoing' || r.direction === undefined)
	);
	if (parentRel) return parentRel.entity_id;

	// 2. Check for location link (NPC hierarchy: NPC -> Location)
	if (entity.type === 'npc' || entity.type === 'encounter') {
		// Get ALL relationships to locations
		const locationRels = relationships.filter((r) => r.entity_type === 'location');

		if (locationRels.length > 0) {
			// Priority 1: Look for specific semantic types
			const primary = locationRels.find((r) =>
				['location', 'located_in', 'base', 'home', 'residence', 'origin', 'occurred_at'].includes(r.type?.toLowerCase())
			);

			// Priority 2: Fallback to the first location found (e.g. generic 'related')
			return primary ? primary.entity_id : locationRels[0].entity_id;
		}
	}

	return null;
};

--- END OF domain\entity\utils\entityUtils.js ---

--- FILE: domain\entity\utils\statusUtils.js ---
import { Sword, Shield, Circle, HelpCircle, CheckCircle2, XCircle, Clock } from 'lucide-react';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

/**
 * Rank definitions for sorting.
 * Lower number = Higher priority in lists.
 */
const AFFINITY_RANKS = {
	// Rank 1: Allies
	ally: 1,
	allies: 1,
	friend: 1,
	friendly: 1,
	helpful: 1,
	allied: 1,
	alliance: 1,
	aligned: 1,
	// Rank 2: Neutral
	neutral: 2,
	indifferent: 2,
	unknown: 2, // 'Unknown' faction status often implies neutral
	// Rank 3: Enemies
	enemy: 3,
	enemies: 3,
	hostile: 3,
	rival: 3,
	villain: 3,
	threat: 3,
	// Rank 99: Fallback
	other: 99,
};

/**
 * Calculate a numeric rank for an entity based on status/affinity string.
 * Used for sorting: Allies -> Neutral -> Enemies -> Unknown
 *
 * @param {string} statusOrAffinity
 * @returns {number} 1, 2, 3, or 99
 */
export const getAffinityRank = (statusOrAffinity) => {
	const key = (statusOrAffinity || '').toLowerCase();

	// Check for exact matches or substring matches
	for (const [term, rank] of Object.entries(AFFINITY_RANKS)) {
		if (key.includes(term)) return rank;
	}

	return 99;
};

/**
 * Get status icon based on entity type and status
 */
export const getStatusIcon = (status, type) => {
	const s = status?.toLowerCase() || 'unknown';

	// Quest-specific icons
	if (type === 'quest') {
		if (['active', 'in progress', 'started'].some((k) => s.includes(k))) {
			return { Icon: Circle, className: 'text-amber-500 fill-amber-500/20' };
		}
		if (['completed', 'finished', 'done', 'success'].some((k) => s.includes(k))) {
			return { Icon: CheckCircle2, className: 'text-emerald-600' };
		}
		if (['failed', 'failure'].some((k) => s.includes(k))) {
			return { Icon: XCircle, className: 'text-red-500' };
		}
		if (['abandoned', 'on-hold', 'paused'].some((k) => s.includes(k))) {
			return { Icon: Clock, className: 'text-slate-400' };
		}
		return { Icon: Circle, className: 'text-slate-300' };
	}

	// NPC/Faction affinity icons
	const rank = getAffinityRank(s);

	if (rank === 3) {
		// Enemy
		return { Icon: Sword, className: 'text-red-500 fill-red-500/10' };
	}
	if (rank === 1) {
		// Ally
		return { Icon: Shield, className: 'text-emerald-500 fill-emerald-500/10' };
	}
	// Neutral / Unknown
	return { Icon: Circle, className: 'text-muted-foreground/70' };
};

export const getStatusInfo = (entity) => {
	const statusRaw = entity.status || getAttributeValue(entity.attributes, ['status']);
	const affinityRaw = getAttributeValue(entity.attributes, ['affinity']);

	const displayStatus = affinityRaw && affinityRaw !== 'unknown' ? affinityRaw : statusRaw;
	const statusLower = displayStatus?.toLowerCase();

	return {
		raw: statusRaw,
		display: displayStatus,
		icon: getStatusIcon(displayStatus, entity.type),
		rank: getAffinityRank(displayStatus),
		isDead: statusLower === 'dead',
		isFailed: statusLower === 'failed',
		isCompleted: ['completed', 'finished', 'done', 'success'].some((k) => statusLower?.includes(k)),
	};
};

--- END OF domain\entity\utils\statusUtils.js ---

