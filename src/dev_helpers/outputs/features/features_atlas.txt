================================================================
PARTIAL BUNDLE: FEATURES ATLAS
================================================================

### PROJECT MAP (FILE STRUCTURE)
./
  main.jsx
  todo.md
  app/
    App.jsx
    AppRoutes.jsx
    components/
      RouteLoading.jsx
    styles/
      global.css
  domain/
    entity/
      api/
        entityService.js
      components/
        EntityBadge.jsx
        EntityIcon.jsx
        EntityLink.jsx
        EntityStatusIcon.jsx
      config/
        entityColors.js
        entityConfig.js
        entityIcons.js
        entityStyles.js
        entityTypes.js
      utils/
        attributeParser.js
        entityUtils.js
        statusUtils.js
  features/
    admin/
      api/
        adminService.js
      components/
        AdminForm.jsx
        AdminFormStyles.js
        EncounterManager.jsx
        EntitySearch.jsx
        EventTagger.jsx
        ImageLibraryModal.jsx
        MarkdownEditor.jsx
        MarkdownEditorImpl.jsx
        QuestObjectiveManager.jsx
        RelationshipManager.jsx
        SessionEventManager.jsx
        SmartImageInput.jsx
        TacticalMapManager.jsx
      config/
        adminStrategies.js
        imageLibrary.js
        imageManifest.json
      layouts/
        AdminLayout.jsx
      pages/
        BulkReplaceTool.jsx
        EntityEditorPage.jsx
        EntityListPage.jsx
        SplitPaneManager.jsx
    atlas/
      MapPage.jsx
      useMapData.js
      components/
        AtlasSidebar.jsx
        MapCanvas.jsx
        MapTools.jsx
        useMapCanvasViewModel.js
        __MapLayerControl.jsx
        layers/
          MapAreas.jsx
          MapMarkers.jsx
          MapOverlays.jsx
          MapRecaps.jsx
      config/
        mapConfig.js
      data/
        modularize.js
        refactor.js
      utils/
        mapNavigation.js
        markerUtils.js
    campaign/
      CampaignContext.jsx
      useCampaignPersistence.js
      useCampaignSelection.js
      api/
        campaignService.js
      components/
        CampaignCard.jsx
        CampaignSelect.jsx
    dashboard/
      DashboardPage.jsx
      api/
        dashboardService.js
      components/
        ActiveThreads.jsx
        ArchiveTree.jsx
        CampaignHeader.jsx
        CurrentArcMetadata.jsx
        CurrentStoryStack.jsx
        InsightsGrid.jsx
        PartyWidget.jsx
        QuickInsights.jsx
    graph/
      GraphPage.jsx
      useGraphView.js
      api/
        graphService.js
      components/
        CytoscapeCanvas.jsx
        GraphLegend.jsx
      config/
        graphStyles.js
      utils/
        graphMapper.js
    navigation/
      MainLayout.jsx
      useNavigation.js
      components/
        Sidebar.jsx
        SidebarFooter.jsx
        SidebarHeader.jsx
        SidebarNav.jsx
      config/
        navConfig.js
    search/
      GlobalSearch.jsx
      SearchContext.jsx
      useGlobalSearch.js
      api/
        searchService.js
      components/
        SearchFooter.jsx
        SearchModal.jsx
        SearchResultItem.jsx
        SearchResults.jsx
        SearchTrigger.jsx
      utils/
        searchMapper.js
    smart-text/
      SmartMarkdown.jsx
      useEntityIndex.js
      useSmartText.js
      components/
        EntityEmbed.jsx
        SmartEntityLink.jsx
    smart-tooltip/
      TooltipContainer.jsx
      TooltipContext.jsx
      useSmartPosition.js
      useTooltipState.js
      components/
        TooltipCard.jsx
    table-of-contents/
      TableOfContents.jsx
      components/
        TocItem.jsx
        TocMobileDrawer.jsx
      hooks/
        useTocObserver.js
        useTocScroll.js
    timeline/
      TimelinePage.jsx
      useTimelineView.js
      api/
        timelineService.js
      components/
        TimelineArcHeader.jsx
        TimelineEvent.jsx
        TimelineSession.jsx
      utils/
        eventStyles.js
    wiki/
      useEntityView.js
      useWikiNavigation.js
      WikiLayout.jsx
      api/
        wikiService.js
      components/
        EncounterTimeline.jsx
        EntityBody.jsx
        EntityHeader.jsx
        EntityHistory.jsx
        EntityMiniMap.jsx
        EntitySidebar.jsx
        QuestObjectives.jsx
        SessionMentions.jsx
        WikiEntryView.jsx
        character/
          CharacterSidebar.jsx
          CharacterStats.jsx
          RelationshipNetwork.jsx
        landing/
          EntityGridCard.jsx
          EntityPosterCard.jsx
          EntityTableGroup.jsx
          Swimlane.jsx
        navigation/
          SidebarEmptyState.jsx
          WikiSidebar.jsx
          WikiSidebarHeader.jsx
          WikiSidebarList.jsx
          sidebar/
            CollapsibleGroup.jsx
            EntityListItem.jsx
            PriorityIcon.jsx
            SidebarTreeItem.jsx
            StatusIcon.jsx
      config/
        groupingConfig.js
        viewStrategies.js
      hooks/
        useEntityContent.js
        useEntityFetching.js
        useEntityGrouping.js
        useEntityHeader.js
        useEntitySidebar.js
      layouts/
        CharacterLayout.jsx
        SessionLayout.jsx
        StandardLayout.jsx
      pages/
        WikiDetailPage.jsx
        WikiLandingPage.jsx
      utils/
        attributeMapper.js
        eventMapper.js
        relationshipMapper.js
        wikiEntryMapper.js
        wikiUtils.js
  shared/
    api/
      supabaseClient.js
    components/
      ErrorBoundary.jsx
      layout/
        CollapsibleSection.jsx
        SplitView.jsx
        TabContainer.jsx
      markdown/
        MarkdownRenderer.jsx
        MarkdownWithToC.jsx
      ui/
        Breadcrumbs.jsx
        Button.jsx
        Card.jsx
        DevAdminButton.jsx
        Drawer.jsx
        EmptyState.jsx
        HighlightBadge.jsx
        LoadingSpinner.jsx
        SectionDivider.jsx
    hooks/
      useBreadcrumbs.js
      useTheme.js
    utils/
      imageUtils.js
      markdownUtils.js
      textUtils.js
      theme/
        colorUtils.js
        cssUtils.js

================================================================
### SOURCE CODE
================================================================

--- FILE: features\atlas\MapPage.jsx ---
import { useMapData } from './useMapData';
import { MapCanvas } from './components/MapCanvas';
import LoadingSpinner from '@/shared/components/ui/LoadingSpinner';

export default function MapView() {
	const { data, navigateToMap, isLoading, currentMapKey } = useMapData();

	if (isLoading) {
		return (
			<div className='h-full flex items-center justify-center bg-[#1a1412]'>
				<LoadingSpinner text='Unrolling the parchment...' className='text-amber-500' />
			</div>
		);
	}

	return <MapCanvas data={data} onNavigate={navigateToMap} currentMapKey={currentMapKey} />;
}

--- END OF features\atlas\MapPage.jsx ---

--- FILE: features\atlas\useMapData.js ---
import { useSearchParams } from 'react-router-dom';
import { useMemo } from 'react';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { getMapConfig } from './utils/mapNavigation';

export function useMapData() {
	const { campaignData } = useCampaign();
	const [searchParams, setSearchParams] = useSearchParams();

	const currentMapKey = searchParams.get('map') || 'world_maps'; // Default updated to match typical ID

	const mapConfig = useMemo(() => {
		// If campaignData comes from API/DB, ensure it matches the { maps: { ... } } structure
		return getMapConfig(currentMapKey, campaignData);
	}, [currentMapKey, campaignData]);

	const viewData = useMemo(() => {
		if (!mapConfig) return null;

		const { metadata, annotations, paths, areas, overlays } = mapConfig;

		// --- MATH FIX ---
		const scaleFactor = Math.pow(2, metadata.sizes.maxZoom);
		const bounds = [
			[-metadata.sizes.imageHeight / scaleFactor, 0],
			[0, metadata.sizes.imageWidth / scaleFactor],
		];

		// --- MARKER FLATTENING ---
		// The modular structure still passes 'annotations' as an object with categories
		const markers = [];
		if (annotations) {
			Object.entries(annotations).forEach(([categoryKey, category]) => {
				if (category.items) {
					category.items.forEach((item) => {
						markers.push({
							...item,
							category: category.name,
							categoryId: categoryKey,
							position: [Number(item.lat), Number(item.lng)],
						});
					});
				}
			});
		}

		// Process Areas
		const mapAreas = [];
		if (areas) {
			Object.values(areas).forEach((category) => {
				category.items.forEach((area) => {
					mapAreas.push({
						...area,
						positions: area.points.map((p) => p.coordinates),
					});
				});
			});
		}

		return {
			config: metadata, // mapConfig.metadata usually contains path, sizes, etc.
			bounds,
			markers,
			sessions: paths || [],
			areas: mapAreas,
			overlays: overlays || [],
		};
	}, [mapConfig]);

	const navigateToMap = (mapKey) => {
		setSearchParams({ map: mapKey });
	};

	return {
		data: viewData,
		currentMapKey,
		navigateToMap,
		isLoading: false,
	};
}

--- END OF features\atlas\useMapData.js ---

--- FILE: features\atlas\components\AtlasSidebar.jsx ---
import React, { useState } from 'react';
import { clsx } from 'clsx';
import {
	Search,
	PanelLeftClose,
	PanelLeftOpen,
	Map as MapIcon,
	ChevronRight,
	ChevronDown,
	Eye,
	EyeOff,
	Crosshair,
} from 'lucide-react';

/**
 * Sidebar Group Item
 */
const AtlasGroup = ({ group, visibility, onToggleVisibility, onNavigate }) => {
	const [isExpanded, setIsExpanded] = useState(true);
	const isGroupVisible = visibility[group.id];

	return (
		<div className='select-none'>
			{/* Header */}
			<div className='flex items-center gap-1 px-3 py-2 hover:bg-black/5 transition-colors group/header sticky top-0 bg-muted/95 backdrop-blur-sm z-10 border-b border-border/40'>
				{/* Expand Toggle */}
				<button
					onClick={() => setIsExpanded(!isExpanded)}
					className='p-0.5 text-muted-foreground/70 hover:text-foreground'>
					{isExpanded ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
				</button>

				{/* Title */}
				<span
					className={clsx(
						'flex-1 text-xs font-bold uppercase tracking-wider cursor-pointer truncate',
						isGroupVisible
							? 'text-foreground'
							: 'text-muted-foreground decoration-line-through decoration-muted-foreground/50'
					)}
					onClick={() => setIsExpanded(!isExpanded)}>
					{group.label}
				</span>

				{/* Layer Visibility Toggle (Global for Group) */}
				<button
					onClick={(e) => {
						e.stopPropagation();
						onToggleVisibility(group.id);
					}}
					className={clsx(
						'p-1.5 rounded-md transition-all',
						isGroupVisible ? 'text-primary hover:bg-primary/10' : 'text-muted-foreground/50 hover:text-foreground'
					)}
					title={isGroupVisible ? 'Hide Layer' : 'Show Layer'}>
					{isGroupVisible ? <Eye size={14} /> : <EyeOff size={14} />}
				</button>
			</div>

			{/* Marker List */}
			{isExpanded && (
				<div className='pl-2 pb-1 pt-0.5 space-y-0.5'>
					{group.items.map((marker, idx) => {
						const isItemVisible = visibility[marker.id];

						return (
							<div
								key={`${group.id}-${idx}`}
								className='flex items-center gap-1 pr-2 group/item hover:bg-black/5 rounded-md'>
								{/* Navigation Button */}
								<button
									onClick={() => onNavigate(marker.position)}
									className='flex-1 flex items-center text-left gap-2 px-2 py-1.5 min-w-0'>
									<span className='opacity-50 group-hover/item:opacity-100 transition-opacity shrink-0'>
										<Crosshair size={12} />
									</span>
									<span
										className={clsx(
											'text-sm font-medium truncate transition-colors',
											isItemVisible && isGroupVisible ? 'text-foreground' : 'text-muted-foreground opacity-70'
										)}>
										{marker.label}
									</span>
								</button>

								{/* Individual Visibility Toggle */}
								<button
									onClick={() => onToggleVisibility(marker.id)}
									className={clsx(
										'p-1 rounded opacity-0 group-hover/item:opacity-100 focus:opacity-100 transition-opacity',
										isItemVisible ? 'text-muted-foreground hover:text-foreground' : 'text-muted-foreground/50'
									)}
									title={isItemVisible ? 'Hide Item' : 'Show Item'}>
									{isItemVisible ? <Eye size={12} /> : <EyeOff size={12} />}
								</button>
							</div>
						);
					})}
					{group.items.length === 0 && (
						<div className='text-[10px] text-muted-foreground/50 pl-9 italic py-1'>No locations</div>
					)}
				</div>
			)}
		</div>
	);
};

export const AtlasSidebar = ({ groups, visibility, onToggleLayer, onFlyTo }) => {
	const [search, setSearch] = useState('');
	const [desktopCollapsed, setDesktopCollapsed] = useState(false);
	const [mobileOpen, setMobileOpen] = useState(false);

	// Filter logic
	const filteredGroups = groups
		.map((g) => ({
			...g,
			items: g.items.filter((m) => m.label.toLowerCase().includes(search.toLowerCase())),
		}))
		.filter((g) => g.items.length > 0 || search === '');

	return (
		<>
			{/* COLLAPSED STATE (Desktop) */}
			{desktopCollapsed && (
				<div className='hidden lg:flex flex-col h-full border-l border-border bg-muted w-12 shrink-0 z-10 transition-all duration-300'>
					<div className='p-3 border-b border-border/50 h-14 flex items-center justify-center'>
						<button
							onClick={() => setDesktopCollapsed(false)}
							className='p-1.5 text-muted-foreground hover:text-primary hover:bg-background rounded-md transition-colors'
							title='Expand Atlas Sidebar'>
							<PanelLeftClose size={20} />
						</button>
					</div>
				</div>
			)}

			{/* SIDEBAR */}
			<div
				className={clsx(
					'flex flex-col bg-muted border-l border-border transition-all duration-300',
					// FIX: Removed global 'h-full' here.

					// Desktop Width Logic
					desktopCollapsed ? 'w-0 overflow-hidden border-none' : 'w-full lg:w-80',

					// Position Logic
					'absolute top-0 left-0 lg:relative z-[1000] lg:z-0',

					// Height Logic:
					// Mobile Closed: h-auto (just header)
					// Mobile Open: h-full (full screen overlay)
					// Desktop: h-full
					!mobileOpen ? 'h-auto bottom-auto lg:h-full' : 'h-full'
				)}>
				{/* Header */}
				<div className='p-4 border-b border-border/50 bg-muted flex flex-col gap-3'>
					<div className='flex items-center justify-between'>
						<div className='flex items-center gap-2 text-foreground font-serif font-bold'>
							<MapIcon size={18} className='text-primary' />
							<span>Atlas Index</span>
						</div>

						<div className='flex gap-1'>
							{/* Desktop Collapse */}
							<button
								onClick={() => setDesktopCollapsed(true)}
								className='hidden lg:block p-1 text-muted-foreground hover:text-primary transition-colors'
								title='Collapse Sidebar'>
								<PanelLeftOpen size={16} />
							</button>

							{/* Mobile Toggle */}
							<button
								onClick={() => setMobileOpen(!mobileOpen)}
								className='lg:hidden p-1 text-muted-foreground hover:text-foreground transition-colors'
								aria-label={mobileOpen ? 'Collapse' : 'Expand'}>
								{mobileOpen ? <ChevronDown size={20} /> : <ChevronRight size={20} />}
							</button>
						</div>
					</div>

					{/* Search - Visible when open */}
					<div className={clsx('relative', !mobileOpen && 'hidden lg:block')}>
						<Search className='absolute left-2.5 top-2.5 text-muted-foreground/50' size={14} />
						<input
							type='text'
							placeholder='Search locations...'
							value={search}
							onChange={(e) => setSearch(e.target.value)}
							className='w-full bg-background border border-border rounded-md pl-8 pr-3 py-2 text-sm focus:ring-1 focus:ring-primary/50 focus:border-primary outline-none shadow-sm'
						/>
					</div>
				</div>

				{/* Scrollable Content */}
				<div className={clsx('flex-1 overflow-y-auto custom-scrollbar bg-muted/30', !mobileOpen && 'hidden lg:block')}>
					{filteredGroups.map((group) => (
						<AtlasGroup
							key={group.id}
							group={group}
							visibility={visibility}
							onToggleVisibility={onToggleLayer}
							onNavigate={onFlyTo}
						/>
					))}

					{filteredGroups.length === 0 && (
						<div className='p-6 text-center text-xs text-muted-foreground italic'>No locations found.</div>
					)}
				</div>
			</div>
		</>
	);
};

--- END OF features\atlas\components\AtlasSidebar.jsx ---

--- FILE: features\atlas\components\MapCanvas.jsx ---
import { useEffect, useState, useMemo, useRef } from 'react';
import { MapContainer, TileLayer, useMap } from 'react-leaflet';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';

import { MapMarkers } from './layers/MapMarkers';
import { MapRecaps } from './layers/MapRecaps';
import { MapAreas } from './layers/MapAreas';
import { MapOverlays } from './layers/MapOverlays';
import { MapTools } from './MapTools';
import { AtlasSidebar } from './AtlasSidebar';
import { useMapCanvasViewModel } from './useMapCanvasViewModel';

// Controller to handle FlyTo from sidebar
const MapController = ({ bounds, minZoom, config, flyToTarget }) => {
	const map = useMap();
	const prevConfigRef = useRef();

	// Handle initial bounds
	useEffect(() => {
		if (!bounds) return;
		const isNewMap = prevConfigRef.current !== config.path;
		prevConfigRef.current = config.path;

		map.setMaxBounds(L.latLngBounds(bounds).pad(0.1));
		if (minZoom !== undefined) map.setMinZoom(minZoom);

		map.fitBounds(bounds, {
			animate: !isNewMap,
			duration: isNewMap ? 0 : 0.5,
		});
	}, [map, bounds, minZoom, config.path]);

	// Handle Sidebar FlyTo
	useEffect(() => {
		if (flyToTarget) {
			map.flyTo(flyToTarget, config.sizes.maxZoom - 1, {
				animate: true,
				duration: 1.5,
			});
		}
	}, [map, flyToTarget]);

	return null;
};

export const MapCanvas = ({ data, onNavigate }) => {
	if (!data) return null;

	const { config, bounds, areas } = data;
	const vm = useMapCanvasViewModel(data);
	const wrapperRef = useRef(null);
	const [flyToTarget, setFlyToTarget] = useState(null);

	const tileUrl = `https://raw.githubusercontent.com/aethere92/dnd-campaign-map/main/${config.path}/{z}/{x}_{y}.png`;
	const minZoom = 0;

	return (
		<div className='flex h-full w-full relative overflow-hidden'>
			{/* MAP AREA - First in DOM (Left side in flex row) */}
			<div
				ref={wrapperRef}
				className='flex-1 relative h-full bg-background'
				style={{
					backgroundColor: 'var(--background)',
					backgroundImage:
						'radial-gradient(circle at center, var(--border) 1px, transparent 1px), radial-gradient(circle at center, var(--border) 1px, transparent 1px)',
					backgroundSize: '40px 40px, 20px 20px',
					backgroundPosition: '0 0, 20px 20px',
				}}>
				<MapContainer
					center={[0, 0]}
					zoom={minZoom}
					crs={L.CRS.Simple}
					minZoom={minZoom}
					maxZoom={config.sizes.maxZoom}
					scrollWheelZoom={true}
					attributionControl={false}
					zoomControl={false}
					style={{ height: '100%', width: '100%', background: 'transparent' }}>
					<MapController bounds={bounds} minZoom={minZoom} config={config} flyToTarget={flyToTarget} />

					<TileLayer key={tileUrl} url={tileUrl} noWrap={true} bounds={bounds} maxNativeZoom={config.sizes.maxZoom} />

					<MapOverlays overlays={vm.visibleOverlays} />
					{vm.showAreas && <MapAreas areas={areas} />}
					<MapRecaps sessions={vm.visibleSessions} />
					<MapMarkers markers={vm.visibleMarkers} onNavigate={onNavigate} />

					<MapTools bounds={bounds} containerRef={wrapperRef} />
				</MapContainer>
			</div>

			{/* ATLAS SIDEBAR - Second in DOM (Right side) */}
			<AtlasSidebar
				groups={vm.sidebarGroups}
				visibility={vm.visibility}
				onToggleLayer={vm.toggleLayer}
				onFlyTo={setFlyToTarget}
			/>
		</div>
	);
};

--- END OF features\atlas\components\MapCanvas.jsx ---

--- FILE: features\atlas\components\MapTools.jsx ---
import { useState, useEffect } from 'react';
import { useMap } from 'react-leaflet';
import { Maximize, Minimize, Crosshair } from 'lucide-react';
import { clsx } from 'clsx';

export const MapTools = ({ bounds, containerRef }) => {
	const map = useMap();
	const [isFullscreen, setIsFullscreen] = useState(false);

	// Sync state if user presses ESC or browser exit
	useEffect(() => {
		const onFullScreenChange = () => {
			setIsFullscreen(!!document.fullscreenElement);
		};
		document.addEventListener('fullscreenchange', onFullScreenChange);
		return () => document.removeEventListener('fullscreenchange', onFullScreenChange);
	}, []);

	const handleCenter = (e) => {
		e.stopPropagation();
		if (bounds) {
			map.fitBounds(bounds, { animate: true, duration: 1 });
		}
	};

	const toggleFullscreen = (e) => {
		e.stopPropagation();
		if (!containerRef?.current) return;

		if (!document.fullscreenElement) {
			containerRef.current.requestFullscreen().catch((err) => {
				console.error(`Error attempting to enable fullscreen: ${err.message}`);
			});
		} else {
			document.exitFullscreen();
		}
	};

	// Reusable Button Style
	const Btn = ({ onClick, icon: Icon, title, active }) => (
		<button
			onClick={onClick}
			title={title}
			className={clsx(
				'flex items-center justify-center w-8 h-8 transition-colors first:rounded-t-md last:rounded-b-md border-b last:border-b-0',
				// FIX: Semantic Theme Colors
				'bg-card border-border text-muted-foreground hover:bg-muted hover:text-primary',
				active && 'bg-primary/10 text-primary'
			)}>
			<Icon size={16} strokeWidth={2.5} />
		</button>
	);

	return (
		<div className='leaflet-top leaflet-left'>
			<div className='leaflet-control leaflet-bar !border-0 !shadow-xl !m-3 rounded-md overflow-hidden border border-border/50'>
				<Btn onClick={handleCenter} icon={Crosshair} title='Center Map' />
				<Btn
					onClick={toggleFullscreen}
					icon={isFullscreen ? Minimize : Maximize}
					title={isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen'}
					active={isFullscreen}
				/>
			</div>
		</div>
	);
};

--- END OF features\atlas\components\MapTools.jsx ---

--- FILE: features\atlas\components\useMapCanvasViewModel.js ---
import { useState, useEffect, useMemo } from 'react';
import { BookOpen, MapPin, Image as ImageIcon, Map as MapIcon } from 'lucide-react';

export function useMapCanvasViewModel(data) {
	// 1. Initialize Visibility
	const [visibility, setVisibility] = useState(() => {
		const init = { areas: false };
		if (!data) return init;

		// Initialize marker categories
		const uniqueCats = [...new Set(data.markers.map((m) => m.category))].filter(Boolean);
		uniqueCats.forEach((cat) => {
			init[`marker-cat-${cat}`] = true;
		});

		// Initialize individual markers (new)
		data.markers.forEach((m) => {
			if (m.label) init[`marker-item-${m.label}`] = true;
		});

		// Sessions/Overlays: OFF by default
		data.sessions.forEach((s) => (init[`session-${s.name}`] = false));
		data.overlays.forEach((o) => (init[`overlay-${o.name}`] = false));

		return init;
	});

	// Sync with data updates
	useEffect(() => {
		if (!data) return;
		setVisibility((prev) => {
			const next = { ...prev };
			let changed = false;

			// Sync Categories
			const uniqueCats = [...new Set(data.markers.map((m) => m.category))].filter(Boolean);
			uniqueCats.forEach((cat) => {
				const key = `marker-cat-${cat}`;
				if (next[key] === undefined) {
					next[key] = true;
					changed = true;
				}
			});

			// Sync Items
			data.markers.forEach((m) => {
				const key = `marker-item-${m.label}`;
				if (next[key] === undefined) {
					next[key] = true;
					changed = true;
				}
			});

			return changed ? next : prev;
		});
	}, [data?.markers]);

	const toggleLayer = (id) => {
		setVisibility((prev) => ({ ...prev, [id]: !prev[id] }));
	};

	// 2. Control Groups Configuration
	const sidebarGroups = useMemo(() => {
		if (!data) return [];

		const groups = [];

		// 1. Sessions
		if (data.sessions.length > 0) {
			groups.push({
				id: 'sessions-group',
				label: 'Sessions & Paths',
				items: data.sessions
					.map((s) => ({
						label: s.name,
						id: `session-${s.name}`,
						position: s.points[0]?.coordinates,
					}))
					.filter((i) => i.position),
			});
		}

		// 2. Markers by Category
		const uniqueCats = [...new Set(data.markers.map((m) => m.category))].filter(Boolean).sort();

		uniqueCats.forEach((cat) => {
			const catId = `marker-cat-${cat}`;
			const catMarkers = data.markers.filter((m) => m.category === cat);

			groups.push({
				id: catId,
				label: cat,
				items: catMarkers.map((m) => ({
					label: m.label,
					id: `marker-item-${m.label}`, // Individual ID
					position: m.position,
				})),
			});
		});

		// 3. Overlays
		if (data.overlays.length > 0) {
			groups.push({
				id: 'overlays-group',
				label: 'Overlays',
				items: data.overlays.map((o) => ({
					label: o.name,
					id: `overlay-${o.name}`,
					position: o.bounds[0],
				})),
			});
		}

		// 4. Areas
		if (data.areas.length > 0) {
			groups.push({
				id: 'areas',
				label: 'Regions & Areas',
				items: data.areas.map((a) => ({
					label: a.name,
					id: 'areas', // Shared ID for all areas for now
					position: a.positions[0],
				})),
			});
		}

		return groups;
	}, [data]);

	// 3. Filter Layers
	// Logic: Marker is visible if Category is ON AND Individual Item is ON
	const visibleMarkers = useMemo(
		() =>
			data?.markers.filter(
				(m) =>
					visibility[`marker-cat-${m.category}`] !== false && // Default to true if undefined
					visibility[`marker-item-${m.label}`] !== false
			) || [],
		[data, visibility]
	);

	const visibleSessions = useMemo(
		() => data?.sessions.filter((s) => visibility[`session-${s.name}`] || visibility['sessions-group']) || [],
		[data, visibility]
	);

	const visibleOverlays = useMemo(
		() => data?.overlays.filter((o) => visibility[`overlay-${o.name}`] || visibility['overlays-group']) || [],
		[data, visibility]
	);

	return {
		visibility,
		toggleLayer,
		sidebarGroups,
		visibleMarkers,
		visibleSessions,
		visibleOverlays,
		showAreas: visibility['areas'],
	};
}

--- END OF features\atlas\components\useMapCanvasViewModel.js ---

--- FILE: features\atlas\components\__MapLayerControl.jsx ---
import { useState, useEffect, useRef } from 'react';
import { Layers, ChevronDown, ChevronRight, Eye, EyeOff, Check } from 'lucide-react';
import { clsx } from 'clsx';
import L from 'leaflet';

// Reusable styled Group Header matching Sidebar aesthetics
const Group = ({ label, icon: Icon, children, defaultOpen = true }) => {
	const [isOpen, setIsOpen] = useState(defaultOpen);
	if (!children || children.length === 0) return null;

	return (
		<div className='mb-2'>
			<button
				onClick={(e) => {
					e.stopPropagation();
					setIsOpen(!isOpen);
				}}
				className='flex items-center w-full text-left text-[10px] font-bold uppercase tracking-widest text-muted-foreground hover:text-primary transition-colors mb-1 select-none font-sans'>
				<span className='mr-1 opacity-70'>{isOpen ? <ChevronDown size={10} /> : <ChevronRight size={10} />}</span>
				<span className='flex items-center gap-1.5'>
					{Icon && <Icon size={12} />}
					{label}
				</span>
			</button>
			{isOpen && <div className='pl-2 space-y-0.5 border-l border-black/5 ml-1'>{children}</div>}
		</div>
	);
};

// Toggle Item with explicit Checkmark UI
const ToggleItem = ({ label, checked, onChange }) => (
	<div
		className='flex items-center gap-2 cursor-pointer group px-2 py-1 hover:bg-black/5 rounded-md transition-colors select-none'
		onClick={(e) => {
			e.stopPropagation();
			onChange();
		}}>
		{/* Custom Checkbox UI - Reduced size */}
		<div
			className={clsx(
				'w-3.5 h-3.5 rounded-[3px] border flex items-center justify-center transition-all shadow-sm shrink-0',
				checked ? 'bg-amber-600 border-amber-700 text-white' : 'bg-card border-border group-hover:border-amber-400'
			)}>
			{checked && <Check size={10} strokeWidth={3.5} />}
		</div>

		<span
			className={clsx(
				'text-[11px] font-medium leading-tight pt-0.5 font-sans',
				checked ? 'text-foreground' : 'text-muted-foreground'
			)}>
			{label}
		</span>
	</div>
);

export const MapLayerControl = ({ groups, visibility, toggleLayer }) => {
	const [expanded, setExpanded] = useState(true);
	const containerRef = useRef(null);

	// Prevent Leaflet map interactions when clicking inside this control
	useEffect(() => {
		if (containerRef.current) {
			L.DomEvent.disableClickPropagation(containerRef.current);
			L.DomEvent.disableScrollPropagation(containerRef.current);
		}
	}, []);

	return (
		<div className='leaflet-top leaflet-right font-sans' style={{ pointerEvents: 'none', zIndex: 1000 }}>
			<div
				ref={containerRef}
				className={clsx(
					'leaflet-control m-3 transition-all duration-200 ease-in-out',
					// Theme colors
					'bg-[#fdfbf7] border border-[#c9c2b8] rounded-lg shadow-xl overflow-hidden'
				)}
				style={{ pointerEvents: 'auto' }}>
				{/* Header */}
				<div
					className='flex items-center justify-between p-2.5 bg-[#f2efe9] border-b border-[#c9c2b8] cursor-pointer min-w-[180px]'
					onClick={() => setExpanded(!expanded)}>
					<div className='flex items-center gap-2 text-xs font-serif font-bold text-amber-900'>
						<Layers size={14} />
						<span>Atlas Layers</span>
					</div>
					<button className='p-0.5 hover:bg-black/5 rounded text-amber-900/70'>
						{expanded ? <Eye size={12} /> : <EyeOff size={12} />}
					</button>
				</div>

				{/* Content */}
				{expanded && (
					<div className='p-2 max-h-[60vh] overflow-y-auto w-56 custom-scrollbar bg-background/50'>
						{groups.overlays?.length > 0 && (
							<Group label='Overlays' icon={groups.icons.overlays} defaultOpen={false}>
								{groups.overlays.map((l) => (
									<ToggleItem
										key={l.id}
										label={l.label}
										checked={!!visibility[l.id]}
										onChange={() => toggleLayer(l.id)}
									/>
								))}
							</Group>
						)}

						{groups.sessions?.length > 0 && (
							<Group label='Journal & Paths' icon={groups.icons.sessions} defaultOpen={false}>
								{groups.sessions.map((l) => (
									<ToggleItem
										key={l.id}
										label={l.label}
										checked={!!visibility[l.id]}
										onChange={() => toggleLayer(l.id)}
									/>
								))}
							</Group>
						)}

						{groups.markers?.length > 0 && (
							<Group label='Map Markers' icon={groups.icons.markers} defaultOpen={true}>
								{groups.markers.map((cat) => (
									<ToggleItem
										key={cat.id}
										label={cat.label}
										checked={!!visibility[cat.id]}
										onChange={() => toggleLayer(cat.id)}
									/>
								))}
							</Group>
						)}

						<div className='mt-2 pt-2 border-t border-black/5'>
							<ToggleItem
								label='Show Areas & Regions'
								checked={!!visibility['areas']}
								onChange={() => toggleLayer('areas')}
							/>
						</div>
					</div>
				)}
			</div>
		</div>
	);
};

--- END OF features\atlas\components\__MapLayerControl.jsx ---

--- FILE: features\atlas\components\layers\MapAreas.jsx ---
import { Polygon, Tooltip } from 'react-leaflet';

export const MapAreas = ({ areas }) => {
	if (!areas || areas.length === 0) return null;

	return (
		<>
			{areas.map((area, idx) => (
				<Polygon
					key={`${area.name}-${idx}`}
					positions={area.positions}
					pathOptions={{
						color: area.lineColor || 'transparent',
						fillColor: area.interiorColor || '#ff0000',
						fillOpacity: 0.3,
						weight: 1,
					}}>
					<Tooltip
						permanent
						direction='center'
						className='bg-transparent border-0 shadow-none font-serif text-lg font-bold text-white drop-shadow-md text-center'>
						<div style={{ transform: `rotate(${area.textRotation || '0deg'})` }}>{area.name}</div>
					</Tooltip>
				</Polygon>
			))}
		</>
	);
};

--- END OF features\atlas\components\layers\MapAreas.jsx ---

--- FILE: features\atlas\components\layers\MapMarkers.jsx ---
import { Marker, Popup } from 'react-leaflet';
import { ArrowRight, BookOpen, Map as MapIcon } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import { clsx } from 'clsx';
import { resolveMarkerIcon } from '@/features/atlas/utils/markerUtils';
import { useEntityIndex } from '@/features/smart-text/useEntityIndex';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import { resolveImageUrl, parseAttributes } from '@/shared/utils/imageUtils';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

export const MapMarkers = ({ markers, onNavigate }) => {
	const navigate = useNavigate();
	const { map: entityMap } = useEntityIndex();

	if (!markers || markers.length === 0) return null;

	return (
		<>
			{markers.map((marker, idx) => {
				const leafletIcon = resolveMarkerIcon(marker);

				const entityMatch = Array.from(entityMap.values()).find(
					(e) => e.name.toLowerCase() === marker.label.toLowerCase()
				);

				const entityAttrs = entityMatch ? parseAttributes(entityMatch.attributes) : {};

				const displayData = {
					title: marker.label,
					category:
						marker.category && marker.category !== 'default'
							? marker.category
							: entityMatch
							? entityMatch.type
							: 'Point of Interest',
					description: marker.description
						? marker.description
						: entityMatch
						? getAttributeValue(entityAttrs, ['summary', 'narrative']) || entityMatch.description
						: null,
					image: entityMatch ? resolveImageUrl(entityAttrs, 'background') : null,
				};

				const entityConfig = entityMatch ? getEntityConfig(entityMatch.type) : null;

				const handleWikiNav = (e) => {
					e.stopPropagation();
					if (entityMatch) {
						navigate(`/wiki/${entityMatch.type}/${entityMatch.id}`);
					}
				};

				const handleMapNav = (e) => {
					e.stopPropagation();
					onNavigate(marker.mapLink);
				};

				return (
					<Marker key={`${marker.label}-${idx}`} position={marker.position} icon={leafletIcon}>
						<Popup className='custom-popup-clean' closeButton={false}>
							<div className='flex flex-col w-full font-sans bg-background rounded-lg overflow-hidden border border-border shadow-sm'>
								{displayData.image && (
									<div className='h-24 w-full relative bg-muted'>
										<img src={displayData.image} alt={displayData.title} className='w-full h-full object-cover' />
										{/* FIX: Improved Gradient - Stronger fade at bottom for text readability */}
										<div className='absolute inset-0 bg-gradient-to-t from-[var(--background)] via-[var(--background)]/80 via-30% to-transparent pointer-events-none' />
									</div>
								)}

								<div className={clsx('px-4 pb-3', displayData.image ? 'pt-2 -mt-8 relative z-10' : 'pt-4')}>
									<div className='flex items-start justify-between gap-2'>
										<div>
											<span
												className={clsx(
													'text-[10px] font-bold uppercase tracking-wider block mb-0.5',
													entityConfig ? entityConfig.tailwind.text : 'text-muted-foreground'
												)}>
												{displayData.category}
											</span>
											{/* FIX: Ensure title text color is always readable (foreground) */}
											<h3 className='font-serif font-bold text-lg leading-tight text-foreground drop-shadow-sm'>
												{displayData.title}
											</h3>
										</div>
										{entityConfig && (
											<div
												className={clsx(
													'p-1.5 rounded-md border shrink-0 bg-background/80 backdrop-blur-sm',
													entityConfig.tailwind.border,
													entityConfig.tailwind.text
												)}>
												<entityConfig.icon size={14} />
											</div>
										)}
									</div>

									<div className='h-px w-full bg-border/50 my-3' />

									<div className='text-xs text-muted-foreground leading-relaxed max-h-32 overflow-y-auto custom-scrollbar'>
										{displayData.description || <span className='italic opacity-70'>No details available.</span>}
									</div>
								</div>

								{(marker.mapLink || entityMatch) && (
									<div className='bg-muted/50 p-2 border-t border-border flex flex-col gap-1'>
										{marker.mapLink && (
											<button
												onClick={handleMapNav}
												className='w-full flex items-center justify-between px-3 py-1.5 rounded hover:bg-primary/10 text-primary transition-colors text-xs font-bold uppercase tracking-wide group'>
												<span className='flex items-center gap-2'>
													<MapIcon size={12} /> Enter Location
												</span>
												<ArrowRight size={12} className='group-hover:translate-x-1 transition-transform' />
											</button>
										)}

										{entityMatch && (
											<button
												onClick={handleWikiNav}
												className='w-full flex items-center justify-between px-3 py-1.5 rounded hover:bg-background text-muted-foreground hover:text-foreground transition-colors text-xs font-semibold group'>
												<span className='flex items-center gap-2'>
													<BookOpen size={12} /> View Encyclopedia
												</span>
												<ArrowRight size={12} className='opacity-0 group-hover:opacity-100 transition-opacity' />
											</button>
										)}
									</div>
								)}
							</div>
						</Popup>
					</Marker>
				);
			})}
		</>
	);
};

--- END OF features\atlas\components\layers\MapMarkers.jsx ---

--- FILE: features\atlas\components\layers\MapOverlays.jsx ---
import { ImageOverlay } from 'react-leaflet';

export const MapOverlays = ({ overlays }) => {
	if (!overlays || overlays.length === 0) return null;

	return (
		<>
			{overlays.map((overlay, idx) => (
				<ImageOverlay
					key={`${overlay.name}-${idx}`}
					url={`${import.meta.env.BASE_URL}${overlay.image}`}
					bounds={overlay.bounds}
					opacity={1}
				/>
			))}
		</>
	);
};

--- END OF features\atlas\components\layers\MapOverlays.jsx ---

--- FILE: features\atlas\components\layers\MapRecaps.jsx ---
import { Fragment } from 'react';
import { Polyline, Marker, Popup } from 'react-leaflet';
import { Calendar } from 'lucide-react';
import { createDotIcon } from '@/features/atlas/utils/markerUtils';

export const MapRecaps = ({ sessions }) => {
	if (!sessions || sessions.length === 0) return null;

	return (
		<>
			{sessions.map((session, idx) => (
				<Fragment key={session.name}>
					<Polyline
						positions={session.points.map((p) => p.coordinates)}
						pathOptions={{ color: session.lineColor || '#d97706', weight: 3, dashArray: '8, 8', opacity: 0.7 }}
					/>

					{session.points
						.filter((p) => p.text)
						.map((point, pIdx) => (
							<Marker
								key={`${session.name}-p-${pIdx}`}
								position={point.coordinates}
								icon={createDotIcon(session.lineColor || '#d97706')}>
								<Popup closeButton={false} className='leaflet-popup-clean'>
									<div className='flex flex-col w-[200px] font-sans bg-background rounded-md overflow-hidden shadow-sm border border-border/50'>
										{/* Header */}
										<div className='px-3 py-2 bg-amber-500/10/80 border-b border-primary/20 flex items-center gap-2'>
											<Calendar size={12} className='text-primary' />
											<span className='text-[10px] font-bold uppercase tracking-wider text-primary'>
												{session.name}
											</span>
										</div>

										{/* Content */}
										<div className='p-3 px-5 text-xs text-foreground/90 leading-snug'>{point.text}</div>
									</div>
								</Popup>
							</Marker>
						))}
				</Fragment>
			))}
		</>
	);
};

--- END OF features\atlas\components\layers\MapRecaps.jsx ---

--- FILE: features\atlas\config\mapConfig.js ---

--- END OF features\atlas\config\mapConfig.js ---

--- FILE: features\atlas\data\modularize.js ---
import fs from 'fs';
import path from 'path';

// ==========================================
// CONFIGURATION
// ==========================================
const INPUT_FILE = 'campaign_01.js';

// We output deep into src so it's ready for Vite to pick up
const OUTPUT_DIR = 'campaign_01';

// ==========================================
// 1. HELPER: JS Stringifier
// ==========================================
function toJsString(obj, indentLevel = 0) {
	const indent = '\t'.repeat(indentLevel);
	const nextIndent = '\t'.repeat(indentLevel + 1);

	if (obj === null) return 'null';
	if (typeof obj === 'undefined') return 'undefined';

	// Force single quotes for strings
	if (typeof obj === 'string') {
		const escaped = obj.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n');
		return `'${escaped}'`;
	}

	if (typeof obj !== 'object') return String(obj);

	if (Array.isArray(obj)) {
		if (obj.length === 0) return '[]';
		// Keep coordinates [x, y] on one line
		if (obj.length === 2 && typeof obj[0] === 'number') {
			return `[${obj.join(', ')}]`;
		}
		const items = obj.map((item) => toJsString(item, indentLevel + 1));
		return `[\n${nextIndent}${items.join(`,\n${nextIndent}`)}\n${indent}]`;
	}

	const keys = Object.keys(obj);
	if (keys.length === 0) return '{}';

	const props = keys.map((key) => {
		const value = toJsString(obj[key], indentLevel + 1);
		// Don't quote simple keys
		const cleanKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `'${key}'`;
		return `${cleanKey}: ${value}`;
	});

	return `{\n${nextIndent}${props.join(`,\n${nextIndent}`)}\n${indent}}`;
}

// ==========================================
// 2. HELPER: Recursive Extractor
// ==========================================
function extractMapsRecursively(obj, parentId = null, collectedMaps = []) {
	// If it has metadata, we treat it as a Map configuration
	if (obj.metadata) {
		const mapId = obj.metadata.mapId || 'unknown_map';

		// Clone to avoid mutating the original deeply nested structure immediately
		const mapData = { ...obj };

		// Add explicit parent ID for navigation logic
		if (parentId) {
			mapData.parentId = parentId;
		}

		// Check for children (submaps)
		if (obj.submaps) {
			Object.keys(obj.submaps).forEach((category) => {
				const categoryObj = obj.submaps[category];
				Object.keys(categoryObj).forEach((submapKey) => {
					// Recurse down
					extractMapsRecursively(categoryObj[submapKey], mapId, collectedMaps);
				});
			});
		}

		// Clean up the object (we don't want the nested submaps in the flat config)
		delete mapData.submaps;

		collectedMaps.push({
			id: mapId,
			data: mapData,
		});
	} else {
		// If it's the root container (CAMPAIGN_01)
		Object.keys(obj).forEach((key) => {
			if (obj[key] && typeof obj[key] === 'object') {
				extractMapsRecursively(obj[key], null, collectedMaps);
			}
		});
	}
	return collectedMaps;
}

// ==========================================
// 3. MAIN PROCESS
// ==========================================
try {
	console.log(`ðŸ“– Reading ${INPUT_FILE}...`);
	let fileContent = fs.readFileSync(INPUT_FILE, 'utf8');

	// Remove "export" keywords so we can eval it locally
	const cleanCode = fileContent.replace(/export const/g, 'const');

	// Evaluate to get the object
	const { CAMPAIGN_01 } = eval(`${cleanCode}; ({ CAMPAIGN_01 });`);

	console.log(`ðŸ”¨ Flattening map hierarchy...`);
	const allMaps = extractMapsRecursively(CAMPAIGN_01);
	console.log(`   Found ${allMaps.length} maps.`);

	// Prepare Directories
	if (fs.existsSync(OUTPUT_DIR)) {
		fs.rmSync(OUTPUT_DIR, { recursive: true, force: true });
	}
	fs.mkdirSync(path.join(OUTPUT_DIR, 'maps'), { recursive: true });

	const registryImports = [];
	const registryExports = [];

	// Process every map found
	allMaps.forEach((map) => {
		const mapId = map.id;
		const mapData = map.data;
		const mapDir = path.join(OUTPUT_DIR, 'maps', mapId);

		fs.mkdirSync(mapDir, { recursive: true });

		const localImports = [];

		// -----------------------------------------------------
		// FILE EXTRACTION LOGIC
		// We replace data with strings like 'PLACEHOLDER_PATHS'
		// and then regex replace them later.
		// -----------------------------------------------------

		// 1. Paths
		if (mapData.paths && mapData.paths.length > 0) {
			const content = `export const paths = ${toJsString(mapData.paths)};`;
			fs.writeFileSync(path.join(mapDir, 'paths.js'), content);

			localImports.push(`import { paths } from './paths.js';`);
			mapData.paths = 'PLACEHOLDER_PATHS';
		}

		// 2. Annotations (POIs, NPCs, etc)
		if (mapData.annotations && Object.keys(mapData.annotations).length > 0) {
			const content = `export const annotations = ${toJsString(mapData.annotations)};`;
			fs.writeFileSync(path.join(mapDir, 'annotations.js'), content);

			localImports.push(`import { annotations } from './annotations.js';`);
			mapData.annotations = 'PLACEHOLDER_ANNOTATIONS';
		}

		// 3. Areas (Polygons)
		if (mapData.areas && Object.keys(mapData.areas).length > 0) {
			const content = `export const areas = ${toJsString(mapData.areas)};`;
			fs.writeFileSync(path.join(mapDir, 'areas.js'), content);

			localImports.push(`import { areas } from './areas.js';`);
			mapData.areas = 'PLACEHOLDER_AREAS';
		}

		// 4. Overlays
		if (mapData.overlays && mapData.overlays.length > 0) {
			const content = `export const overlays = ${toJsString(mapData.overlays)};`;
			fs.writeFileSync(path.join(mapDir, 'overlays.js'), content);

			localImports.push(`import { overlays } from './overlays.js';`);
			mapData.overlays = 'PLACEHOLDER_OVERLAYS';
		}

		// Generate the Map Config String
		let configStr = toJsString(mapData);

		// Replace Placeholders with actual variables
		// We match quotes around them because toJsString adds quotes to strings
		configStr = configStr.replace(/['"]PLACEHOLDER_PATHS['"]/g, 'paths');
		configStr = configStr.replace(/['"]PLACEHOLDER_ANNOTATIONS['"]/g, 'annotations');
		configStr = configStr.replace(/['"]PLACEHOLDER_AREAS['"]/g, 'areas');
		configStr = configStr.replace(/['"]PLACEHOLDER_OVERLAYS['"]/g, 'overlays');

		const mapVarName = mapId.toUpperCase();

		const indexContent = `
${localImports.join('\n')}

export const ${mapVarName} = ${configStr};
`;
		fs.writeFileSync(path.join(mapDir, 'index.js'), indexContent.trim());

		// Prepare Registry
		registryImports.push(`import { ${mapVarName} } from './maps/${mapId}/index.js';`);
		registryExports.push(`    [${mapVarName}.metadata.mapId]: ${mapVarName}`);
	});

	// ==========================================
	// 4. GENERATE REGISTRY
	// ==========================================
	const registryContent = `
${registryImports.join('\n')}

export const CAMPAIGN_01 = {
    name: 'Campaign 01',
    maps: {
${registryExports.join(',\n')}
    }
};
`;
	fs.writeFileSync(path.join(OUTPUT_DIR, 'index.js'), registryContent.trim());

	console.log(`âœ… Done! Created modular React structure in:`);
	console.log(`   ðŸ“‚ ${OUTPUT_DIR}/`);
	console.log(`      ðŸ“„ index.js (Import this in your App)`);
	console.log(`      ðŸ“‚ maps/ (Individual map configs)`);
} catch (err) {
	console.error('âŒ Error:', err.message);
	console.error(err.stack);
}

--- END OF features\atlas\data\modularize.js ---

--- FILE: features\atlas\data\refactor.js ---
import fs from 'fs';

// 1. CONFIGURATION
const INPUT_FILE = 'campaign_01.js';
const OUTPUT_FILE = 'campaign_01_cleaned.js';

// Keys to completely remove
const KEYS_TO_REMOVE = ['icon', 'iconType', 'animation', 'pointColor', 'pointWidth', 'filter', 'loot', 'image'];

// Keys to force to the top of objects
const KEY_ORDER = ['label', 'name', 'lat', 'lng', 'coordinates', 'text'];

// 2. HELPERS

/**
 * Recursively cleans and reorders objects
 */
function cleanAndReorder(obj) {
	if (!obj || typeof obj !== 'object') {
		return obj;
	}

	if (Array.isArray(obj)) {
		return obj.map(cleanAndReorder);
	}

	const newObj = {};

	// 1. Add High Priority Keys first
	KEY_ORDER.forEach((key) => {
		if (Object.prototype.hasOwnProperty.call(obj, key)) {
			newObj[key] = cleanAndReorder(obj[key]);
		}
	});

	// 2. Add remaining keys (filtering out removed ones)
	Object.keys(obj).forEach((key) => {
		if (KEYS_TO_REMOVE.includes(key)) return;
		if (KEY_ORDER.includes(key)) return;

		newObj[key] = cleanAndReorder(obj[key]);
	});

	return newObj;
}

/**
 * Converts object to formatted JS string using single quotes
 */
function toJsString(obj, indentLevel = 0) {
	const indent = '\t'.repeat(indentLevel);
	const nextIndent = '\t'.repeat(indentLevel + 1);

	if (obj === null) return 'null';
	if (typeof obj === 'undefined') return 'undefined';

	// Force single quotes for strings
	if (typeof obj === 'string') {
		const escaped = obj.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n');
		return `'${escaped}'`;
	}

	if (typeof obj !== 'object') return String(obj);

	if (Array.isArray(obj)) {
		if (obj.length === 0) return '[]';

		// Keep coordinate arrays [x, y] on one line
		if (obj.length === 2 && typeof obj[0] === 'number') {
			return `[${obj.join(', ')}]`;
		}

		const items = obj.map((item) => toJsString(item, indentLevel + 1));
		return `[\n${nextIndent}${items.join(`,\n${nextIndent}`)}\n${indent}]`;
	}

	const keys = Object.keys(obj);
	if (keys.length === 0) return '{}';

	const props = keys.map((key) => {
		const value = toJsString(obj[key], indentLevel + 1);
		const cleanKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `'${key}'`;
		return `${cleanKey}: ${value}`;
	});

	return `{\n${nextIndent}${props.join(`,\n${nextIndent}`)}\n${indent}}`;
}

// 3. MAIN LOGIC
try {
	console.log(`Reading ${INPUT_FILE}...`);
	let fileContent = fs.readFileSync(INPUT_FILE, 'utf8');

	// Remove "export" keywords to allow local eval
	const cleanCode = fileContent.replace(/export const/g, 'const');

	// Evaluate code to get objects
	const { CAMPAIGN_01, CAMPAIGN_01_ALIASES } = eval(`
        ${cleanCode}
        ;({ CAMPAIGN_01, CAMPAIGN_01_ALIASES });
    `);

	console.log('Cleaning and reordering data...');
	const cleanedCampaign = cleanAndReorder(CAMPAIGN_01);
	const cleanedAliases = cleanAndReorder(CAMPAIGN_01_ALIASES);

	// 4. DATA EXTRACTION

	// Extract Paths
	let WORLD_MAP_PATHS = [];
	if (cleanedCampaign.world_maps?.paths) {
		WORLD_MAP_PATHS = cleanedCampaign.world_maps.paths;
		// Set placeholder
		cleanedCampaign.world_maps.paths = 'PLACEHOLDER_PATHS';
	}

	// Extract Korinis
	let KORINIS_ISLAND = null;
	if (cleanedCampaign.world_maps?.submaps?.islands?.korinis_island) {
		KORINIS_ISLAND = cleanedCampaign.world_maps.submaps.islands.korinis_island;
		cleanedCampaign.world_maps.submaps.islands.korinis_island = 'PLACEHOLDER_KORINIS';
	}

	// Extract Unnamed Island
	let UNNAMED_ISLAND = null;
	if (cleanedCampaign.world_maps?.submaps?.islands?.unnamed_island_01) {
		UNNAMED_ISLAND = cleanedCampaign.world_maps.submaps.islands.unnamed_island_01;
		cleanedCampaign.world_maps.submaps.islands.unnamed_island_01 = 'PLACEHOLDER_UNNAMED';
	}

	// 5. FILE GENERATION
	console.log('Generating output string...');

	let output = `// ==========================================
// ALIASES
// ==========================================
export const CAMPAIGN_01_ALIASES = ${toJsString(cleanedAliases)};

// ==========================================
// EXTRACTED DATA
// ==========================================

// --- World Map Paths ---
const WORLD_MAP_PATHS = ${toJsString(WORLD_MAP_PATHS)};

`;

	if (KORINIS_ISLAND) {
		output += `// --- Submap: Korinis Island ---\nconst KORINIS_ISLAND = ${toJsString(KORINIS_ISLAND)};\n\n`;
	}

	if (UNNAMED_ISLAND) {
		output += `// --- Submap: Unnamed Island ---\nconst UNNAMED_ISLAND = ${toJsString(UNNAMED_ISLAND)};\n\n`;
	}

	// Generate main string
	let mainString = toJsString(cleanedCampaign);

	// 6. REPLACE PLACEHOLDERS (Robust Regex)
	// Matches 'PLACEHOLDER' or "PLACEHOLDER"
	mainString = mainString.replace(/['"]PLACEHOLDER_PATHS['"]/g, 'WORLD_MAP_PATHS');
	mainString = mainString.replace(/['"]PLACEHOLDER_KORINIS['"]/g, 'KORINIS_ISLAND');
	mainString = mainString.replace(/['"]PLACEHOLDER_UNNAMED['"]/g, 'UNNAMED_ISLAND');

	output += `// ==========================================
// MAIN CAMPAIGN OBJECT
// ==========================================
export const CAMPAIGN_01 = ${mainString};
`;

	fs.writeFileSync(OUTPUT_FILE, output);
	console.log(`\nâœ… Success! File saved to: ${OUTPUT_FILE}`);
} catch (err) {
	console.error('âŒ Error:', err.message);
	console.error(err.stack);
}

--- END OF features\atlas\data\refactor.js ---

--- FILE: features\atlas\utils\mapNavigation.js ---
// 1. Update the import to point to your new generated folder
// Ensure this path matches where your modularize.js script output the files
import { CAMPAIGN_01 } from '@/features/atlas/data/campaign_01/index';

/**
 * Resolves the configuration object for a specific map key.
 *
 * CHANGE: With the modular structure, all maps are now siblings
 * in the .maps object, so deep traversal/aliases are no longer needed.
 */
export const getMapConfig = (mapKey, campaignData) => {
	// 1. Use context data if provided, otherwise fallback to static generated file
	const rootData = campaignData || CAMPAIGN_01;

	// 2. Determine ID (Default to 'world_maps' if undefined)
	// Make sure 'world_maps' matches the mapId in your world map's metadata
	const targetId = mapKey || 'world_maps';

	// 3. Direct Lookup
	// The new structure is simply { maps: { [id]: { ...config } } }
	if (rootData.maps && rootData.maps[targetId]) {
		return rootData.maps[targetId];
	}

	console.warn(`[getMapConfig] Map ID not found: ${targetId}`);
	return null;
};

/**
 * Helper to calculate map bounds based on image size
 */
export const calculateBounds = (imageWidth, imageHeight) => {
	return [
		[-imageHeight, 0],
		[0, imageWidth],
	];
};

--- END OF features\atlas\utils\mapNavigation.js ---

--- FILE: features\atlas\utils\markerUtils.js ---
import React from 'react';
import L from 'leaflet';
import { renderToString } from 'react-dom/server';
import { Skull, MapPin, Castle, User, Tent, Sparkles, Home, Sword, Anchor, Mountain, Scroll } from 'lucide-react';

// 1. Map your category strings to Lucide Components
const ICON_MAP = {
	combat: Skull,
	danger: Skull,
	encounter: Sword,
	city: Castle,
	town: Home,
	village: Home,
	npc: User,
	people: User,
	camp: Tent,
	magic: Sparkles,
	shrine: Sparkles,
	port: Anchor,
	landmark: MapPin,
	dungeon: Mountain,
	quest: Scroll,
	default: MapPin,
};

// Singleton for invisible/interactive-only markers
export const invisibleIcon = L.divIcon({
	className: 'bg-transparent border-none',
	html: '<div style="width: 100%; height: 100%;"></div>',
	iconSize: [20, 20],
	iconAnchor: [10, 10],
	popupAnchor: [0, -10],
});

/**
 * Creates a "Pin" style marker using a Lucide React Icon
 */
export const createLucideMarker = (category, color = '#d97706') => {
	const normalized = category?.toLowerCase() || 'default';
	let IconComponent = ICON_MAP.default;
	for (const [key, comp] of Object.entries(ICON_MAP)) {
		if (normalized.includes(key)) {
			IconComponent = comp;
			break;
		}
	}

	const iconHtml = renderToString(
		React.createElement(IconComponent, {
			size: 14,
			strokeWidth: 3,
			color: 'white',
		})
	);

	/**
	 * STABLE SVG PIN
	 * The point is exactly at 16, 36.
	 * The circle center is at 16, 16.
	 */
	return L.divIcon({
		className: 'custom-marker-container',
		html: `
            <div class="relative group" style="width: 32px; height: 36px;">
                <svg width="32" height="36" viewBox="0 0 32 36" fill="none" xmlns="http://www.w3.org/2000/svg" style="filter: drop-shadow(0px 2px 2px rgba(0,0,0,0.2));">
                    <!-- Pin Body -->
                    <path d="M16 36C16 36 32 26.5 32 16C32 7.16344 24.8366 0 16 0C7.16344 0 0 7.16344 0 16C0 26.5 16 36 16 36Z" fill="white"/>
                    <path d="M16 33C16 33 29 24.5 29 16C29 8.8203 23.1797 3 16 3C8.8203 3 3 8.8203 3 16C3 24.5 16 33 16 33Z" fill="${color}"/>
                    <!-- Inner Hole -->
                    <circle cx="16" cy="16" r="10" fill="white" fill-opacity="0.2"/>
                </svg>
                <!-- Icon Overlay -->
                <div class="absolute top-[8px] left-[8px] w-[16px] h-[16px] flex items-center justify-center pointer-events-none transition-transform group-hover:-translate-y-0.5">
                    ${iconHtml}
                </div>
            </div>
        `,
		iconSize: [32, 36],
		iconAnchor: [16, 36], // EXACT BOTTOM CENTER
		popupAnchor: [0, -36],
	});
};

// Text Label Marker Generator
export const createTextMarker = (label, fontSize) => {
	const sizeStyle = fontSize ? `${fontSize}px` : '1.5rem';
	return L.divIcon({
		className: 'map-text-marker',
		html: `
            <div style="transform: translate(-50%, -50%); width: max-content; text-align: center; display: flex; justify-content: center; align-items: center;">
                <span style="font-family: 'Inter', sans-serif; text-transform: uppercase; font-weight: 600; font-size: ${sizeStyle}; color: #2c1a0e; text-shadow: 0 0 4px #fdfbf7, 0 0 8px #fdfbf7, 0 0 15px #fdfbf7; pointer-events: auto; cursor: pointer; white-space: nowrap;">
                    ${label}
                </span>
            </div>`,
		iconSize: [0, 0],
		iconAnchor: [0, 0],
		popupAnchor: [0, -10],
	});
};

/**
 * Logic Hub: Resolves the appropriate Leaflet icon
 */
export const resolveMarkerIcon = (marker) => {
	const { icon, type, label, fontSize, category } = marker;

	// 1. Existing Text Marker logic
	if (type === 'text' || icon === 'text') {
		return createTextMarker(label, fontSize);
	}

	// 2. Invisible / Null Icon
	if (!icon && !category) {
		return invisibleIcon;
	}

	// 3. Lucide Marker logic
	let markerColor = '#d97706';
	const cat = category?.toLowerCase() || '';
	if (cat.includes('combat') || cat.includes('danger')) markerColor = '#dc2626'; // Red
	if (cat.includes('magic') || cat.includes('shrine')) markerColor = '#7c3aed'; // Purple
	if (['city', 'location', 'town', 'points of interest'].includes(cat)) markerColor = '#059669'; // Emerald
	if (cat.includes('city') || cat.includes('town')) markerColor = '#1e40af'; // Blue
	if (['npcs', 'people'].includes(cat)) markerColor = '#d97706'; // Orange

	return createLucideMarker(category, markerColor);
};

// For session paths/dots
export const createDotIcon = (color) =>
	L.divIcon({
		className: 'path-dot',
		html: `<div style="background-color: ${color};" class="w-3 h-3 rounded-full border-2 border-white shadow-sm"></div>`,
		iconSize: [12, 12],
		iconAnchor: [6, 6],
	});

--- END OF features\atlas\utils\markerUtils.js ---

