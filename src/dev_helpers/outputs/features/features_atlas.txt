================================================================
PARTIAL BUNDLE: FEATURES ATLAS
================================================================

### PROJECT MAP (FILE STRUCTURE)
./
  main.jsx
  todo.md
  app/
    App.jsx
    AppRoutes.jsx
    components/
      RouteLoading.jsx
    styles/
      global.css
  domain/
    entity/
      api/
        entityService.js
      components/
        EntityBadge.jsx
        EntityIcon.jsx
        EntityLink.jsx
        EntityStatusIcon.jsx
      config/
        entityColors.js
        entityConfig.js
        entityIcons.js
        entityStyles.js
        entityTypes.js
      utils/
        attributeParser.js
        entityUtils.js
        statusUtils.js
  features/
    admin/
      api/
        adminService.js
      components/
        AdminForm.jsx
        AdminFormStyles.js
        AdvancedFilter.jsx
        EncounterManager.jsx
        EntitySearch.jsx
        EventTagger.jsx
        ImageLibraryModal.jsx
        MarkdownEditor.jsx
        MarkdownEditorImpl.jsx
        QuestObjectiveManager.jsx
        RelationshipManager.jsx
        SessionEventManager.jsx
        SmartColorPicker.jsx
        SmartImageInput.jsx
        TacticalMapManager.jsx
        atlas/
          AtlasForms.jsx
          editor/
            AtlasEditor.jsx
            AtlasEditorContext.jsx
            components/
              EditorLayerList.jsx
              EditorMapEvents.jsx
              EditorSidebar.jsx
              EditorToolbar.jsx
              VertexHandle.jsx
            layers/
              EditAreasLayer.jsx
              EditMarkersLayer.jsx
              EditOverlaysLayer.jsx
              EditPathsLayer.jsx
      config/
        adminStrategies.js
        imageManifest.json
      layouts/
        AdminLayout.jsx
      pages/
        BulkReplaceTool.jsx
        EntityEditorPage.jsx
        EntityListPage.jsx
        MapManagerPage.jsx
        MapMigrationTool.jsx
        SplitPaneManager.jsx
      utils/
        filterUtils.js
    atlas/
      MapPage.jsx
      useMapData.js
      api/
        mapService.js
      components/
        AtlasSidebar.jsx
        MapCanvas.jsx
        MapTools.jsx
        MapZoomHandler.jsx
        useMapCanvasViewModel.js
        __MapLayerControl.jsx
        layers/
          MapAreas.jsx
          MapMarkers.jsx
          MapOverlays.jsx
          MapRecaps.jsx
        sidebar/
          SidebarGroup.jsx
          SidebarItem.jsx
      config/
        mapConfig.js
      context/
        AtlasContext.jsx
      data/
        modularize.js
        refactor.js
        campaign_02/
          index.js
          faerun/
            index.js
      utils/
        mapNavigation.js
        markerUtils.js
        useAtlasSearch.jsx
    campaign/
      CampaignContext.jsx
      useCampaignData.js
      useCampaignPersistence.js
      useCampaignSelection.js
      api/
        campaignService.js
      components/
        CampaignCard.jsx
        CampaignSelect.jsx
    dashboard/
      DashboardPage.jsx
      api/
        dashboardService.js
      components/
        ActiveThreads.jsx
        ArchiveTree.jsx
        CampaignHeader.jsx
        CurrentArcMetadata.jsx
        CurrentStoryStack.jsx
        InsightsGrid.jsx
        PartyWidget.jsx
        QuickInsights.jsx
    graph/
      GraphPage.jsx
      useGraphView.js
      api/
        graphService.js
      components/
        CytoscapeCanvas.jsx
        GraphLegend.jsx
      config/
        graphStyles.js
      utils/
        graphMapper.js
    navigation/
      MainLayout.jsx
      useNavigation.js
      components/
        Sidebar.jsx
        SidebarFooter.jsx
        SidebarHeader.jsx
        SidebarNav.jsx
      config/
        navConfig.js
    search/
      GlobalSearch.jsx
      SearchContext.jsx
      useGlobalSearch.js
      api/
        searchService.js
      components/
        SearchFooter.jsx
        SearchModal.jsx
        SearchResultItem.jsx
        SearchResults.jsx
        SearchTrigger.jsx
      utils/
        searchMapper.js
    smart-text/
      SmartMarkdown.jsx
      useEntityIndex.js
      useSmartText.js
      components/
        EntityEmbed.jsx
        SmartEntityLink.jsx
    smart-tooltip/
      TooltipContainer.jsx
      TooltipContext.jsx
      useSmartPosition.js
      useTooltipState.js
      components/
        TooltipCard.jsx
      config/
        tooltipProfiles.js
    table-of-contents/
      TableOfContents.jsx
      components/
        TocItem.jsx
        TocMobileDrawer.jsx
      hooks/
        useTocObserver.js
        useTocScroll.js
    timeline/
      TimelinePage.jsx
      useTimelineView.js
      api/
        timelineService.js
      components/
        TimelineArcHeader.jsx
        TimelineEvent.jsx
        TimelineSession.jsx
      utils/
        eventStyles.js
    wiki/
      useEntityView.js
      useWikiNavigation.js
      WikiLayout.jsx
      api/
        wikiService.js
      components/
        EncounterTimeline.jsx
        EntityBody.jsx
        EntityHeader.jsx
        EntityHistory.jsx
        EntityLocalGraph.jsx
        EntityMiniMap.jsx
        EntitySidebar.jsx
        QuestObjectives.jsx
        SessionMentions.jsx
        WikiEntryView.jsx
        character/
          CharacterSidebar.jsx
          CharacterStats.jsx
          RelationshipNetwork.jsx
        landing/
          EntityGridCard.jsx
          EntityPosterCard.jsx
          EntityTableGroup.jsx
          Swimlane.jsx
        navigation/
          SidebarEmptyState.jsx
          WikiSidebar.jsx
          WikiSidebarHeader.jsx
          WikiSidebarList.jsx
          sidebar/
            CollapsibleGroup.jsx
            EntityListItem.jsx
            PriorityIcon.jsx
            SidebarTreeItem.jsx
            StatusIcon.jsx
      config/
        groupingConfig.js
        viewStrategies.js
      hooks/
        useEntityContent.js
        useEntityFetching.js
        useEntityGrouping.js
        useEntityHeader.js
        useEntitySidebar.js
      layouts/
        CharacterLayout.jsx
        SessionLayout.jsx
        StandardLayout.jsx
      pages/
        WikiDetailPage.jsx
        WikiLandingPage.jsx
      utils/
        attributeMapper.js
        eventMapper.js
        relationshipMapper.js
        wikiEntryMapper.js
        wikiUtils.js
  shared/
    api/
      supabaseClient.js
    components/
      ErrorBoundary.jsx
      layout/
        CollapsibleSection.jsx
        SplitView.jsx
        TabContainer.jsx
      markdown/
        MarkdownRenderer.jsx
        MarkdownWithToC.jsx
      ui/
        Breadcrumbs.jsx
        Button.jsx
        Card.jsx
        DevAdminButton.jsx
        Drawer.jsx
        EmptyState.jsx
        HighlightBadge.jsx
        LoadingSpinner.jsx
        SectionDivider.jsx
    hooks/
      useBreadcrumbs.js
      useTheme.js
    utils/
      imageUtils.js
      markdownUtils.js
      textUtils.js
      theme/
        colorUtils.js
        cssUtils.js

================================================================
### SOURCE CODE
================================================================

--- FILE: features\atlas\MapPage.jsx ---
// features/atlas/MapPage.jsx
import React from 'react';
import { AtlasProvider } from './context/AtlasContext';
import { MapCanvas } from './components/MapCanvas';
import { AtlasSidebar } from './components/AtlasSidebar';

const MapView = () => {
	return (
		// relative is CRITICAL here for the absolute sidebar positioning on mobile
		<div className='flex h-full w-full relative overflow-hidden bg-background'>
			<MapCanvas />
			<AtlasSidebar />
		</div>
	);
};

export default function MapPage() {
	return (
		<AtlasProvider>
			<MapView />
		</AtlasProvider>
	);
}

--- END OF features\atlas\MapPage.jsx ---

--- FILE: features\atlas\useMapData.js ---
import { useSearchParams } from 'react-router-dom';
import { useMemo, useEffect, useState } from 'react';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { getMapConfig } from './utils/mapNavigation'; // Legacy File Loader
import { fetchMapByKey } from './api/mapService'; // New DB Loader

export function useMapData() {
	const { campaignData, campaignId, isLoading: isCampaignLoading } = useCampaign();
	const [searchParams, setSearchParams] = useSearchParams();

	// New State for DB Data
	const [dbMapData, setDbMapData] = useState(null);
	const [isMapLoading, setIsMapLoading] = useState(false);

	const urlMapKey = searchParams.get('map');

	// 1. Determine effective map key
	const currentMapKey = urlMapKey || campaignData?.defaultMap;

	// 2. Fetch from DB when key changes
	useEffect(() => {
		let isMounted = true;

		const loadMap = async () => {
			if (!currentMapKey || !campaignId) return;

			setIsMapLoading(true);
			try {
				// Try DB First
				const fromDb = await fetchMapByKey(campaignId, currentMapKey);

				if (isMounted) {
					if (fromDb) {
						console.log(`[Atlas] Loaded map '${currentMapKey}' from Database.`);
						setDbMapData(fromDb);
					} else {
						// If not in DB, fall back to null (will use Legacy below)
						console.log(`[Atlas] Map '${currentMapKey}' not found in DB. Using legacy files.`);
						setDbMapData(null);
					}
				}
			} catch (err) {
				console.error(err);
			} finally {
				if (isMounted) setIsMapLoading(false);
			}
		};

		loadMap();

		return () => {
			isMounted = false;
		};
	}, [campaignId, currentMapKey]);

	// 3. Update URL if needed (legacy behavior)
	useEffect(() => {
		if (!urlMapKey && campaignData?.defaultMap) {
			setSearchParams({ map: campaignData.defaultMap }, { replace: true });
		}
	}, [urlMapKey, campaignData, setSearchParams]);

	// 4. Merge Logic: DB > Legacy File
	const mapConfig = useMemo(() => {
		if (dbMapData) return dbMapData;
		// Fallback to file registry
		return getMapConfig(currentMapKey, campaignData);
	}, [dbMapData, currentMapKey, campaignData]);

	const viewData = useMemo(() => {
		if (!mapConfig) return null;

		const { metadata, annotations, paths, areas, overlays } = mapConfig;

		if (!metadata) return null;

		const scaleFactor = Math.pow(2, metadata.sizes.maxZoom);
		const bounds = [
			[-metadata.sizes.imageHeight / scaleFactor, 0],
			[0, metadata.sizes.imageWidth / scaleFactor],
		];

		const markers = [];
		if (annotations) {
			Object.entries(annotations).forEach(([categoryKey, category]) => {
				if (category.items) {
					category.items.forEach((item) => {
						markers.push({
							...item,
							category: category.name,
							categoryId: categoryKey,
							position: [Number(item.lat), Number(item.lng)],
						});
					});
				}
			});
		}

		const mapAreas = [];
		if (areas) {
			Object.values(areas).forEach((category) => {
				category.items.forEach((area) => {
					mapAreas.push({
						...area,
						positions: area.points.map((p) => p.coordinates),
					});
				});
			});
		}

		return {
			config: metadata,
			bounds,
			markers,
			sessions: paths || [],
			areas: mapAreas,
			overlays: overlays || [],
		};
	}, [mapConfig]);

	const navigateToMap = (mapKey) => {
		setSearchParams({ map: mapKey });
	};

	return {
		data: viewData,
		currentMapKey,
		navigateToMap,
		isLoading: isMapLoading, // Return specific map loading state
	};
}

--- END OF features\atlas\useMapData.js ---

--- FILE: features\atlas\api\mapService.js ---
import { supabase } from '@/shared/api/supabaseClient';

/**
 * Fetches a specific map by its URL key for the active campaign.
 */
export const fetchMapByKey = async (campaignId, mapKey) => {
	if (!campaignId || !mapKey) return null;

	const { data, error } = await supabase
		.from('maps')
		.select('*')
		.eq('campaign_id', campaignId)
		.eq('key', mapKey)
		.maybeSingle();

	if (error) {
		console.error('[MapService] Error fetching map:', error);
		return null;
	}

	if (!data) return null;

	// Reconstruct the object structure
	return {
		// Merge 'config' (metadata + parentId) back to the root level
		// so the UI can find mapConfig.parentId if needed
		...data.config,
		metadata: data.config, // Keep a specific metadata key for compatibility

		// Spread the content data (annotations, paths, etc)
		...data.data,
	};
};

export const upsertMap = async (campaignId, mapKey, title, config, contentData) => {
	const payload = {
		campaign_id: campaignId,
		key: mapKey,
		title: title,
		config: config,
		data: contentData,
		updated_at: new Date(),
	};

	const { data, error } = await supabase
		.from('maps')
		.upsert(payload, { onConflict: 'campaign_id, key' })
		.select()
		.single();

	if (error) throw error;
	return data;
};

export const fetchCampaignMaps = async (campaignId) => {
	const { data, error } = await supabase.from('maps').select('id, key, title').eq('campaign_id', campaignId);

	if (error) throw error;
	return data;
};

/**
 * Updates only the content data (markers, paths, etc) of a map.
 */
export const updateMapData = async (mapId, contentData) => {
	const { error } = await supabase
		.from('maps')
		.update({
			data: contentData,
			updated_at: new Date(),
		})
		.eq('id', mapId);

	if (error) throw error;
	return true;
};

--- END OF features\atlas\api\mapService.js ---

--- FILE: features\atlas\components\AtlasSidebar.jsx ---
import React, { useState } from 'react';
import { clsx } from 'clsx';
import {
	Map as MapIcon,
	Search,
	Layers,
	BookOpen,
	Navigation,
	LocateFixed,
	PanelLeftClose,
	PanelLeftOpen,
	Menu,
	X,
} from 'lucide-react';
import { useAtlas } from '../context/AtlasContext';
import { useAtlasSearch } from '../utils/useAtlasSearch';
import { SidebarItem } from './sidebar/SidebarItem';
import { SidebarGroup } from './sidebar/SidebarGroup';

export const AtlasSidebar = () => {
	const { mapData, isLoading, activeTab, setActiveTab, visibility, toggleItem, toggleGroup, flyTo } = useAtlas();
	const { searchTerm, setSearchTerm, filteredData } = useAtlasSearch(mapData);

	const [isMobileOpen, setIsMobileOpen] = useState(false);
	const [isDesktopCollapsed, setIsDesktopCollapsed] = useState(false);

	if (isLoading || !filteredData) return null;
	const title = mapData.config.label || mapData.config.title || 'Atlas';

	const handleFlyTo = (pos) => {
		flyTo(pos);
		if (window.innerWidth < 768) setIsMobileOpen(false);
	};

	const Tab = ({ id, icon: Icon, label }) => (
		<button
			onClick={() => setActiveTab(id)}
			className={clsx(
				'flex-1 flex flex-col items-center justify-center gap-1 py-2 text-[10px] font-bold uppercase tracking-wider transition-colors border-b-2',
				activeTab === id
					? 'border-primary text-primary bg-primary/5'
					: 'border-transparent text-muted-foreground hover:bg-black/5'
			)}>
			<Icon size={14} />
			<span className='hidden md:inline'>{label}</span>
		</button>
	);

	return (
		<>
			{/* Mobile Trigger */}
			<div className='absolute top-4 left-4 z-[400] md:hidden'>
				{!isMobileOpen && (
					<button
						onClick={() => setIsMobileOpen(true)}
						className='p-2 bg-background border border-border shadow-lg rounded-md text-foreground'>
						<Menu size={20} />
					</button>
				)}
			</div>

			{/* Desktop Collapsed Strip */}
			{isDesktopCollapsed && (
				<div className='hidden md:flex flex-col h-full w-10 bg-muted border-l border-border z-20 items-center py-4 gap-4'>
					<button
						onClick={() => setIsDesktopCollapsed(false)}
						className='p-1.5 hover:bg-black/5 rounded text-muted-foreground'>
						<PanelLeftClose size={18} />
					</button>
				</div>
			)}

			{/* Sidebar Container */}
			<div
				className={clsx(
					'flex flex-col h-full bg-muted border-l border-border shadow-2xl z-[500] transition-transform duration-300',
					'absolute top-0 left-0 w-full md:w-72 md:static',
					isMobileOpen ? 'translate-x-0' : '-translate-x-full md:translate-x-0',
					isDesktopCollapsed && 'md:hidden'
				)}>
				{/* Header */}
				<div className='p-3 border-b border-border bg-muted flex flex-col gap-2 shrink-0'>
					<div className='flex items-center justify-between'>
						<div className='flex items-center gap-2 text-foreground font-serif font-bold text-sm'>
							<MapIcon size={16} className='text-primary' />
							<span className='truncate'>{title}</span>
						</div>
						<div className='flex gap-1'>
							<button
								onClick={() => setIsDesktopCollapsed(true)}
								className='hidden md:block p-1 text-muted-foreground hover:text-primary'>
								<PanelLeftOpen size={16} />
							</button>
							<button onClick={() => setIsMobileOpen(false)} className='md:hidden p-2 text-muted-foreground'>
								<X size={20} />
							</button>
						</div>
					</div>
					<div className='relative'>
						<Search className='absolute left-2.5 top-2 text-muted-foreground/50' size={12} />
						<input
							type='text'
							placeholder='Search...'
							value={searchTerm}
							onChange={(e) => setSearchTerm(e.target.value)}
							className='w-full bg-background border border-border rounded text-xs pl-7 pr-2 py-1.5 focus:border-primary outline-none'
						/>
					</div>
				</div>

				{/* Tabs */}
				<div className='flex border-b border-border bg-muted/50 shrink-0'>
					<Tab id='locations' icon={LocateFixed} label='Places' />
					<Tab id='journal' icon={BookOpen} label='Journal' />
					<Tab id='layers' icon={Layers} label='Layers' />
				</div>

				{/* Content */}
				<div className='flex-1 overflow-y-auto custom-scrollbar p-1 bg-muted/30'>
					{/* PLACES TAB */}
					{activeTab === 'locations' && (
						<div className='space-y-0.5'>
							{filteredData.groups.map((group) => (
								<SidebarGroup
									key={group.id}
									label={group.label}
									items={group.items}
									visibility={visibility}
									onToggleItem={toggleItem}
									onToggleGroup={toggleGroup}
									onFlyTo={handleFlyTo}
								/>
							))}
							{filteredData.groups.length === 0 && (
								<div className='p-4 text-center text-xs text-muted-foreground italic'>No locations found.</div>
							)}
						</div>
					)}

					{/* JOURNAL TAB */}
					{activeTab === 'journal' && (
						<div className='space-y-0.5'>
							{filteredData.sessions.map((session, idx) => (
								<SidebarItem
									key={`session-${idx}`}
									label={session.name}
									icon={Navigation}
									isVisible={visibility[`session-${session.name}`]}
									onToggle={() => toggleItem(`session-${session.name}`)}
									onNavigate={() => handleFlyTo(session.points?.[0]?.coordinates)}
								/>
							))}
						</div>
					)}

					{/* LAYERS TAB */}
					{activeTab === 'layers' && (
						<div className='space-y-4 p-2 pb-10'>
							{/* Base Layers */}
							<div className='bg-background/50 rounded-lg p-2 border border-border/50'>
								<div className='text-[10px] font-bold text-muted-foreground uppercase tracking-wider mb-2 flex items-center gap-2 px-2'>
									<MapIcon size={12} /> Base Layers
								</div>
								<div className='space-y-0.5'>
									{filteredData.areas.length > 0 ? (
										<SidebarGroup
											label='Regions'
											items={filteredData.areas}
											visibility={visibility}
											onToggleItem={toggleItem}
											onToggleGroup={toggleGroup}
											onFlyTo={handleFlyTo}
										/>
									) : (
										<div className='px-3 py-1 text-xs text-muted-foreground italic opacity-70'>No regions found.</div>
									)}
								</div>
							</div>

							{/* Overlays */}
							<div className='bg-background/50 rounded-lg p-2 border border-border/50'>
								<div className='text-[10px] font-bold text-muted-foreground uppercase tracking-wider mb-2 flex items-center gap-2 px-2'>
									<Layers size={12} /> Overlays
								</div>
								{filteredData.overlays.map((o, idx) => (
									<SidebarItem
										key={`overlay-${idx}`}
										label={o.name}
										icon={Layers}
										isVisible={visibility[`overlay-${o.name}`]}
										onToggle={() => toggleItem(`overlay-${o.name}`)}
										onNavigate={() => handleFlyTo(o.bounds?.[0])}
									/>
								))}
								{filteredData.overlays.length === 0 && (
									<div className='px-3 py-1 text-xs text-muted-foreground italic opacity-70'>
										No overlays available.
									</div>
								)}
							</div>
						</div>
					)}
				</div>
			</div>

			{/* Mobile Backdrop */}
			{isMobileOpen && (
				<div className='fixed inset-0 bg-black/50 z-[400] md:hidden' onClick={() => setIsMobileOpen(false)} />
			)}
		</>
	);
};

--- END OF features\atlas\components\AtlasSidebar.jsx ---

--- FILE: features\atlas\components\MapCanvas.jsx ---
import { useEffect, useRef } from 'react';
import { MapContainer, TileLayer, useMap } from 'react-leaflet';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import { MapMarkers } from './layers/MapMarkers';
import { MapRecaps } from './layers/MapRecaps';
import { MapAreas } from './layers/MapAreas';
import { MapOverlays } from './layers/MapOverlays';
import { MapTools } from './MapTools';
import { MapZoomHandler } from './MapZoomHandler';
import { useAtlas } from '../context/AtlasContext';
import LoadingSpinner from '@/shared/components/ui/LoadingSpinner';

const MapController = ({ config, flyToTarget }) => {
	const map = useMap();
	const prevMapId = useRef();

	useEffect(() => {
		if (!config || !config.sizes) return;
		const scaleFactor = Math.pow(2, config.sizes.maxZoom);
		const bounds = [
			[-config.sizes.imageHeight / scaleFactor, 0],
			[0, config.sizes.imageWidth / scaleFactor],
		];

		map.setMaxBounds(L.latLngBounds(bounds).pad(0.1));
		if (prevMapId.current !== config.key) {
			map.fitBounds(bounds, { animate: false });
			prevMapId.current = config.key;
		}
	}, [map, config]);

	useEffect(() => {
		if (flyToTarget) map.flyTo(flyToTarget, config.sizes.maxZoom, { animate: true, duration: 1.5 });
	}, [map, flyToTarget, config]);

	return null;
};

export const MapCanvas = () => {
	const { mapData, isLoading, visibility, flyToTarget } = useAtlas();
	const wrapperRef = useRef(null);

	if (isLoading || !mapData) {
		return (
			<div className='flex-1 flex items-center justify-center bg-[#1a1412]'>
				<LoadingSpinner text='Unrolling...' className='text-amber-500' />
			</div>
		);
	}

	const { config, markers, sessions, overlays, areas } = mapData;
	const visibleMarkers = markers.filter((m) => visibility[m.id]);
	const visibleSessions = sessions.filter((s) => visibility[`session-${s.name}`]);
	const visibleOverlays = overlays.filter((o) => visibility[`overlay-${o.name}`]);
	const visibleAreas = areas.filter((a) => visibility[a.id]);

	const isAbsolute = config.path.startsWith('http');
	const baseUrl = isAbsolute
		? config.path
		: `https://raw.githubusercontent.com/aethere92/dnd-campaign-map/main/${config.path}`;
	const tileUrl = `${baseUrl}/{z}/{x}_{y}.${config.fileExtension || 'png'}`;

	return (
		<div ref={wrapperRef} className='flex-1 relative h-full bg-background'>
			<MapContainer
				center={[0, 0]}
				zoom={0}
				crs={L.CRS.Simple}
				minZoom={0}
				maxZoom={config.sizes.maxZoom}
				scrollWheelZoom={true}
				attributionControl={false}
				zoomControl={false}
				style={{ height: '100%', width: '100%', background: 'transparent' }}>
				<MapController config={config} flyToTarget={flyToTarget} />
				<MapZoomHandler referenceZoom={3} />
				<TileLayer key={tileUrl} url={tileUrl} noWrap={true} maxNativeZoom={config.sizes.maxZoom} />

				<MapOverlays overlays={visibleOverlays} />
				<MapAreas areas={visibleAreas} />
				<MapRecaps sessions={visibleSessions} />
				<MapMarkers markers={visibleMarkers} />
				<MapTools containerRef={wrapperRef} />
			</MapContainer>
		</div>
	);
};

--- END OF features\atlas\components\MapCanvas.jsx ---

--- FILE: features\atlas\components\MapTools.jsx ---
import { useState, useEffect } from 'react';
import { useMap } from 'react-leaflet';
import { Maximize, Minimize, Crosshair } from 'lucide-react';
import { clsx } from 'clsx';

export const MapTools = ({ bounds, containerRef }) => {
	const map = useMap();
	const [isFullscreen, setIsFullscreen] = useState(false);

	// Sync state if user presses ESC or browser exit
	useEffect(() => {
		const onFullScreenChange = () => {
			setIsFullscreen(!!document.fullscreenElement);
		};
		document.addEventListener('fullscreenchange', onFullScreenChange);
		return () => document.removeEventListener('fullscreenchange', onFullScreenChange);
	}, []);

	const handleCenter = (e) => {
		e.stopPropagation();
		if (bounds) {
			map.fitBounds(bounds, { animate: true, duration: 1 });
		}
	};

	const toggleFullscreen = (e) => {
		e.stopPropagation();
		if (!containerRef?.current) return;

		if (!document.fullscreenElement) {
			containerRef.current.requestFullscreen().catch((err) => {
				console.error(`Error attempting to enable fullscreen: ${err.message}`);
			});
		} else {
			document.exitFullscreen();
		}
	};

	// Reusable Button Style
	const Btn = ({ onClick, icon: Icon, title, active }) => (
		<button
			onClick={onClick}
			title={title}
			className={clsx(
				'flex items-center justify-center w-8 h-8 transition-colors first:rounded-t-md last:rounded-b-md border-b last:border-b-0',
				// FIX: Semantic Theme Colors
				'bg-card border-border text-muted-foreground hover:bg-muted hover:text-primary',
				active && 'bg-primary/10 text-primary'
			)}>
			<Icon size={16} strokeWidth={2.5} />
		</button>
	);

	return (
		<div className='leaflet-top leaflet-left'>
			<div className='leaflet-control leaflet-bar !border-0 !shadow-xl !m-3 rounded-md overflow-hidden border border-border/50'>
				<Btn onClick={handleCenter} icon={Crosshair} title='Center Map' />
				<Btn
					onClick={toggleFullscreen}
					icon={isFullscreen ? Minimize : Maximize}
					title={isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen'}
					active={isFullscreen}
				/>
			</div>
		</div>
	);
};

--- END OF features\atlas\components\MapTools.jsx ---

--- FILE: features\atlas\components\MapZoomHandler.jsx ---
import { useEffect } from 'react';
import { useMap, useMapEvents } from 'react-leaflet';

export const MapZoomHandler = ({ referenceZoom = 3 }) => {
	const map = useMap();

	const updateScale = () => {
		const zoom = map.getZoom();

		// 1. Calculate Geographic Scale (Standard map math: 2^diff)
		const geoScale = Math.pow(2, zoom - referenceZoom);

		// 2. Apply Clamping Strategy
		// - Shrink when zooming out (zoom < ref) to prevent overlap.
		// - Stop growing when zooming in (zoom > ref) to keep text readable/non-obstructive.
		// - Min limit 0.1 to prevent total disappearance.
		const scale = Math.min(1, Math.max(0.1, geoScale));

		map.getContainer().style.setProperty('--label-scale', scale);

		// Inverse scale (if we ever need elements to grow while map shrinks)
		map.getContainer().style.setProperty('--inv-label-scale', 1 / scale);
	};

	useMapEvents({
		zoom: updateScale,
		zoomend: updateScale,
	});

	useEffect(() => {
		updateScale();
	}, [map]);

	return null;
};

--- END OF features\atlas\components\MapZoomHandler.jsx ---

--- FILE: features\atlas\components\useMapCanvasViewModel.js ---
import { useState, useEffect, useMemo } from 'react';
import { BookOpen, MapPin, Image as ImageIcon, Map as MapIcon } from 'lucide-react';

export function useMapCanvasViewModel(data) {
	// 1. Initialize Visibility
	const [visibility, setVisibility] = useState(() => {
		const init = { areas: false };
		if (!data) return init;

		// Initialize marker categories
		const uniqueCats = [...new Set(data.markers.map((m) => m.category))].filter(Boolean);
		uniqueCats.forEach((cat) => {
			init[`marker-cat-${cat}`] = true;
		});

		// Initialize individual markers (new)
		data.markers.forEach((m) => {
			if (m.label) init[`marker-item-${m.label}`] = true;
		});

		// Sessions/Overlays: OFF by default
		data.sessions.forEach((s) => (init[`session-${s.name}`] = false));
		data.overlays.forEach((o) => (init[`overlay-${o.name}`] = false));

		return init;
	});

	// Sync with data updates
	useEffect(() => {
		if (!data) return;
		setVisibility((prev) => {
			const next = { ...prev };
			let changed = false;

			// Sync Categories
			const uniqueCats = [...new Set(data.markers.map((m) => m.category))].filter(Boolean);
			uniqueCats.forEach((cat) => {
				const key = `marker-cat-${cat}`;
				if (next[key] === undefined) {
					next[key] = true;
					changed = true;
				}
			});

			// Sync Items
			data.markers.forEach((m) => {
				const key = `marker-item-${m.label}`;
				if (next[key] === undefined) {
					next[key] = true;
					changed = true;
				}
			});

			return changed ? next : prev;
		});
	}, [data?.markers]);

	const toggleLayer = (id) => {
		setVisibility((prev) => ({ ...prev, [id]: !prev[id] }));
	};

	// 2. Control Groups Configuration
	const sidebarGroups = useMemo(() => {
		if (!data) return [];

		const groups = [];

		// 1. Sessions
		if (data.sessions.length > 0) {
			groups.push({
				id: 'sessions-group',
				label: 'Sessions & Paths',
				items: data.sessions
					.map((s) => ({
						label: s.name,
						id: `session-${s.name}`,
						position: s.points[0]?.coordinates,
					}))
					.filter((i) => i.position),
			});
		}

		// 2. Markers by Category
		const uniqueCats = [...new Set(data.markers.map((m) => m.category))].filter(Boolean).sort();

		uniqueCats.forEach((cat) => {
			const catId = `marker-cat-${cat}`;
			const catMarkers = data.markers.filter((m) => m.category === cat);

			groups.push({
				id: catId,
				label: cat,
				items: catMarkers.map((m) => ({
					label: m.label,
					id: `marker-item-${m.label}`, // Individual ID
					position: m.position,
				})),
			});
		});

		// 3. Overlays
		if (data.overlays.length > 0) {
			groups.push({
				id: 'overlays-group',
				label: 'Overlays',
				items: data.overlays.map((o) => ({
					label: o.name,
					id: `overlay-${o.name}`,
					position: o.bounds[0],
				})),
			});
		}

		// 4. Areas
		if (data.areas.length > 0) {
			groups.push({
				id: 'areas',
				label: 'Regions & Areas',
				items: data.areas.map((a) => ({
					label: a.name,
					id: 'areas', // Shared ID for all areas for now
					position: a.positions[0],
				})),
			});
		}

		return groups;
	}, [data]);

	// 3. Filter Layers
	// Logic: Marker is visible if Category is ON AND Individual Item is ON
	const visibleMarkers = useMemo(
		() =>
			data?.markers.filter(
				(m) =>
					visibility[`marker-cat-${m.category}`] !== false && // Default to true if undefined
					visibility[`marker-item-${m.label}`] !== false
			) || [],
		[data, visibility]
	);

	const visibleSessions = useMemo(
		() => data?.sessions.filter((s) => visibility[`session-${s.name}`] || visibility['sessions-group']) || [],
		[data, visibility]
	);

	const visibleOverlays = useMemo(
		() => data?.overlays.filter((o) => visibility[`overlay-${o.name}`] || visibility['overlays-group']) || [],
		[data, visibility]
	);

	return {
		visibility,
		toggleLayer,
		sidebarGroups,
		visibleMarkers,
		visibleSessions,
		visibleOverlays,
		showAreas: visibility['areas'],
	};
}

--- END OF features\atlas\components\useMapCanvasViewModel.js ---

--- FILE: features\atlas\components\__MapLayerControl.jsx ---
import { useState, useEffect, useRef } from 'react';
import { Layers, ChevronDown, ChevronRight, Eye, EyeOff, Check } from 'lucide-react';
import { clsx } from 'clsx';
import L from 'leaflet';

// Reusable styled Group Header matching Sidebar aesthetics
const Group = ({ label, icon: Icon, children, defaultOpen = true }) => {
	const [isOpen, setIsOpen] = useState(defaultOpen);
	if (!children || children.length === 0) return null;

	return (
		<div className='mb-2'>
			<button
				onClick={(e) => {
					e.stopPropagation();
					setIsOpen(!isOpen);
				}}
				className='flex items-center w-full text-left text-[10px] font-bold uppercase tracking-widest text-muted-foreground hover:text-primary transition-colors mb-1 select-none font-sans'>
				<span className='mr-1 opacity-70'>{isOpen ? <ChevronDown size={10} /> : <ChevronRight size={10} />}</span>
				<span className='flex items-center gap-1.5'>
					{Icon && <Icon size={12} />}
					{label}
				</span>
			</button>
			{isOpen && <div className='pl-2 space-y-0.5 border-l border-black/5 ml-1'>{children}</div>}
		</div>
	);
};

// Toggle Item with explicit Checkmark UI
const ToggleItem = ({ label, checked, onChange }) => (
	<div
		className='flex items-center gap-2 cursor-pointer group px-2 py-1 hover:bg-black/5 rounded-md transition-colors select-none'
		onClick={(e) => {
			e.stopPropagation();
			onChange();
		}}>
		{/* Custom Checkbox UI - Reduced size */}
		<div
			className={clsx(
				'w-3.5 h-3.5 rounded-[3px] border flex items-center justify-center transition-all shadow-sm shrink-0',
				checked ? 'bg-amber-600 border-amber-700 text-white' : 'bg-card border-border group-hover:border-amber-400'
			)}>
			{checked && <Check size={10} strokeWidth={3.5} />}
		</div>

		<span
			className={clsx(
				'text-[11px] font-medium leading-tight pt-0.5 font-sans',
				checked ? 'text-foreground' : 'text-muted-foreground'
			)}>
			{label}
		</span>
	</div>
);

export const MapLayerControl = ({ groups, visibility, toggleLayer }) => {
	const [expanded, setExpanded] = useState(true);
	const containerRef = useRef(null);

	// Prevent Leaflet map interactions when clicking inside this control
	useEffect(() => {
		if (containerRef.current) {
			L.DomEvent.disableClickPropagation(containerRef.current);
			L.DomEvent.disableScrollPropagation(containerRef.current);
		}
	}, []);

	return (
		<div className='leaflet-top leaflet-right font-sans' style={{ pointerEvents: 'none', zIndex: 1000 }}>
			<div
				ref={containerRef}
				className={clsx(
					'leaflet-control m-3 transition-all duration-200 ease-in-out',
					// Theme colors
					'bg-[#fdfbf7] border border-[#c9c2b8] rounded-lg shadow-xl overflow-hidden'
				)}
				style={{ pointerEvents: 'auto' }}>
				{/* Header */}
				<div
					className='flex items-center justify-between p-2.5 bg-[#f2efe9] border-b border-[#c9c2b8] cursor-pointer min-w-[180px]'
					onClick={() => setExpanded(!expanded)}>
					<div className='flex items-center gap-2 text-xs font-serif font-bold text-amber-900'>
						<Layers size={14} />
						<span>Atlas Layers</span>
					</div>
					<button className='p-0.5 hover:bg-black/5 rounded text-amber-900/70'>
						{expanded ? <Eye size={12} /> : <EyeOff size={12} />}
					</button>
				</div>

				{/* Content */}
				{expanded && (
					<div className='p-2 max-h-[60vh] overflow-y-auto w-56 custom-scrollbar bg-background/50'>
						{groups.overlays?.length > 0 && (
							<Group label='Overlays' icon={groups.icons.overlays} defaultOpen={false}>
								{groups.overlays.map((l) => (
									<ToggleItem
										key={l.id}
										label={l.label}
										checked={!!visibility[l.id]}
										onChange={() => toggleLayer(l.id)}
									/>
								))}
							</Group>
						)}

						{groups.sessions?.length > 0 && (
							<Group label='Journal & Paths' icon={groups.icons.sessions} defaultOpen={false}>
								{groups.sessions.map((l) => (
									<ToggleItem
										key={l.id}
										label={l.label}
										checked={!!visibility[l.id]}
										onChange={() => toggleLayer(l.id)}
									/>
								))}
							</Group>
						)}

						{groups.markers?.length > 0 && (
							<Group label='Map Markers' icon={groups.icons.markers} defaultOpen={true}>
								{groups.markers.map((cat) => (
									<ToggleItem
										key={cat.id}
										label={cat.label}
										checked={!!visibility[cat.id]}
										onChange={() => toggleLayer(cat.id)}
									/>
								))}
							</Group>
						)}

						<div className='mt-2 pt-2 border-t border-black/5'>
							<ToggleItem
								label='Show Areas & Regions'
								checked={!!visibility['areas']}
								onChange={() => toggleLayer('areas')}
							/>
						</div>
					</div>
				)}
			</div>
		</div>
	);
};

--- END OF features\atlas\components\__MapLayerControl.jsx ---

--- FILE: features\atlas\components\layers\MapAreas.jsx ---
import React from 'react';
import { Polygon, Marker } from 'react-leaflet';
import { createLabelIcon } from '@/features/atlas/utils/markerUtils';

// Helper to calculate centroid if no manual position exists
const getCentroid = (points) => {
	if (!points || points.length === 0) return [0, 0];
	let lat = 0,
		lng = 0;
	points.forEach((p) => {
		lat += Array.isArray(p) ? p[0] : p.coordinates[0];
		lng += Array.isArray(p) ? p[1] : p.coordinates[1];
	});
	return [lat / points.length, lng / points.length];
};

export const MapAreas = ({ areas }) => {
	if (!areas || areas.length === 0) return null;

	return (
		<>
			{areas.map((area, idx) => {
				// Handle data structure variance (DB vs File)
				const positions = area.positions || (area.points || []).map((p) => p.coordinates);
				if (!positions || positions.length === 0) return null;

				const center = area.labelPosition || getCentroid(positions);

				return (
					<React.Fragment key={`${area.name}-${idx}`}>
						<Polygon
							positions={positions}
							pathOptions={{
								color: area.lineColor || 'transparent',
								fillColor: area.interiorColor || '#ff0000',
								fillOpacity: 0.3,
								weight: 1,
							}}
						/>
						{/* Text Label Marker */}
						{area.name && (
							<Marker
								position={center}
								icon={createLabelIcon(area.name, {
									color: area.labelColor || '#ffffff',
									fontSize: area.fontSize || 16,
									rotation: area.textRotation || 0,
									bgColor: area.labelBgColor || 'transparent',
									bgOpacity: area.labelBgOpacity || 0,
									isSelected: false,
								})}
								interactive={false} // Pass events through to polygon/map
							/>
						)}
					</React.Fragment>
				);
			})}
		</>
	);
};

--- END OF features\atlas\components\layers\MapAreas.jsx ---

--- FILE: features\atlas\components\layers\MapMarkers.jsx ---
import { Marker, Popup } from 'react-leaflet';
import { ArrowRight, BookOpen, Map as MapIcon } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import { clsx } from 'clsx';
import { useAtlas } from '../../context/AtlasContext'; // Import the new Context
import { resolveMarkerIcon } from '@/features/atlas/utils/markerUtils';
import { useEntityIndex } from '@/features/smart-text/useEntityIndex';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import { resolveImageUrl, parseAttributes } from '@/shared/utils/imageUtils';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

export const MapMarkers = ({ markers }) => {
	const navigate = useNavigate();
	const { map: entityMap } = useEntityIndex();

	// Get navigation function directly from context
	const { navigateToMap } = useAtlas();

	if (!markers || markers.length === 0) return null;

	return (
		<>
			{markers.map((marker, idx) => {
				// Generate Leaflet Icon
				const leafletIcon = resolveMarkerIcon(marker);

				// Attempt to link Marker -> Entity (by Name)
				const entityMatch = Array.from(entityMap.values()).find(
					(e) => e.name.toLowerCase() === marker.label.toLowerCase()
				);

				const entityAttrs = entityMatch ? parseAttributes(entityMatch.attributes) : {};

				// Prepare Display Data (Merge Marker Data with Entity Data)
				const displayData = {
					title: marker.label,
					category:
						marker.category && marker.category !== 'default'
							? marker.category
							: entityMatch
							? entityMatch.type
							: 'Point of Interest',
					description: marker.description
						? marker.description
						: entityMatch
						? getAttributeValue(entityAttrs, ['summary', 'narrative']) || entityMatch.description
						: null,
					image: entityMatch ? resolveImageUrl(entityAttrs, 'background') : null,
				};

				const entityConfig = entityMatch ? getEntityConfig(entityMatch.type) : null;

				// --- Handlers ---

				const handleWikiNav = (e) => {
					e.stopPropagation();
					if (entityMatch) {
						navigate(`/wiki/${entityMatch.type}/${entityMatch.id}`);
					}
				};

				const handleMapNav = (e) => {
					e.stopPropagation();
					if (marker.mapLink) {
						navigateToMap(marker.mapLink);
					}
				};

				return (
					<Marker
						// Use a stable key if possible, falling back to label+index
						key={marker.id || `${marker.label}-${idx}`}
						position={marker.position}
						icon={leafletIcon}>
						<Popup className='custom-popup-clean' closeButton={false}>
							<div className='flex flex-col w-full font-sans bg-background rounded-lg overflow-hidden border border-border shadow-sm'>
								{/* Header Image */}
								{displayData.image && (
									<div className='h-24 w-full relative bg-muted'>
										<img src={displayData.image} alt={displayData.title} className='w-full h-full object-cover' />
										<div className='absolute inset-0 bg-gradient-to-t from-[var(--background)] via-[var(--background)]/80 via-30% to-transparent pointer-events-none' />
									</div>
								)}

								{/* Content Body */}
								<div className={clsx('px-4 pb-3', displayData.image ? 'pt-2 -mt-8 relative z-10' : 'pt-4')}>
									<div className='flex items-start justify-between gap-2'>
										<div>
											<span
												className={clsx(
													'text-[10px] font-bold uppercase tracking-wider block mb-0.5',
													entityConfig ? entityConfig.tailwind.text : 'text-muted-foreground'
												)}>
												{displayData.category}
											</span>
											<h3 className='font-serif font-bold text-lg leading-tight text-foreground drop-shadow-sm'>
												{displayData.title}
											</h3>
										</div>
										{entityConfig && (
											<div
												className={clsx(
													'p-1.5 rounded-md border shrink-0 bg-background/80 backdrop-blur-sm',
													entityConfig.tailwind.border,
													entityConfig.tailwind.text
												)}>
												<entityConfig.icon size={14} />
											</div>
										)}
									</div>

									<div className='h-px w-full bg-border/50 my-3' />

									<div className='text-xs text-muted-foreground leading-relaxed max-h-32 overflow-y-auto custom-scrollbar'>
										{displayData.description || <span className='italic opacity-70'>No details available.</span>}
									</div>
								</div>

								{/* Actions Footer */}
								{(marker.mapLink || entityMatch) && (
									<div className='bg-muted/50 p-2 border-t border-border flex flex-col gap-1'>
										{/* Action: Enter Sub-Map */}
										{marker.mapLink && (
											<button
												onClick={handleMapNav}
												className='w-full flex items-center justify-between px-3 py-1.5 rounded hover:bg-primary/10 text-primary transition-colors text-xs font-bold uppercase tracking-wide group'>
												<span className='flex items-center gap-2'>
													<MapIcon size={12} /> Enter Location
												</span>
												<ArrowRight size={12} className='group-hover:translate-x-1 transition-transform' />
											</button>
										)}

										{/* Action: Open Wiki */}
										{entityMatch && (
											<button
												onClick={handleWikiNav}
												className='w-full flex items-center justify-between px-3 py-1.5 rounded hover:bg-background text-muted-foreground hover:text-foreground transition-colors text-xs font-semibold group'>
												<span className='flex items-center gap-2'>
													<BookOpen size={12} /> View Encyclopedia
												</span>
												<ArrowRight size={12} className='opacity-0 group-hover:opacity-100 transition-opacity' />
											</button>
										)}
									</div>
								)}
							</div>
						</Popup>
					</Marker>
				);
			})}
		</>
	);
};

--- END OF features\atlas\components\layers\MapMarkers.jsx ---

--- FILE: features\atlas\components\layers\MapOverlays.jsx ---
import { ImageOverlay } from 'react-leaflet';

export const MapOverlays = ({ overlays }) => {
	if (!overlays || overlays.length === 0) return null;

	return (
		<>
			{overlays.map((overlay, idx) => (
				<ImageOverlay
					key={`${overlay.name}-${idx}`}
					url={`${import.meta.env.BASE_URL}${overlay.image}`}
					bounds={overlay.bounds}
					opacity={1}
				/>
			))}
		</>
	);
};

--- END OF features\atlas\components\layers\MapOverlays.jsx ---

--- FILE: features\atlas\components\layers\MapRecaps.jsx ---
import { Fragment } from 'react';
import { Polyline, Marker, Popup } from 'react-leaflet';
import { Calendar } from 'lucide-react';
import { createDotIcon } from '@/features/atlas/utils/markerUtils';

export const MapRecaps = ({ sessions }) => {
	if (!sessions || sessions.length === 0) return null;

	return (
		<>
			{sessions.map((session, idx) => (
				<Fragment key={session.name}>
					<Polyline
						positions={session.points.map((p) => p.coordinates)}
						pathOptions={{ color: session.lineColor || '#d97706', weight: 3, dashArray: '8, 8', opacity: 0.7 }}
					/>

					{session.points
						.filter((p) => p.text)
						.map((point, pIdx) => (
							<Marker
								key={`${session.name}-p-${pIdx}`}
								position={point.coordinates}
								icon={createDotIcon(session.lineColor || '#d97706')}>
								<Popup closeButton={false} className='leaflet-popup-clean'>
									<div className='flex flex-col w-[200px] font-sans bg-background rounded-md overflow-hidden shadow-sm border border-border/50'>
										{/* Header */}
										<div className='px-3 py-2 bg-amber-500/10/80 border-b border-primary/20 flex items-center gap-2'>
											<Calendar size={12} className='text-primary' />
											<span className='text-[10px] font-bold uppercase tracking-wider text-primary'>
												{session.name}
											</span>
										</div>

										{/* Content */}
										<div className='p-3 px-5 text-xs text-foreground/90 leading-snug'>{point.text}</div>
									</div>
								</Popup>
							</Marker>
						))}
				</Fragment>
			))}
		</>
	);
};

--- END OF features\atlas\components\layers\MapRecaps.jsx ---

--- FILE: features\atlas\components\sidebar\SidebarGroup.jsx ---
import React, { useState } from 'react';
import { clsx } from 'clsx';
import { ChevronRight, ChevronDown, Eye, EyeOff } from 'lucide-react';
import { SidebarItem } from './SidebarItem';

export const SidebarGroup = ({ label, items, visibility, onToggleItem, onToggleGroup, onFlyTo }) => {
	const [isExpanded, setIsExpanded] = useState(true);

	const visibleCount = items.filter((i) => visibility[i.id]).length;
	const isAllVisible = visibleCount === items.length;
	const isNoneVisible = visibleCount === 0;
	const isMixed = !isAllVisible && !isNoneVisible;

	const handleGroupToggle = (e) => {
		e.stopPropagation();
		// If mixed, turn ON. If all on, turn OFF.
		onToggleGroup(
			items.map((i) => i.id),
			isMixed ? true : !isAllVisible
		);
	};

	return (
		<div className='mb-0.5'>
			<div className='flex items-center gap-1 px-2 py-2 md:py-1 sticky top-0 bg-muted/95 backdrop-blur-sm z-10 select-none group/header hover:bg-black/5 rounded-md'>
				<button
					onClick={() => setIsExpanded(!isExpanded)}
					className='p-1 text-muted-foreground hover:text-foreground transition-colors'>
					{isExpanded ? <ChevronDown size={12} /> : <ChevronRight size={12} />}
				</button>

				<span
					className='flex-1 text-xs md:text-[10px] font-bold uppercase tracking-wider text-muted-foreground cursor-pointer truncate'
					onClick={() => setIsExpanded(!isExpanded)}>
					{label} <span className='opacity-50 ml-1'>({items.length})</span>
				</span>

				<button
					onClick={handleGroupToggle}
					className={clsx(
						'p-1 rounded transition-colors',
						isAllVisible ? 'text-primary' : isMixed ? 'text-primary/70' : 'text-muted-foreground/30'
					)}>
					{isAllVisible ? <Eye size={12} /> : isMixed ? <Eye size={12} className='opacity-50' /> : <EyeOff size={12} />}
				</button>
			</div>

			{isExpanded && (
				<div className='pl-1 space-y-0.5 ml-2 border-l border-border/40'>
					{items.map((item) => (
						<SidebarItem
							key={item.id}
							label={item.label}
							isVisible={!!visibility[item.id]}
							onToggle={() => onToggleItem(item.id)}
							onNavigate={() => onFlyTo(item.position)}
						/>
					))}
				</div>
			)}
		</div>
	);
};

--- END OF features\atlas\components\sidebar\SidebarGroup.jsx ---

--- FILE: features\atlas\components\sidebar\SidebarItem.jsx ---
import React from 'react';
import { clsx } from 'clsx';
import { Eye, EyeOff, Crosshair } from 'lucide-react';

export const SidebarItem = ({ label, isVisible, onToggle, onNavigate, icon: Icon }) => (
	<div className='flex items-center gap-1 px-2 py-2 md:py-0.5 hover:bg-black/5 group rounded-md transition-colors min-w-0'>
		<button
			onClick={(e) => {
				e.stopPropagation();
				onToggle();
			}}
			className={clsx(
				'p-2 md:p-0.5 rounded transition-colors shrink-0 outline-none',
				isVisible ? 'text-primary hover:bg-primary/10' : 'text-muted-foreground/40 hover:text-muted-foreground'
			)}>
			{isVisible ? <Eye size={14} /> : <EyeOff size={14} />}
		</button>

		<button
			onClick={onNavigate}
			className='flex-1 flex items-center text-left min-w-0 gap-2 py-1 md:py-0.5 outline-none'>
			{Icon && <Icon size={12} className='text-muted-foreground/70 shrink-0' />}
			<span
				className={clsx(
					'text-sm md:text-xs truncate transition-opacity',
					!isVisible && 'opacity-50 text-muted-foreground'
				)}>
				{label}
			</span>
		</button>

		<button
			onClick={(e) => {
				e.stopPropagation();
				onNavigate();
			}}
			className='hidden md:block p-0.5 text-muted-foreground/0 group-hover:text-muted-foreground group-hover:opacity-100 opacity-0 transition-all'
			title='Fly To'>
			<Crosshair size={12} />
		</button>
	</div>
);

--- END OF features\atlas\components\sidebar\SidebarItem.jsx ---

--- FILE: features\atlas\config\mapConfig.js ---

--- END OF features\atlas\config\mapConfig.js ---

--- FILE: features\atlas\context\AtlasContext.jsx ---
import React, { createContext, useContext, useState, useEffect, useMemo, useCallback } from 'react';
import { useSearchParams } from 'react-router-dom';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { fetchMapByKey } from '../api/mapService';

const AtlasContext = createContext(null);

export const AtlasProvider = ({ children }) => {
	const { campaignId, campaignData } = useCampaign();
	const [searchParams, setSearchParams] = useSearchParams();

	// -- Data State --
	const [mapData, setMapData] = useState(null);
	const [isLoading, setIsLoading] = useState(false);

	// -- UI State --
	const [visibility, setVisibility] = useState({});
	const [flyToTarget, setFlyToTarget] = useState(null);
	const [activeTab, setActiveTab] = useState('locations');

	const currentMapKey = searchParams.get('map') || campaignData?.defaultMap;

	// Helper: Generate Unique ID
	const generateId = (type, categoryKey, index, label) => {
		const safeLabel = (label || 'unknown').replace(/\s+/g, '_').toLowerCase();
		return `${type}-${categoryKey}-${index}-${safeLabel}`;
	};

	// 1. Fetch Data
	useEffect(() => {
		let isMounted = true;
		const load = async () => {
			if (!campaignId || !currentMapKey) return;

			setIsLoading(true);
			try {
				const data = await fetchMapByKey(campaignId, currentMapKey);
				if (isMounted) {
					setMapData(data);
					if (data) initializeVisibility(data);
				}
			} catch (err) {
				console.error(err);
			} finally {
				if (isMounted) setIsLoading(false);
			}
		};
		load();
		return () => {
			isMounted = false;
		};
	}, [campaignId, currentMapKey]);

	// 2. Initialize Visibility Helper
	const initializeVisibility = (data) => {
		const initial = { areas: true };

		// Markers
		if (data.annotations) {
			Object.entries(data.annotations).forEach(([key, cat]) => {
				if (cat.items) {
					cat.items.forEach((item, index) => {
						const id = item.id || generateId('marker', key, index, item.label);
						initial[id] = true;
					});
				}
			});
		}

		// Areas
		if (data.areas) {
			Object.entries(data.areas).forEach(([key, cat]) => {
				if (cat.items) {
					cat.items.forEach((item, index) => {
						const id = item.id || generateId('area', key, index, item.name);
						initial[id] = true;
					});
				}
			});
		}

		// Default OFF
		if (data.paths) data.paths.forEach((p) => (initial[`session-${p.name}`] = false));
		if (data.overlays) data.overlays.forEach((o) => (initial[`overlay-${o.name}`] = false));

		setVisibility(initial);
	};

	// 3. Actions
	const navigateToMap = (key) => setSearchParams({ map: key });

	const flyTo = useCallback((position) => {
		setFlyToTarget(position);
	}, []);

	const toggleItem = useCallback((id) => {
		setVisibility((prev) => ({ ...prev, [id]: !prev[id] }));
	}, []);

	const toggleGroup = useCallback((ids, forceState = null) => {
		setVisibility((prev) => {
			const next = { ...prev };
			const targetState = forceState !== null ? forceState : !prev[ids[0]];
			ids.forEach((id) => (next[id] = targetState));
			return next;
		});
	}, []);

	// 4. View Model
	const viewData = useMemo(() => {
		if (!mapData) return null;

		const markers = [];
		const groups = [];

		// Process Markers
		if (mapData.annotations) {
			Object.entries(mapData.annotations).forEach(([key, category]) => {
				const groupItems = (category.items || []).map((item, index) => ({
					...item,
					// Generate stable, unique ID using index
					id: item.id || generateId('marker', key, index, item.label),
					category: category.name,
					categoryId: key,
					position: [Number(item.lat), Number(item.lng)],
				}));

				markers.push(...groupItems);

				if (groupItems.length > 0) {
					groups.push({
						id: key,
						label: category.name,
						items: groupItems,
					});
				}
			});
		}

		// Process Areas
		const areas = mapData.areas
			? Object.entries(mapData.areas).flatMap(([key, cat]) =>
					(cat.items || []).map((item, index) => {
						// Centroid fallback
						const pos = item.labelPosition || (item.positions && item.positions[0]) || [0, 0];
						return {
							...item,
							id: item.id || generateId('area', key, index, item.name),
							label: item.name,
							position: pos,
						};
					})
			  )
			: [];

		return {
			config: mapData,
			markers,
			groups,
			sessions: mapData.paths || [],
			overlays: mapData.overlays || [],
			areas: areas,
		};
	}, [mapData]);

	const value = {
		mapData: viewData,
		rawConfig: mapData,
		isLoading,
		visibility,
		activeTab,
		setActiveTab,
		toggleItem,
		toggleGroup,
		navigateToMap,
		flyTo,
		flyToTarget,
	};

	return <AtlasContext.Provider value={value}>{children}</AtlasContext.Provider>;
};

export const useAtlas = () => {
	const context = useContext(AtlasContext);
	if (!context) throw new Error('useAtlas must be used within AtlasProvider');
	return context;
};

--- END OF features\atlas\context\AtlasContext.jsx ---

--- FILE: features\atlas\data\modularize.js ---
import fs from 'fs';
import path from 'path';

// ==========================================
// CONFIGURATION
// ==========================================
const INPUT_FILE = 'campaign_01.js';

// We output deep into src so it's ready for Vite to pick up
const OUTPUT_DIR = 'campaign_01';

// ==========================================
// 1. HELPER: JS Stringifier
// ==========================================
function toJsString(obj, indentLevel = 0) {
	const indent = '\t'.repeat(indentLevel);
	const nextIndent = '\t'.repeat(indentLevel + 1);

	if (obj === null) return 'null';
	if (typeof obj === 'undefined') return 'undefined';

	// Force single quotes for strings
	if (typeof obj === 'string') {
		const escaped = obj.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n');
		return `'${escaped}'`;
	}

	if (typeof obj !== 'object') return String(obj);

	if (Array.isArray(obj)) {
		if (obj.length === 0) return '[]';
		// Keep coordinates [x, y] on one line
		if (obj.length === 2 && typeof obj[0] === 'number') {
			return `[${obj.join(', ')}]`;
		}
		const items = obj.map((item) => toJsString(item, indentLevel + 1));
		return `[\n${nextIndent}${items.join(`,\n${nextIndent}`)}\n${indent}]`;
	}

	const keys = Object.keys(obj);
	if (keys.length === 0) return '{}';

	const props = keys.map((key) => {
		const value = toJsString(obj[key], indentLevel + 1);
		// Don't quote simple keys
		const cleanKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `'${key}'`;
		return `${cleanKey}: ${value}`;
	});

	return `{\n${nextIndent}${props.join(`,\n${nextIndent}`)}\n${indent}}`;
}

// ==========================================
// 2. HELPER: Recursive Extractor
// ==========================================
function extractMapsRecursively(obj, parentId = null, collectedMaps = []) {
	// If it has metadata, we treat it as a Map configuration
	if (obj.metadata) {
		const mapId = obj.metadata.mapId || 'unknown_map';

		// Clone to avoid mutating the original deeply nested structure immediately
		const mapData = { ...obj };

		// Add explicit parent ID for navigation logic
		if (parentId) {
			mapData.parentId = parentId;
		}

		// Check for children (submaps)
		if (obj.submaps) {
			Object.keys(obj.submaps).forEach((category) => {
				const categoryObj = obj.submaps[category];
				Object.keys(categoryObj).forEach((submapKey) => {
					// Recurse down
					extractMapsRecursively(categoryObj[submapKey], mapId, collectedMaps);
				});
			});
		}

		// Clean up the object (we don't want the nested submaps in the flat config)
		delete mapData.submaps;

		collectedMaps.push({
			id: mapId,
			data: mapData,
		});
	} else {
		// If it's the root container (CAMPAIGN_01)
		Object.keys(obj).forEach((key) => {
			if (obj[key] && typeof obj[key] === 'object') {
				extractMapsRecursively(obj[key], null, collectedMaps);
			}
		});
	}
	return collectedMaps;
}

// ==========================================
// 3. MAIN PROCESS
// ==========================================
try {
	console.log(` Reading ${INPUT_FILE}...`);
	let fileContent = fs.readFileSync(INPUT_FILE, 'utf8');

	// Remove "export" keywords so we can eval it locally
	const cleanCode = fileContent.replace(/export const/g, 'const');

	// Evaluate to get the object
	const { CAMPAIGN_01 } = eval(`${cleanCode}; ({ CAMPAIGN_01 });`);

	console.log(` Flattening map hierarchy...`);
	const allMaps = extractMapsRecursively(CAMPAIGN_01);
	console.log(`   Found ${allMaps.length} maps.`);

	// Prepare Directories
	if (fs.existsSync(OUTPUT_DIR)) {
		fs.rmSync(OUTPUT_DIR, { recursive: true, force: true });
	}
	fs.mkdirSync(path.join(OUTPUT_DIR, 'maps'), { recursive: true });

	const registryImports = [];
	const registryExports = [];

	// Process every map found
	allMaps.forEach((map) => {
		const mapId = map.id;
		const mapData = map.data;
		const mapDir = path.join(OUTPUT_DIR, 'maps', mapId);

		fs.mkdirSync(mapDir, { recursive: true });

		const localImports = [];

		// -----------------------------------------------------
		// FILE EXTRACTION LOGIC
		// We replace data with strings like 'PLACEHOLDER_PATHS'
		// and then regex replace them later.
		// -----------------------------------------------------

		// 1. Paths
		if (mapData.paths && mapData.paths.length > 0) {
			const content = `export const paths = ${toJsString(mapData.paths)};`;
			fs.writeFileSync(path.join(mapDir, 'paths.js'), content);

			localImports.push(`import { paths } from './paths.js';`);
			mapData.paths = 'PLACEHOLDER_PATHS';
		}

		// 2. Annotations (POIs, NPCs, etc)
		if (mapData.annotations && Object.keys(mapData.annotations).length > 0) {
			const content = `export const annotations = ${toJsString(mapData.annotations)};`;
			fs.writeFileSync(path.join(mapDir, 'annotations.js'), content);

			localImports.push(`import { annotations } from './annotations.js';`);
			mapData.annotations = 'PLACEHOLDER_ANNOTATIONS';
		}

		// 3. Areas (Polygons)
		if (mapData.areas && Object.keys(mapData.areas).length > 0) {
			const content = `export const areas = ${toJsString(mapData.areas)};`;
			fs.writeFileSync(path.join(mapDir, 'areas.js'), content);

			localImports.push(`import { areas } from './areas.js';`);
			mapData.areas = 'PLACEHOLDER_AREAS';
		}

		// 4. Overlays
		if (mapData.overlays && mapData.overlays.length > 0) {
			const content = `export const overlays = ${toJsString(mapData.overlays)};`;
			fs.writeFileSync(path.join(mapDir, 'overlays.js'), content);

			localImports.push(`import { overlays } from './overlays.js';`);
			mapData.overlays = 'PLACEHOLDER_OVERLAYS';
		}

		// Generate the Map Config String
		let configStr = toJsString(mapData);

		// Replace Placeholders with actual variables
		// We match quotes around them because toJsString adds quotes to strings
		configStr = configStr.replace(/['"]PLACEHOLDER_PATHS['"]/g, 'paths');
		configStr = configStr.replace(/['"]PLACEHOLDER_ANNOTATIONS['"]/g, 'annotations');
		configStr = configStr.replace(/['"]PLACEHOLDER_AREAS['"]/g, 'areas');
		configStr = configStr.replace(/['"]PLACEHOLDER_OVERLAYS['"]/g, 'overlays');

		const mapVarName = mapId.toUpperCase();

		const indexContent = `
${localImports.join('\n')}

export const ${mapVarName} = ${configStr};
`;
		fs.writeFileSync(path.join(mapDir, 'index.js'), indexContent.trim());

		// Prepare Registry
		registryImports.push(`import { ${mapVarName} } from './maps/${mapId}/index.js';`);
		registryExports.push(`    [${mapVarName}.metadata.mapId]: ${mapVarName}`);
	});

	// ==========================================
	// 4. GENERATE REGISTRY
	// ==========================================
	const registryContent = `
${registryImports.join('\n')}

export const CAMPAIGN_01 = {
    name: 'Campaign 01',
    maps: {
${registryExports.join(',\n')}
    }
};
`;
	fs.writeFileSync(path.join(OUTPUT_DIR, 'index.js'), registryContent.trim());

	console.log(` Done! Created modular React structure in:`);
	console.log(`    ${OUTPUT_DIR}/`);
	console.log(`       index.js (Import this in your App)`);
	console.log(`       maps/ (Individual map configs)`);
} catch (err) {
	console.error(' Error:', err.message);
	console.error(err.stack);
}

--- END OF features\atlas\data\modularize.js ---

--- FILE: features\atlas\data\refactor.js ---
import fs from 'fs';

// 1. CONFIGURATION
const INPUT_FILE = 'campaign_01.js';
const OUTPUT_FILE = 'campaign_01_cleaned.js';

// Keys to completely remove
const KEYS_TO_REMOVE = ['icon', 'iconType', 'animation', 'pointColor', 'pointWidth', 'filter', 'loot', 'image'];

// Keys to force to the top of objects
const KEY_ORDER = ['label', 'name', 'lat', 'lng', 'coordinates', 'text'];

// 2. HELPERS

/**
 * Recursively cleans and reorders objects
 */
function cleanAndReorder(obj) {
	if (!obj || typeof obj !== 'object') {
		return obj;
	}

	if (Array.isArray(obj)) {
		return obj.map(cleanAndReorder);
	}

	const newObj = {};

	// 1. Add High Priority Keys first
	KEY_ORDER.forEach((key) => {
		if (Object.prototype.hasOwnProperty.call(obj, key)) {
			newObj[key] = cleanAndReorder(obj[key]);
		}
	});

	// 2. Add remaining keys (filtering out removed ones)
	Object.keys(obj).forEach((key) => {
		if (KEYS_TO_REMOVE.includes(key)) return;
		if (KEY_ORDER.includes(key)) return;

		newObj[key] = cleanAndReorder(obj[key]);
	});

	return newObj;
}

/**
 * Converts object to formatted JS string using single quotes
 */
function toJsString(obj, indentLevel = 0) {
	const indent = '\t'.repeat(indentLevel);
	const nextIndent = '\t'.repeat(indentLevel + 1);

	if (obj === null) return 'null';
	if (typeof obj === 'undefined') return 'undefined';

	// Force single quotes for strings
	if (typeof obj === 'string') {
		const escaped = obj.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n');
		return `'${escaped}'`;
	}

	if (typeof obj !== 'object') return String(obj);

	if (Array.isArray(obj)) {
		if (obj.length === 0) return '[]';

		// Keep coordinate arrays [x, y] on one line
		if (obj.length === 2 && typeof obj[0] === 'number') {
			return `[${obj.join(', ')}]`;
		}

		const items = obj.map((item) => toJsString(item, indentLevel + 1));
		return `[\n${nextIndent}${items.join(`,\n${nextIndent}`)}\n${indent}]`;
	}

	const keys = Object.keys(obj);
	if (keys.length === 0) return '{}';

	const props = keys.map((key) => {
		const value = toJsString(obj[key], indentLevel + 1);
		const cleanKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `'${key}'`;
		return `${cleanKey}: ${value}`;
	});

	return `{\n${nextIndent}${props.join(`,\n${nextIndent}`)}\n${indent}}`;
}

// 3. MAIN LOGIC
try {
	console.log(`Reading ${INPUT_FILE}...`);
	let fileContent = fs.readFileSync(INPUT_FILE, 'utf8');

	// Remove "export" keywords to allow local eval
	const cleanCode = fileContent.replace(/export const/g, 'const');

	// Evaluate code to get objects
	const { CAMPAIGN_01, CAMPAIGN_01_ALIASES } = eval(`
        ${cleanCode}
        ;({ CAMPAIGN_01, CAMPAIGN_01_ALIASES });
    `);

	console.log('Cleaning and reordering data...');
	const cleanedCampaign = cleanAndReorder(CAMPAIGN_01);
	const cleanedAliases = cleanAndReorder(CAMPAIGN_01_ALIASES);

	// 4. DATA EXTRACTION

	// Extract Paths
	let WORLD_MAP_PATHS = [];
	if (cleanedCampaign.world_maps?.paths) {
		WORLD_MAP_PATHS = cleanedCampaign.world_maps.paths;
		// Set placeholder
		cleanedCampaign.world_maps.paths = 'PLACEHOLDER_PATHS';
	}

	// Extract Korinis
	let KORINIS_ISLAND = null;
	if (cleanedCampaign.world_maps?.submaps?.islands?.korinis_island) {
		KORINIS_ISLAND = cleanedCampaign.world_maps.submaps.islands.korinis_island;
		cleanedCampaign.world_maps.submaps.islands.korinis_island = 'PLACEHOLDER_KORINIS';
	}

	// Extract Unnamed Island
	let UNNAMED_ISLAND = null;
	if (cleanedCampaign.world_maps?.submaps?.islands?.unnamed_island_01) {
		UNNAMED_ISLAND = cleanedCampaign.world_maps.submaps.islands.unnamed_island_01;
		cleanedCampaign.world_maps.submaps.islands.unnamed_island_01 = 'PLACEHOLDER_UNNAMED';
	}

	// 5. FILE GENERATION
	console.log('Generating output string...');

	let output = `// ==========================================
// ALIASES
// ==========================================
export const CAMPAIGN_01_ALIASES = ${toJsString(cleanedAliases)};

// ==========================================
// EXTRACTED DATA
// ==========================================

// --- World Map Paths ---
const WORLD_MAP_PATHS = ${toJsString(WORLD_MAP_PATHS)};

`;

	if (KORINIS_ISLAND) {
		output += `// --- Submap: Korinis Island ---\nconst KORINIS_ISLAND = ${toJsString(KORINIS_ISLAND)};\n\n`;
	}

	if (UNNAMED_ISLAND) {
		output += `// --- Submap: Unnamed Island ---\nconst UNNAMED_ISLAND = ${toJsString(UNNAMED_ISLAND)};\n\n`;
	}

	// Generate main string
	let mainString = toJsString(cleanedCampaign);

	// 6. REPLACE PLACEHOLDERS (Robust Regex)
	// Matches 'PLACEHOLDER' or "PLACEHOLDER"
	mainString = mainString.replace(/['"]PLACEHOLDER_PATHS['"]/g, 'WORLD_MAP_PATHS');
	mainString = mainString.replace(/['"]PLACEHOLDER_KORINIS['"]/g, 'KORINIS_ISLAND');
	mainString = mainString.replace(/['"]PLACEHOLDER_UNNAMED['"]/g, 'UNNAMED_ISLAND');

	output += `// ==========================================
// MAIN CAMPAIGN OBJECT
// ==========================================
export const CAMPAIGN_01 = ${mainString};
`;

	fs.writeFileSync(OUTPUT_FILE, output);
	console.log(`\n Success! File saved to: ${OUTPUT_FILE}`);
} catch (err) {
	console.error(' Error:', err.message);
	console.error(err.stack);
}

--- END OF features\atlas\data\refactor.js ---

--- FILE: features\atlas\data\campaign_02\index.js ---
import { FAERUN_MAP } from './faerun/index.js';

export const campaign_002_map_data = {
	name: 'Red Hand of Doom',
	defaultMap: 'faerun_map',
	maps: {
		// The ID here MUST match the mapId in the metadata
		[FAERUN_MAP.metadata.mapId]: FAERUN_MAP,
	},
};

--- END OF features\atlas\data\campaign_02\index.js ---

--- FILE: features\atlas\data\campaign_02\faerun\index.js ---
// features/atlas/data/maps/faerun/index.js

export const FAERUN_MAP = {
	metadata: {
		mapId: 'faerun_map',
		path: 'https://yffukfulnggfhlgoyowg.supabase.co/storage/v1/object/public/atlas/maps/faerun',
		fileExtension: 'webp',
		sizes: {
			maxZoom: 7,
			imageWidth: 18607,
			imageHeight: 15017,
		},
		label: 'Faern',
	},
	annotations: {
		locations: { name: 'Locations', items: [] },
		pois: { name: 'Points of Interest', items: [] },
	},
	paths: [],
	areas: {},
	overlays: [],
};

--- END OF features\atlas\data\campaign_02\faerun\index.js ---

--- FILE: features\atlas\utils\mapNavigation.js ---
import { campaign_001_map_data } from '@/features/atlas/data/campaign_01/index';
import { campaign_002_map_data } from '@/features/atlas/data/campaign_02/index'; // Ensure path is correct

// FIX: Keys updated to match Database "map_data" attribute values
export const CAMPAIGN_REGISTRY = {
	campaign_001_map_data: campaign_001_map_data,
	campaign_002_map_data: campaign_002_map_data,
};

export const getMapConfig = (mapKey, campaignData) => {
	// 1. Use context data if provided
	// If campaignData is null (loading/error), we don't want to default to Campaign 1 immediately
	// or it will flash the wrong map.
	const rootData = campaignData;

	if (!rootData) return null;

	// 2. Direct Lookup
	if (rootData.maps && rootData.maps[mapKey]) {
		return rootData.maps[mapKey];
	}

	console.warn(`[getMapConfig] Map ID not found: ${mapKey}`);
	return null;
};

--- END OF features\atlas\utils\mapNavigation.js ---

--- FILE: features\atlas\utils\markerUtils.js ---
import React from 'react';
import L from 'leaflet';
import { renderToString } from 'react-dom/server';
import {
	Skull,
	MapPin,
	Castle,
	User,
	Tent,
	Sparkles,
	Home,
	Sword,
	Anchor,
	Mountain,
	Scroll,
	Circle,
	Square,
	Star,
	Flag,
	RotateCcw, // Added this import
} from 'lucide-react';

// 1. Extended Icon Map
// Maps both semantic categories (e.g., 'combat') and direct icon names (e.g., 'skull')
const ICON_MAP = {
	// Semantic Categories
	combat: Skull,
	danger: Skull,
	encounter: Sword,
	city: Castle,
	town: Home,
	village: Home,
	npc: User,
	people: User,
	camp: Tent,
	magic: Sparkles,
	shrine: Sparkles,
	port: Anchor,
	landmark: MapPin,
	dungeon: Mountain,
	quest: Scroll,

	// Direct Dropdown Matches
	default: MapPin,
	mappin: MapPin,
	flag: Flag,
	circle: Circle,
	square: Square,
	star: Star,
	rotateccw: RotateCcw, // New mapping
	skull: Skull,
	castle: Castle,
	user: User,
	tent: Tent,
	sparkles: Sparkles,
	home: Home,
	sword: Sword,
	anchor: Anchor,
	mountain: Mountain,
	scroll: Scroll,
};

// Singleton for invisible/interactive-only markers
export const invisibleIcon = L.divIcon({
	className: 'bg-transparent border-none',
	html: '<div style="width: 100%; height: 100%;"></div>',
	iconSize: [20, 20],
	iconAnchor: [10, 10],
	popupAnchor: [0, -10],
});

/**
 * Creates a "Pin" style marker using a Lucide React Icon
 */
export const createPinMarker = (IconComponent, color = '#d97706') => {
	const iconHtml = renderToString(
		React.createElement(IconComponent, {
			size: 14,
			strokeWidth: 3,
			color: 'white',
		})
	);

	return L.divIcon({
		className: 'custom-marker-container',
		html: `
            <div class="relative group" style="width: 32px; height: 36px;">
                <svg width="32" height="36" viewBox="0 0 32 36" fill="none" xmlns="http://www.w3.org/2000/svg" style="filter: drop-shadow(0px 2px 2px rgba(0,0,0,0.2));">
                    <path d="M16 36C16 36 32 26.5 32 16C32 7.16344 24.8366 0 16 0C7.16344 0 0 7.16344 0 16C0 26.5 16 36 16 36Z" fill="white"/>
                    <path d="M16 33C16 33 29 24.5 29 16C29 8.8203 23.1797 3 16 3C8.8203 3 3 8.8203 3 16C3 24.5 16 33 16 33Z" fill="${color}"/>
                    <circle cx="16" cy="16" r="10" fill="white" fill-opacity="0.2"/>
                </svg>
                <div class="absolute top-[8px] left-[8px] w-[16px] h-[16px] flex items-center justify-center pointer-events-none transition-transform group-hover:-translate-y-0.5">
                    ${iconHtml}
                </div>
            </div>
        `,
		iconSize: [32, 36],
		iconAnchor: [16, 36],
		popupAnchor: [0, -36],
	});
};

/**
 * Creates a "Flat" style marker (Just the icon, no pin background)
 */
export const createFlatMarker = (IconComponent, color = '#d97706') => {
	const iconHtml = renderToString(
		React.createElement(IconComponent, {
			size: 24,
			strokeWidth: 2.5,
			color: color,
			fill: color,
			fillOpacity: 0.2,
		})
	);

	return L.divIcon({
		className: 'custom-flat-marker',
		html: `<div style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3)); transition: transform 0.2s;">${iconHtml}</div>`,
		iconSize: [24, 24],
		iconAnchor: [12, 12],
		popupAnchor: [0, -12],
	});
};

// Text Label Marker Generator
export const createTextMarker = (label, fontSize, color = '#2c1a0e') => {
	const sizeStyle = fontSize ? `${fontSize}px` : '1.5rem';
	return L.divIcon({
		className: 'map-text-marker',
		html: `
            <div style="transform: translate(-50%, -50%); width: max-content; text-align: center; display: flex; justify-content: center; align-items: center;">
                <span style="font-family: 'Inter', sans-serif; text-transform: uppercase; font-weight: 600; font-size: ${sizeStyle}; color: ${color}; text-shadow: 0 0 4px #fff, 0 0 8px #fff; pointer-events: auto; cursor: pointer; white-space: nowrap;">
                    ${label}
                </span>
            </div>`,
		iconSize: [0, 0],
		iconAnchor: [0, 0],
		popupAnchor: [0, -10],
	});
};

/**
 * Resolve Category Default Colors
 */
const getCategoryColor = (category) => {
	const cat = category?.toLowerCase() || '';
	if (cat.includes('combat') || cat.includes('danger')) return '#dc2626'; // Red
	if (cat.includes('magic') || cat.includes('shrine')) return '#7c3aed'; // Purple
	if (['city', 'location', 'town', 'points of interest'].includes(cat)) return '#059669'; // Emerald
	if (cat.includes('city') || cat.includes('town')) return '#1e40af'; // Blue
	if (['npcs', 'people'].includes(cat)) return '#d97706'; // Orange
	return '#d97706'; // Default Amber
};

/**
 * Logic Hub: Resolves the appropriate Leaflet icon
 */
export const resolveMarkerIcon = (marker) => {
	const { icon, type, label, fontSize, category, color, iconType, customIcon } = marker;

	// 1. Text Marker
	if (type === 'text' || icon === 'text') {
		return createTextMarker(label, fontSize, color || '#2c1a0e');
	}

	// 2. Invisible
	if (!icon && !category && !customIcon) {
		return invisibleIcon;
	}

	// 3. Determine Color (Manual override > Category default)
	const finalColor = color || getCategoryColor(category);

	// 4. Determine Icon Component
	let IconComponent = ICON_MAP.default;

	// Check specific custom icon setting first (matches your Dropdown values)
	if (customIcon && ICON_MAP[customIcon]) {
		IconComponent = ICON_MAP[customIcon];
	}
	// Also check 'icon' property in case DB saves it there instead of customIcon
	else if (icon && ICON_MAP[icon]) {
		IconComponent = ICON_MAP[icon];
	}
	// Fallback to category mapping
	else {
		const normalizedCat = category?.toLowerCase() || 'default';
		for (const [key, comp] of Object.entries(ICON_MAP)) {
			if (normalizedCat.includes(key)) {
				IconComponent = comp;
				break;
			}
		}
	}

	// 5. Render Style (Pin vs Flat)
	if (iconType === 'flat') {
		return createFlatMarker(IconComponent, finalColor);
	}

	return createPinMarker(IconComponent, finalColor);
};

// For session paths/dots
export const createDotIcon = (color) =>
	L.divIcon({
		className: 'path-dot',
		html: `<div style="background-color: ${color};" class="w-3 h-3 rounded-full border-2 border-white shadow-sm"></div>`,
		iconSize: [12, 12],
		iconAnchor: [6, 6],
	});

export const createLabelIcon = (text, options = {}) => {
	const {
		color = '#ffffff',
		fontSize = 16,
		rotation = 0,
		isSelected = false,
		bgColor = 'transparent',
		bgOpacity = 0,
	} = options;

	const hexToRgb = (hex) => {
		const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
		return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '0,0,0';
	};

	const bgRgba = bgOpacity > 0 && bgColor ? `rgba(${hexToRgb(bgColor)}, ${bgOpacity})` : 'transparent';
	const padding = '4px 12px';

	return L.divIcon({
		className: 'area-label-icon',
		html: `
            <div style="
                position: relative;
                width: max-content;
                /* Scale Logic: Controlled by MapZoomHandler */
                transform: translate(-50%, -50%) rotate(${rotation}deg) scale(var(--label-scale, 1));
                transform-origin: center center;
                will-change: transform; /* Performance optimization for zoom */
                
                color: ${color};
                font-size: ${fontSize}px;
                font-family: 'Cinzel', 'Inter', ui-serif, Georgia, serif; 
                font-weight: 700;
                text-align: center;
                white-space: nowrap;
                
                cursor: ${isSelected ? 'move' : 'pointer'};
                border: ${isSelected ? '2px dashed #3b82f6' : '1px solid transparent'};
                padding: ${padding};
                background-color: ${bgRgba};
                border-radius: 6px;
                pointer-events: auto;
                
                text-shadow: ${bgOpacity < 0.3 ? '0 1px 4px rgba(0,0,0,0.9)' : 'none'};
                box-shadow: ${isSelected ? '0 4px 12px rgba(0,0,0,0.3)' : 'none'};
                user-select: none;
                transition: border-color 0.2s, box-shadow 0.2s;
            ">
                ${text}
            </div>
        `,
		iconSize: [0, 0],
		iconAnchor: [0, 0],
	});
};

/**
 * Midpoint handle for splitting lines
 */
export const createMidpointIcon = () =>
	L.divIcon({
		className: 'midpoint-handle',
		html: `<div style="width: 8px; height: 8px; background: rgba(255,255,255,0.5); border: 1px solid #3b82f6; border-radius: 50%; opacity: 0.6; transition: opacity 0.2s;"></div>`,
		iconSize: [8, 8],
		iconAnchor: [4, 4],
	});

--- END OF features\atlas\utils\markerUtils.js ---

--- FILE: features\atlas\utils\useAtlasSearch.jsx ---
import { useState, useMemo } from 'react';

export const useAtlasSearch = (mapData) => {
	const [searchTerm, setSearchTerm] = useState('');

	const filteredData = useMemo(() => {
		if (!mapData) return null;

		const term = searchTerm.toLowerCase();
		const filterFn = (item) => item.label && item.label.toLowerCase().includes(term);

		return {
			groups: mapData.groups
				.map((g) => ({
					...g,
					items: g.items.filter(filterFn),
				}))
				.filter((g) => g.items.length > 0),

			sessions: mapData.sessions.filter((s) => s.name.toLowerCase().includes(term)),

			overlays: mapData.overlays.filter((o) => o.name.toLowerCase().includes(term)),

			areas: (mapData.areas || []).filter((a) => a.label && a.label.toLowerCase().includes(term)),
		};
	}, [mapData, searchTerm]);

	return { searchTerm, setSearchTerm, filteredData };
};

--- END OF features\atlas\utils\useAtlasSearch.jsx ---

