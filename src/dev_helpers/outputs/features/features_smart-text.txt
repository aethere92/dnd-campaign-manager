================================================================
PARTIAL BUNDLE: FEATURES SMART-TEXT
================================================================

### PROJECT MAP (FILE STRUCTURE)
./
  main.jsx
  todo.md
  app/
    App.jsx
    AppRoutes.jsx
    components/
      RouteLoading.jsx
    styles/
      global.css
  domain/
    entity/
      api/
        entityService.js
      components/
        EntityBadge.jsx
        EntityIcon.jsx
        EntityLink.jsx
        EntityStatusIcon.jsx
      config/
        entityColors.js
        entityConfig.js
        entityIcons.js
        entityStyles.js
        entityTypes.js
      utils/
        attributeParser.js
        entityUtils.js
        statusUtils.js
  features/
    admin/
      api/
        adminService.js
      components/
        AdminForm.jsx
        AdminFormStyles.js
        AdvancedFilter.jsx
        EncounterManager.jsx
        EntitySearch.jsx
        EventTagger.jsx
        ImageLibraryModal.jsx
        MarkdownEditor.jsx
        MarkdownEditorImpl.jsx
        QuestObjectiveManager.jsx
        RelationshipManager.jsx
        SessionEventManager.jsx
        SmartImageInput.jsx
        TacticalMapManager.jsx
      config/
        adminStrategies.js
        imageManifest.json
      layouts/
        AdminLayout.jsx
      pages/
        BulkReplaceTool.jsx
        EntityEditorPage.jsx
        EntityListPage.jsx
        SplitPaneManager.jsx
      utils/
        filterUtils.js
    atlas/
      MapPage.jsx
      useMapData.js
      components/
        AtlasSidebar.jsx
        MapCanvas.jsx
        MapTools.jsx
        useMapCanvasViewModel.js
        __MapLayerControl.jsx
        layers/
          MapAreas.jsx
          MapMarkers.jsx
          MapOverlays.jsx
          MapRecaps.jsx
      config/
        mapConfig.js
      data/
        modularize.js
        refactor.js
        campaign_02/
          index.js
          faerun/
            index.js
      utils/
        mapNavigation.js
        markerUtils.js
    campaign/
      CampaignContext.jsx
      useCampaignData.js
      useCampaignPersistence.js
      useCampaignSelection.js
      api/
        campaignService.js
      components/
        CampaignCard.jsx
        CampaignSelect.jsx
    dashboard/
      DashboardPage.jsx
      api/
        dashboardService.js
      components/
        ActiveThreads.jsx
        ArchiveTree.jsx
        CampaignHeader.jsx
        CurrentArcMetadata.jsx
        CurrentStoryStack.jsx
        InsightsGrid.jsx
        PartyWidget.jsx
        QuickInsights.jsx
    graph/
      GraphPage.jsx
      useGraphView.js
      api/
        graphService.js
      components/
        CytoscapeCanvas.jsx
        GraphLegend.jsx
      config/
        graphStyles.js
      utils/
        graphMapper.js
    navigation/
      MainLayout.jsx
      useNavigation.js
      components/
        Sidebar.jsx
        SidebarFooter.jsx
        SidebarHeader.jsx
        SidebarNav.jsx
      config/
        navConfig.js
    search/
      GlobalSearch.jsx
      SearchContext.jsx
      useGlobalSearch.js
      api/
        searchService.js
      components/
        SearchFooter.jsx
        SearchModal.jsx
        SearchResultItem.jsx
        SearchResults.jsx
        SearchTrigger.jsx
      utils/
        searchMapper.js
    smart-text/
      SmartMarkdown.jsx
      useEntityIndex.js
      useSmartText.js
      components/
        EntityEmbed.jsx
        SmartEntityLink.jsx
    smart-tooltip/
      TooltipContainer.jsx
      TooltipContext.jsx
      useSmartPosition.js
      useTooltipState.js
      components/
        TooltipCard.jsx
      config/
        tooltipProfiles.js
    table-of-contents/
      TableOfContents.jsx
      components/
        TocItem.jsx
        TocMobileDrawer.jsx
      hooks/
        useTocObserver.js
        useTocScroll.js
    timeline/
      TimelinePage.jsx
      useTimelineView.js
      api/
        timelineService.js
      components/
        TimelineArcHeader.jsx
        TimelineEvent.jsx
        TimelineSession.jsx
      utils/
        eventStyles.js
    wiki/
      useEntityView.js
      useWikiNavigation.js
      WikiLayout.jsx
      api/
        wikiService.js
      components/
        EncounterTimeline.jsx
        EntityBody.jsx
        EntityHeader.jsx
        EntityHistory.jsx
        EntityLocalGraph.jsx
        EntityMiniMap.jsx
        EntitySidebar.jsx
        QuestObjectives.jsx
        SessionMentions.jsx
        WikiEntryView.jsx
        character/
          CharacterSidebar.jsx
          CharacterStats.jsx
          RelationshipNetwork.jsx
        landing/
          EntityGridCard.jsx
          EntityPosterCard.jsx
          EntityTableGroup.jsx
          Swimlane.jsx
        navigation/
          SidebarEmptyState.jsx
          WikiSidebar.jsx
          WikiSidebarHeader.jsx
          WikiSidebarList.jsx
          sidebar/
            CollapsibleGroup.jsx
            EntityListItem.jsx
            PriorityIcon.jsx
            SidebarTreeItem.jsx
            StatusIcon.jsx
      config/
        groupingConfig.js
        viewStrategies.js
      hooks/
        useEntityContent.js
        useEntityFetching.js
        useEntityGrouping.js
        useEntityHeader.js
        useEntitySidebar.js
      layouts/
        CharacterLayout.jsx
        SessionLayout.jsx
        StandardLayout.jsx
      pages/
        WikiDetailPage.jsx
        WikiLandingPage.jsx
      utils/
        attributeMapper.js
        eventMapper.js
        relationshipMapper.js
        wikiEntryMapper.js
        wikiUtils.js
  shared/
    api/
      supabaseClient.js
    components/
      ErrorBoundary.jsx
      layout/
        CollapsibleSection.jsx
        SplitView.jsx
        TabContainer.jsx
      markdown/
        MarkdownRenderer.jsx
        MarkdownWithToC.jsx
      ui/
        Breadcrumbs.jsx
        Button.jsx
        Card.jsx
        DevAdminButton.jsx
        Drawer.jsx
        EmptyState.jsx
        HighlightBadge.jsx
        LoadingSpinner.jsx
        SectionDivider.jsx
    hooks/
      useBreadcrumbs.js
      useTheme.js
    utils/
      imageUtils.js
      markdownUtils.js
      textUtils.js
      theme/
        colorUtils.js
        cssUtils.js

================================================================
### SOURCE CODE
================================================================

--- FILE: features\smart-text\SmartMarkdown.jsx ---
import ReactMarkdown from 'react-markdown';
import { useSmartText } from './useSmartText';
import { SmartEntityLink } from './components/SmartEntityLink';
import { EntityEmbed } from './components/EntityEmbed';
import { generateId, extractText } from '@/shared/utils/textUtils';
import { Link } from 'react-router-dom';
import { getEntityStyles } from '@/domain/entity/config/entityStyles';

export default function SmartMarkdown({ children, inline = false, disableTooltips = false, ...props }) {
	let safeText = children;
	if (Array.isArray(children)) {
		safeText = children.join('');
	} else if (typeof children !== 'string' && children !== null && children !== undefined) {
		safeText = String(children);
	}

	const processedText = useSmartText(safeText);

	const HeadingRenderer = ({ level, children }) => {
		const text = extractText(children);
		const id = generateId(text);
		const Tag = `h${level}`;
		return <Tag id={id}>{children}</Tag>;
	};

	return (
		<ReactMarkdown
			{...props}
			disallowedElements={inline ? ['p'] : []}
			unwrapDisallowed={inline}
			components={{
				...props.components,
				h1: (props) => <HeadingRenderer level={1} {...props} />,
				h2: (props) => <HeadingRenderer level={2} {...props} />,
				h3: (props) => <HeadingRenderer level={3} {...props} />,

				a: ({ href, children }) => {
					if (href && href.startsWith('#entity/')) {
						const parts = href.split('/');
						const id = parts[1];
						const type = parts[2] || 'default';

						const textContent = String(children);
						const isEmbed = textContent.startsWith('::') && textContent.endsWith('::');

						if (isEmbed) {
							const label = textContent.replace(/^::\s*|\s*::$/g, '');
							return <EntityEmbed id={id} type={type} label={label} />;
						}

						// PREVENT RECURSIVE TOOLTIPS
						if (disableTooltips) {
							const styles = getEntityStyles(type);
							return (
								<Link
									to={`/wiki/${type}/${id}`}
									className={`${styles.text} font-semibold hover:underline cursor-pointer`}
									onClick={(e) => e.stopPropagation()} // Prevent card click
								>
									{children}
								</Link>
							);
						}

						return (
							<SmartEntityLink id={id} type={type}>
								{children}
							</SmartEntityLink>
						);
					}

					return (
						<a href={href} className='text-blue-600 hover:underline' target='_blank' rel='noopener noreferrer'>
							{children}
						</a>
					);
				},
			}}>
			{processedText}
		</ReactMarkdown>
	);
}

--- END OF features\smart-text\SmartMarkdown.jsx ---

--- FILE: features\smart-text\useEntityIndex.js ---
import { useQuery } from '@tanstack/react-query';
import { getEntityIndex } from '@/domain/entity/api/entityService';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { resolveImageUrl, parseAttributes } from '@/shared/utils/imageUtils';
import { getParentId } from '@/domain/entity/utils/entityUtils';

export function useEntityIndex() {
	const { campaignId } = useCampaign();

	const { data } = useQuery({
		queryKey: ['entityIndex', campaignId],
		queryFn: async () => {
			const rawData = await getEntityIndex(campaignId);

			const list = [];
			const map = new Map();
			const searchTokens = [];

			rawData.forEach((entity) => {
				const attrs = parseAttributes(entity.attributes);

				const lightEntity = {
					...entity,
					parentId: getParentId(entity),
					iconUrl: resolveImageUrl(attrs, 'icon'),
					attributes: attrs,
				};

				// 1. Add Primary Name
				if (entity.name && entity.name.length > 2) {
					searchTokens.push({
						term: entity.name,
						entityId: entity.id,
						type: entity.type,
					});
				}

				// 2. Add Aliases
				if (attrs.aliases) {
					// Handle Array or String
					const aliasList = Array.isArray(attrs.aliases)
						? attrs.aliases
						: typeof attrs.aliases === 'string'
						? attrs.aliases.split(',').map((s) => s.trim())
						: [];

					aliasList.forEach((alias) => {
						if (alias && alias.length > 2) {
							searchTokens.push({
								term: alias,
								entityId: entity.id,
								type: entity.type,
							});
						}
					});
				}

				list.push(lightEntity);
				map.set(entity.id, lightEntity);
			});

			// Sort by length DESC so "Captain Soranna" matches before "Soranna"
			searchTokens.sort((a, b) => b.term.length - a.term.length);

			return { list, map, searchTokens };
		},
		staleTime: 1000 * 60 * 30,
		enabled: !!campaignId,
	});

	return data || { list: [], map: new Map(), searchTokens: [] };
}

--- END OF features\smart-text\useEntityIndex.js ---

--- FILE: features\smart-text\useSmartText.js ---
import { useMemo } from 'react';
import { useEntityIndex } from './useEntityIndex';

const escapeRegex = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

const findEntityMatches = (text, searchTokens, entityMap) => {
	const matches = [];
	const processedRanges = [];

	if (!searchTokens || searchTokens.length === 0) return [];

	for (const token of searchTokens) {
		// Use standard Word Boundaries (\b) for matching
		const pattern = new RegExp(`\\b${escapeRegex(token.term)}\\b`, 'gi');
		let match;

		while ((match = pattern.exec(text)) !== null) {
			const start = match.index;
			const end = start + token.term.length;

			// Check overlap
			const overlaps = processedRanges.some(
				(range) =>
					(start >= range.start && start < range.end) ||
					(end > range.start && end <= range.end) ||
					(start <= range.start && end >= range.end)
			);

			if (!overlaps) {
				const entity = entityMap.get(token.entityId);
				if (entity) {
					// CHANGED: Use text.slice(start, end) to grab the ACTUAL text
					// (e.g., "the Arcane Brotherhood") instead of token.term ("The Arcane Brotherhood")
					matches.push({
						start,
						end,
						text: text.slice(start, end),
						entity,
					});
					processedRanges.push({ start, end });
				}
			}
		}
	}

	return matches.sort((a, b) => a.start - b.start);
};

const replaceMatches = (text, matches) => {
	if (matches.length === 0) return text;
	let result = '';
	let lastIndex = 0;
	for (const match of matches) {
		result += text.slice(lastIndex, match.start);
		result += `[${match.text}](#entity/${match.entity.id}/${match.entity.type})`;
		lastIndex = match.end;
	}
	result += text.slice(lastIndex);
	return result;
};

export function useSmartText(text) {
	const { searchTokens, map } = useEntityIndex();

	const shouldProcess = useMemo(() => {
		if (!text || typeof text !== 'string' || text.length < 3) return false;
		if (!searchTokens || searchTokens.length === 0) return false;
		return true;
	}, [text, searchTokens]);

	return useMemo(() => {
		if (!shouldProcess) return text || '';

		try {
			const linkProtectionRegex = /(\[.*?\]\(.*?\))/g;
			const parts = text.split(linkProtectionRegex);

			const processedParts = parts.map((part) => {
				if (part.startsWith('[') && part.includes('](') && part.endsWith(')')) {
					return part;
				}
				const matches = findEntityMatches(part, searchTokens, map);
				return replaceMatches(part, matches);
			});

			return processedParts.join('');
		} catch (err) {
			console.error('SmartMarkdown processing error:', err);
			return text;
		}
	}, [text, searchTokens, map, shouldProcess]);
}

--- END OF features\smart-text\useSmartText.js ---

--- FILE: features\smart-text\components\EntityEmbed.jsx ---
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { ArrowRight } from 'lucide-react';
import { clsx } from 'clsx';
import EntityIcon from '@/domain/entity/components/EntityIcon';
import { useEntityIndex } from '@/features/smart-text/useEntityIndex';
import { resolveImageUrl, parseAttributes } from '@/shared/utils/imageUtils';

// Utility to calculate brightness from an image
const getImageBrightness = (imageUrl) => {
	return new Promise((resolve) => {
		const img = new Image();
		img.crossOrigin = 'Anonymous';

		img.onload = () => {
			try {
				const canvas = document.createElement('canvas');
				const ctx = canvas.getContext('2d');

				canvas.width = 100;
				canvas.height = 100;

				ctx.drawImage(img, 0, 0, 100, 100);
				const imageData = ctx.getImageData(0, 0, 100, 100);
				const data = imageData.data;

				let totalBrightness = 0;
				let pixelCount = 0;

				for (let i = 0; i < data.length; i += 4) {
					const r = data[i];
					const g = data[i + 1];
					const b = data[i + 2];
					const a = data[i + 3];

					if (a < 125) continue;

					const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
					totalBrightness += brightness;
					pixelCount++;
				}

				const avgBrightness = totalBrightness / pixelCount;
				resolve(avgBrightness);
			} catch (e) {
				resolve(200);
			}
		};

		img.onerror = () => {
			resolve(200);
		};

		img.src = imageUrl;
	});
};

export const EntityEmbed = ({ id, type, label }) => {
	const navigate = useNavigate();
	// FIX: Destructure the 'map' from the new hook signature
	const { map: entityMap } = useEntityIndex();

	// FIX: Use .get() (O(1) speed) instead of .find()
	const entity = entityMap.get(id);
	const resolvedLabel = label || entity?.name || 'Unknown Entity';

	// Resolve Images
	const attributes = parseAttributes(entity?.attributes);
	const customIcon = entity?.iconUrl || resolveImageUrl(attributes, 'icon');
	const bgImage = resolveImageUrl(attributes, 'background_image');

	// State for brightness detection
	const [isDarkBackground, setIsDarkBackground] = useState(false);
	const [isAnalyzing, setIsAnalyzing] = useState(!!bgImage);

	// Analyze background image brightness
	useEffect(() => {
		if (!bgImage) {
			setIsAnalyzing(false);
			return;
		}

		setIsAnalyzing(true);

		getImageBrightness(bgImage).then((brightness) => {
			setIsDarkBackground(brightness < 127.5);
			setIsAnalyzing(false);
		});
	}, [bgImage]);

	// Border Color Logic (Left Side Only)
	const getBorderColor = () => {
		switch (type) {
			case 'encounter':
				return 'border-l-red-600';
			case 'quest':
				return 'border-l-blue-600';
			case 'location':
				return 'border-l-emerald-600';
			default:
				return 'border-l-amber-600';
		}
	};

	const getActionLabel = () => {
		switch (type) {
			case 'encounter':
				return 'View Encounter';
			case 'quest':
				return 'View Quest';
			case 'location':
				return 'View Map';
			default:
				return 'View Entity';
		}
	};

	return (
		<span
			role='button'
			onClick={(e) => {
				e.preventDefault();
				navigate(`/wiki/${type}/${id}`);
			}}
			className={clsx(
				// Layout & Base (Changed to flex to behave like block context within span)
				'group relative w-full h-[30px] my-4 cursor-pointer select-none overflow-hidden',
				'flex rounded-md transition-all duration-200',

				// Borders
				'border border-border/60 border-l-[3px]',
				getBorderColor(),

				// Background (Default White if no image)
				!bgImage && 'bg-background hover:bg-muted/30',

				// Hover Effects
				'hover:shadow hover:border-l-4'
			)}>
			{/* BACKGROUND IMAGE LAYER */}
			{bgImage && (
				<span
					className='absolute inset-0 bg-cover bg-center opacity-80 group-hover:scale-105 transition-transform duration-500 block'
					style={{ backgroundImage: `url('${bgImage}')` }}
				/>
			)}

			{/* CONTENT LAYER */}
			<span className='relative z-10 flex items-center gap-2 pl-2 pr-3 h-full w-full'>
				{/* Icon - Adaptive color, no background */}
				<span
					className={clsx(
						'shrink-0 flex items-center justify-center opacity-90 group-hover:opacity-100 transition-all duration-200',
						isAnalyzing ? 'opacity-0' : 'opacity-100'
					)}
					style={{
						filter: bgImage
							? isDarkBackground
								? 'brightness(0) invert(1)' // White for dark backgrounds
								: 'brightness(0)' // Black for light backgrounds
							: 'none',
					}}>
					<EntityIcon
						type={type}
						customIconUrl={customIcon}
						size={16}
						inline={true}
						className='object-cover rounded-full'
					/>
				</span>

				{/* Label */}
				<span
					className={clsx(
						'font-serif font-bold text-[12px] truncate leading-none flex-1 pt-0.5 block',
						'transition-colors duration-200',
						isAnalyzing ? 'opacity-0' : 'opacity-100',
						bgImage ? (isDarkBackground ? 'text-white' : 'text-black') : 'text-foreground'
					)}>
					{resolvedLabel}
				</span>

				{/* Right Side Action */}
				<span
					className={clsx(
						'text-[9px] font-bold uppercase tracking-wider flex items-center gap-1 shrink-0 transition-colors',
						isAnalyzing ? 'opacity-0' : 'opacity-100',
						bgImage
							? isDarkBackground
								? 'text-white/90 group-hover:text-white'
								: 'text-black/90 group-hover:text-black'
							: 'text-muted-foreground/60 group-hover:text-amber-700'
					)}>
					{getActionLabel()} <ArrowRight size={10} />
				</span>
			</span>
		</span>
	);
};

--- END OF features\smart-text\components\EntityEmbed.jsx ---

--- FILE: features\smart-text\components\SmartEntityLink.jsx ---
/**
 * SmartEntityLink - MIGRATED to use EntityLink component
 * This is now just a thin wrapper that adds entity index lookup
 */

import EntityLink from '@/domain/entity/components/EntityLink';
import { useEntityIndex } from '@/features/smart-text/useEntityIndex';

export const SmartEntityLink = ({ id, type, children }) => {
	// FIX: Destructure the 'map' from the new hook signature
	const { map: entityMap } = useEntityIndex();

	// FIX: Use .get() (O(1) speed) instead of .find()
	const entity = entityMap.get(id);
	const customIconUrl = entity?.iconUrl;

	return (
		<EntityLink id={id} type={type} customIconUrl={customIconUrl} inline>
			{children}
		</EntityLink>
	);
};

--- END OF features\smart-text\components\SmartEntityLink.jsx ---

