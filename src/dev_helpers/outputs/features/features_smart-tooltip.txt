================================================================
PARTIAL BUNDLE: FEATURES SMART-TOOLTIP
================================================================

### PROJECT MAP (FILE STRUCTURE)
./
  main.jsx
  todo.md
  app/
    App.jsx
    AppRoutes.jsx
    components/
      RouteLoading.jsx
    styles/
      global.css
  domain/
    entity/
      api/
        entityService.js
      components/
        EntityBadge.jsx
        EntityIcon.jsx
        EntityLink.jsx
        EntityStatusIcon.jsx
      config/
        entityColors.js
        entityConfig.js
        entityIcons.js
        entityStyles.js
        entityTypes.js
      utils/
        attributeParser.js
        entityUtils.js
        statusUtils.js
  features/
    admin/
      api/
        adminService.js
      components/
        AdminForm.jsx
        AdminFormStyles.js
        AdvancedFilter.jsx
        EncounterManager.jsx
        EntitySearch.jsx
        EventTagger.jsx
        ImageLibraryModal.jsx
        MarkdownEditor.jsx
        MarkdownEditorImpl.jsx
        QuestObjectiveManager.jsx
        RelationshipManager.jsx
        SessionEventManager.jsx
        SmartColorPicker.jsx
        SmartImageInput.jsx
        TacticalMapManager.jsx
        atlas/
          AtlasForms.jsx
          editor/
            AtlasEditor.jsx
            AtlasEditorContext.jsx
            components/
              EditorLayerList.jsx
              EditorMapEvents.jsx
              EditorSidebar.jsx
              EditorToolbar.jsx
              VertexHandle.jsx
            layers/
              EditAreasLayer.jsx
              EditMarkersLayer.jsx
              EditOverlaysLayer.jsx
              EditPathsLayer.jsx
      config/
        adminStrategies.js
        imageManifest.json
      layouts/
        AdminLayout.jsx
      pages/
        BulkReplaceTool.jsx
        EntityEditorPage.jsx
        EntityListPage.jsx
        MapManagerPage.jsx
        MapMigrationTool.jsx
        SplitPaneManager.jsx
      utils/
        filterUtils.js
    atlas/
      MapPage.jsx
      useMapData.js
      api/
        mapService.js
      components/
        AtlasSidebar.jsx
        MapCanvas.jsx
        MapTools.jsx
        MapZoomHandler.jsx
        useMapCanvasViewModel.js
        __MapLayerControl.jsx
        layers/
          MapAreas.jsx
          MapMarkers.jsx
          MapOverlays.jsx
          MapRecaps.jsx
      config/
        mapConfig.js
      context/
        AtlasContext.jsx
      data/
        modularize.js
        refactor.js
        campaign_02/
          index.js
          faerun/
            index.js
      utils/
        mapNavigation.js
        markerUtils.js
    campaign/
      CampaignContext.jsx
      useCampaignData.js
      useCampaignPersistence.js
      useCampaignSelection.js
      api/
        campaignService.js
      components/
        CampaignCard.jsx
        CampaignSelect.jsx
    dashboard/
      DashboardPage.jsx
      api/
        dashboardService.js
      components/
        ActiveThreads.jsx
        ArchiveTree.jsx
        CampaignHeader.jsx
        CurrentArcMetadata.jsx
        CurrentStoryStack.jsx
        InsightsGrid.jsx
        PartyWidget.jsx
        QuickInsights.jsx
    graph/
      GraphPage.jsx
      useGraphView.js
      api/
        graphService.js
      components/
        CytoscapeCanvas.jsx
        GraphLegend.jsx
      config/
        graphStyles.js
      utils/
        graphMapper.js
    navigation/
      MainLayout.jsx
      useNavigation.js
      components/
        Sidebar.jsx
        SidebarFooter.jsx
        SidebarHeader.jsx
        SidebarNav.jsx
      config/
        navConfig.js
    search/
      GlobalSearch.jsx
      SearchContext.jsx
      useGlobalSearch.js
      api/
        searchService.js
      components/
        SearchFooter.jsx
        SearchModal.jsx
        SearchResultItem.jsx
        SearchResults.jsx
        SearchTrigger.jsx
      utils/
        searchMapper.js
    smart-text/
      SmartMarkdown.jsx
      useEntityIndex.js
      useSmartText.js
      components/
        EntityEmbed.jsx
        SmartEntityLink.jsx
    smart-tooltip/
      TooltipContainer.jsx
      TooltipContext.jsx
      useSmartPosition.js
      useTooltipState.js
      components/
        TooltipCard.jsx
      config/
        tooltipProfiles.js
    table-of-contents/
      TableOfContents.jsx
      components/
        TocItem.jsx
        TocMobileDrawer.jsx
      hooks/
        useTocObserver.js
        useTocScroll.js
    timeline/
      TimelinePage.jsx
      useTimelineView.js
      api/
        timelineService.js
      components/
        TimelineArcHeader.jsx
        TimelineEvent.jsx
        TimelineSession.jsx
      utils/
        eventStyles.js
    wiki/
      useEntityView.js
      useWikiNavigation.js
      WikiLayout.jsx
      api/
        wikiService.js
      components/
        EncounterTimeline.jsx
        EntityBody.jsx
        EntityHeader.jsx
        EntityHistory.jsx
        EntityLocalGraph.jsx
        EntityMiniMap.jsx
        EntitySidebar.jsx
        QuestObjectives.jsx
        SessionMentions.jsx
        WikiEntryView.jsx
        character/
          CharacterSidebar.jsx
          CharacterStats.jsx
          RelationshipNetwork.jsx
        landing/
          EntityGridCard.jsx
          EntityPosterCard.jsx
          EntityTableGroup.jsx
          Swimlane.jsx
        navigation/
          SidebarEmptyState.jsx
          WikiSidebar.jsx
          WikiSidebarHeader.jsx
          WikiSidebarList.jsx
          sidebar/
            CollapsibleGroup.jsx
            EntityListItem.jsx
            PriorityIcon.jsx
            SidebarTreeItem.jsx
            StatusIcon.jsx
      config/
        groupingConfig.js
        viewStrategies.js
      hooks/
        useEntityContent.js
        useEntityFetching.js
        useEntityGrouping.js
        useEntityHeader.js
        useEntitySidebar.js
      layouts/
        CharacterLayout.jsx
        SessionLayout.jsx
        StandardLayout.jsx
      pages/
        WikiDetailPage.jsx
        WikiLandingPage.jsx
      utils/
        attributeMapper.js
        eventMapper.js
        relationshipMapper.js
        wikiEntryMapper.js
        wikiUtils.js
  shared/
    api/
      supabaseClient.js
    components/
      ErrorBoundary.jsx
      layout/
        CollapsibleSection.jsx
        SplitView.jsx
        TabContainer.jsx
      markdown/
        MarkdownRenderer.jsx
        MarkdownWithToC.jsx
      ui/
        Breadcrumbs.jsx
        Button.jsx
        Card.jsx
        DevAdminButton.jsx
        Drawer.jsx
        EmptyState.jsx
        HighlightBadge.jsx
        LoadingSpinner.jsx
        SectionDivider.jsx
    hooks/
      useBreadcrumbs.js
      useTheme.js
    utils/
      imageUtils.js
      markdownUtils.js
      textUtils.js
      theme/
        colorUtils.js
        cssUtils.js

================================================================
### SOURCE CODE
================================================================

--- FILE: features\smart-tooltip\TooltipContainer.jsx ---
import { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import { useQuery } from '@tanstack/react-query';
import { getTooltipData } from '@/domain/entity/api/entityService';
import { TooltipCard } from './components/TooltipCard';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

export const TooltipContainer = ({ target, onMouseEnter, onMouseLeave }) => {
	const targetId = target?.id;
	const targetType = target?.type;
	// We need a ref to the card to know if a click was "inside" or "outside"
	const cardRef = useRef(null);

	const isValidId = targetId ? /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(targetId) : false;

	const { data, isLoading } = useQuery({
		queryKey: ['tooltip', targetId],
		queryFn: async () => {
			if (!targetId) return null;
			const rawData = await getTooltipData(targetId, targetType);

			if (targetType === 'session') {
				const attrs = rawData.attributes || {};
				const synopsis = getAttributeValue(attrs, 'synopsis');

				if (!rawData.description) {
					return {
						...rawData,
						description: synopsis || rawData.narrative || 'No synopsis available.',
					};
				}
			}
			return rawData;
		},
		enabled: !!targetId && isValidId,
		staleTime: 1000 * 60 * 5,
		retry: false,
	});

	// HANDLE OUTSIDE INTERACTIONS (The "No-Backdrop" Solution)
	useEffect(() => {
		if (!target) return;

		// 1. Close on Scroll (User drags screen)
		const handleScroll = () => {
			if (onMouseLeave) onMouseLeave();
		};

		// 2. Close on Outside Tap (User taps background)
		const handleOutsideTap = (e) => {
			// If the tap is NOT inside the card, close it
			if (cardRef.current && !cardRef.current.contains(e.target)) {
				if (onMouseLeave) onMouseLeave();
			}
		};

		// Passive listener for scroll performance
		window.addEventListener('scroll', handleScroll, { passive: true });
		// Capture phase ensures we catch the tap before it triggers other buttons
		document.addEventListener('touchstart', handleOutsideTap, { passive: false });
		document.addEventListener('mousedown', handleOutsideTap);

		return () => {
			window.removeEventListener('scroll', handleScroll);
			document.removeEventListener('touchstart', handleOutsideTap);
			document.removeEventListener('mousedown', handleOutsideTap);
		};
	}, [target, onMouseLeave]);

	if (!target) return null;

	return createPortal(
		// Wrap with a simple div to attach the Ref for "contains" checking
		<div ref={cardRef} style={{ display: 'contents' }}>
			<TooltipCard
				data={data}
				type={target.type}
				id={target.id}
				position={target.pos}
				isLoading={isLoading}
				onMouseEnter={onMouseEnter}
				onMouseLeave={onMouseLeave}
			/>
		</div>,
		document.body
	);
};

--- END OF features\smart-tooltip\TooltipContainer.jsx ---

--- FILE: features\smart-tooltip\TooltipContext.jsx ---
import { createContext, useContext } from 'react';
import { useTooltipState } from './useTooltipState';
import { TooltipContainer } from './TooltipContainer';

const TooltipContext = createContext(null);

export const TooltipProvider = ({ children }) => {
	const { activeTooltip, openTooltip, closeTooltip, cancelClose } = useTooltipState();

	return (
		<TooltipContext.Provider value={{ openTooltip, closeTooltip, cancelClose }}>
			{children}

			{/* Pass interaction handlers to the Overlay Layer */}
			<TooltipContainer target={activeTooltip} onMouseEnter={cancelClose} onMouseLeave={closeTooltip} />
		</TooltipContext.Provider>
	);
};

export const useTooltip = () => {
	const context = useContext(TooltipContext);

	// CHANGED: Graceful degradation instead of hard crash
	if (!context) {
		// Return dummy functions so components don't break
		return {
			openTooltip: () => {},
			closeTooltip: () => {},
			cancelClose: () => {},
		};
	}
	return context;
};

--- END OF features\smart-tooltip\TooltipContext.jsx ---

--- FILE: features\smart-tooltip\useSmartPosition.js ---
import { useState, useEffect, useRef } from 'react';

/**
 * Calculates smart positioning for tooltips to keep them onscreen
 * @param {Object} targetPosition - { x, y } coordinates of the trigger element
 * @param {boolean} isOpen - Whether the tooltip is currently visible
 * @returns {Object} - { style, tooltipRef } for positioning
 */
export function useSmartPosition(targetPosition, isOpen) {
	const tooltipRef = useRef(null);
	const [position, setPosition] = useState({ top: 0, left: 0, transform: '' });
	const [isPositioned, setIsPositioned] = useState(false);

	useEffect(() => {
		if (!isOpen || !tooltipRef.current || !targetPosition) {
			setIsPositioned(false);
			return;
		}

		const calculatePosition = () => {
			const tooltip = tooltipRef.current;
			const rect = tooltip.getBoundingClientRect();

			// Get viewport dimensions
			const viewportWidth = window.innerWidth;
			const viewportHeight = window.innerHeight;

			// Configuration
			const EDGE_PADDING = 10; // Minimum distance from screen edges
			const OFFSET_Y = 20; // Distance below cursor
			const TOOLTIP_WIDTH = 300; // Match your tooltip width

			let top = targetPosition.y + OFFSET_Y;
			let left = targetPosition.x;
			let transform = 'translateX(-50%)'; // Center by default

			// --- HORIZONTAL POSITIONING ---

			// Calculate where the tooltip would end up with center alignment
			const leftEdge = left - TOOLTIP_WIDTH / 2;
			const rightEdge = left + TOOLTIP_WIDTH / 2;

			if (rightEdge > viewportWidth - EDGE_PADDING) {
				// Tooltip would overflow right side
				// Align to right edge of viewport with padding
				left = viewportWidth - EDGE_PADDING;
				transform = 'translateX(-100%)'; // Right align
			} else if (leftEdge < EDGE_PADDING) {
				// Tooltip would overflow left side
				// Align to left edge of viewport with padding
				left = EDGE_PADDING;
				transform = 'translateX(0)'; // Left align
			}

			// --- VERTICAL POSITIONING ---

			// Check if tooltip would overflow bottom
			if (top + rect.height > viewportHeight - EDGE_PADDING) {
				// Position above the cursor instead
				top = targetPosition.y - rect.height - 10;

				// If it still doesn't fit above, clamp to top
				if (top < EDGE_PADDING) {
					top = EDGE_PADDING;
				}
			}

			// Ensure tooltip doesn't go above viewport
			if (top < EDGE_PADDING) {
				top = EDGE_PADDING;
			}

			setPosition({ top, left, transform });
			setIsPositioned(true);
		};

		// Initial calculation
		calculatePosition();

		// Recalculate on resize (debounced)
		let resizeTimer;
		const handleResize = () => {
			clearTimeout(resizeTimer);
			resizeTimer = setTimeout(calculatePosition, 100);
		};

		window.addEventListener('resize', handleResize);

		return () => {
			window.removeEventListener('resize', handleResize);
			clearTimeout(resizeTimer);
		};
	}, [targetPosition, isOpen]);

	const style = {
		position: 'fixed',
		top: `${position.top}px`,
		left: `${position.left}px`,
		transform: position.transform,
		zIndex: 9999,
		width: '300px',
		pointerEvents: 'auto',
		opacity: isPositioned ? 1 : 0,
		transition: 'opacity 0.15s ease-out',
	};

	return { style, tooltipRef, isPositioned };
}

--- END OF features\smart-tooltip\useSmartPosition.js ---

--- FILE: features\smart-tooltip\useTooltipState.js ---
import { useState, useRef, useCallback, useEffect } from 'react';
// import './types';

export function useTooltipState() {
	const [activeTooltip, setActiveTooltip] = useState(null);
	const timeoutRef = useRef(null);

	useEffect(() => {
		return () => {
			if (timeoutRef.current) {
				clearTimeout(timeoutRef.current);
			}
		};
	}, []);

	const openTooltip = useCallback((e, id, type, isPinned = false) => {
		// If we are opening a new one, clear any pending close
		if (timeoutRef.current) clearTimeout(timeoutRef.current);

		// Get position from event
		let x = e.clientX;
		let y = e.clientY;

		// For touch events on mobile, use touch coordinates
		if (e.touches && e.touches[0]) {
			x = e.touches[0].clientX;
			y = e.touches[0].clientY;
		}

		setActiveTooltip({ id, type, pos: { x, y }, isPinned });
	}, []);

	const closeTooltip = useCallback(() => {
		// Add a delay so the user can move their mouse from the link TO the tooltip
		timeoutRef.current = setTimeout(() => {
			setActiveTooltip(null);
		}, 100); // 300ms grace period
	}, []);

	// Allows the Tooltip Card to say "I'm being hovered, don't close!"
	const cancelClose = useCallback(() => {
		if (timeoutRef.current) clearTimeout(timeoutRef.current);
	}, []);

	return {
		activeTooltip,
		openTooltip,
		closeTooltip,
		cancelClose,
	};
}

--- END OF features\smart-tooltip\useTooltipState.js ---

--- FILE: features\smart-tooltip\components\TooltipCard.jsx ---
import { useNavigate } from 'react-router-dom';
import { clsx } from 'clsx';
import { ArrowRight, Heart, Crown, Shield, Wind } from 'lucide-react';
import { useSmartPosition } from '@/features/smart-tooltip/useSmartPosition';
import { resolveImageUrl, parseAttributes } from '@/shared/utils/imageUtils';
import SmartMarkdown from '@/features/smart-text/SmartMarkdown';

// SINGLE SOURCE OF TRUTH IMPORTS
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import { getEntityPalette } from '@/domain/entity/config/entityColors';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';
import { TOOLTIP_PROFILES, DEFAULT_PROFILE } from '../config/tooltipProfiles';

// --- UTILS ---

const resolveField = (attrs, key) => {
	if (key === 'level_prefix') {
		const lvl = getAttributeValue(attrs, 'level');
		return lvl ? `Lvl ${lvl}` : null;
	}
	if (key === 'session_number_prefixed') {
		const num = getAttributeValue(attrs, ['session_number', 'number']);
		return num ? `Session ${num}` : null;
	}
	return getAttributeValue(attrs, key);
};

// --- MINI COMPONENTS ---

const StatusDot = ({ status }) => {
	if (!status) return null;
	const s = status.toLowerCase();
	const isDead = ['dead', 'destroyed', 'completed', 'failed'].includes(s);
	const isAlive = ['alive', 'active', 'in progress'].includes(s);

	let colorClass = 'bg-muted-foreground/50';
	if (isDead) colorClass = 'bg-red-500';
	if (isAlive) colorClass = 'bg-emerald-500';

	return (
		<div className='flex items-center gap-1.5 text-[10px] font-medium uppercase tracking-wide text-muted-foreground/90'>
			<span className={`w-1.5 h-1.5 rounded-full ${colorClass}`} />
			{status}
		</div>
	);
};

const TagText = ({ value, type }) => {
	if (!value) return null;
	const v = value.toLowerCase();

	let colorClass = 'text-muted-foreground';

	if (type === 'affinity') {
		if (['enemy', 'hostile'].includes(v)) colorClass = 'text-orange-600 dark:text-orange-400';
		if (['ally', 'friendly'].includes(v)) colorClass = 'text-blue-600 dark:text-blue-400';
	}

	return <span className={clsx('text-[10px] font-bold uppercase tracking-wide opacity-90', colorClass)}>{value}</span>;
};

// --- MAIN CARD ---

export const TooltipCard = ({ data, type, id, position, isLoading, onMouseEnter, onMouseLeave }) => {
	const navigate = useNavigate();

	// 1. Get Domain Configuration
	const config = getEntityConfig(type);
	const palette = getEntityPalette(type);
	const TypeIcon = config.icon;

	// 2. Get Layout Profile
	const profile = TOOLTIP_PROFILES[type] || DEFAULT_PROFILE;

	const { style, tooltipRef } = useSmartPosition(position, true);

	const handleClick = (e) => {
		e.stopPropagation();
		navigate(`/wiki/${type}/${id}`);
		onMouseLeave && onMouseLeave();
	};

	// 3. Dynamic Styles based on Entity Palette (500 shade)
	const primaryColor = palette[500];
	const fallbackGradient = {
		background: `linear-gradient(135deg, ${primaryColor}33 0%, ${primaryColor}11 100%)`,
	};

	if (isLoading) {
		return (
			<div
				ref={tooltipRef}
				style={style}
				className='bg-background/95 backdrop-blur p-4 rounded-lg shadow-xl border border-border text-xs text-muted-foreground'>
				Loading...
			</div>
		);
	}

	if (!data) return null;

	const attributes = parseAttributes(data.attributes);
	const image = resolveImageUrl(attributes, 'background');

	// Info Line
	const infoParts = (profile.subtitle || []).map((key) => resolveField(attributes, key)).filter(Boolean);
	const infoLine = infoParts.join(' â€¢ ');

	// Extra Data
	const hp = profile.features?.showHP ? getAttributeValue(attributes, ['hit points', 'hp']) : null;
	const armorClass = profile.features?.showArmorClass ? getAttributeValue(attributes, ['armor class', 'ac']) : null;
	const movement = profile.features?.showMovement ? getAttributeValue(attributes, ['movement', 'speed']) : null;
	const ruler = profile.features?.showRuler ? getAttributeValue(attributes, 'ruler') : null;

	// Personality Parsing
	let parsedPersonality = null;
	const personality = profile.features?.showPersonality ? getAttributeValue(attributes, 'personality') : null;
	if (personality) {
		if (Array.isArray(personality)) {
			parsedPersonality = personality.map((p) => p.value || p).join(' ');
		} else {
			parsedPersonality = personality;
		}
	}

	return (
		<div
			ref={tooltipRef}
			style={style}
			onClick={handleClick}
			onMouseEnter={onMouseEnter}
			onMouseLeave={onMouseLeave}
			className={clsx(
				'bg-background rounded-lg shadow-2xl ring-1 ring-border group flex flex-col w-[300px] overflow-hidden select-none',
				'hover:ring-2 transition-all duration-200'
			)}>
			{/* HEADER */}
			{image ? (
				<div className='h-28 w-full bg-muted relative shrink-0'>
					<img src={image} alt='' className='w-full h-full object-cover opacity-90' />
					<div className='absolute inset-0 bg-gradient-to-t from-background via-transparent to-transparent' />
				</div>
			) : (
				<div className='h-20 w-full relative overflow-hidden shrink-0' style={fallbackGradient}>
					<TypeIcon
						strokeWidth={1.5}
						className='absolute -bottom-3 -right-3 w-24 h-24 opacity-[0.07] -rotate-12 text-foreground'
						style={{ color: primaryColor }}
					/>
				</div>
			)}

			{/* CONTENT */}
			<div className={clsx('flex flex-col px-4 pb-3', image ? '-mt-8 relative z-10' : 'pt-2')}>
				{/* TITLE ROW */}
				<div className='flex justify-between items-end gap-2 mb-1'>
					<div className='min-w-0 flex-1'>
						<span
							className='text-[9px] font-bold uppercase tracking-wider block opacity-70 mb-0.5'
							style={{ color: primaryColor }}>
							{data.type}
						</span>
						<h3
							className={clsx(
								'font-serif font-bold text-xl leading-none truncate pr-1 drop-shadow-sm text-foreground'
							)}>
							{data.name}
						</h3>
					</div>
					{/* Floating Icon Badge */}
					<div
						className={clsx(
							'p-1.5 rounded-md border shadow-sm shrink-0 mb-0.5',
							image
								? 'bg-background/90 text-foreground border-transparent backdrop-blur'
								: 'bg-muted/30 border-border/50'
						)}>
						<TypeIcon size={18} strokeWidth={1.5} style={!image ? { color: primaryColor } : {}} />
					</div>
				</div>

				{/* SUBTITLE */}
				{infoLine && <div className='text-xs font-medium text-muted-foreground/90 mb-2 truncate'>{infoLine}</div>}

				{/* TAGS */}
				{(profile.tags?.length > 0 || hp) && (
					<div className='flex items-center gap-3 mb-3 border-b border-border/40 pb-2'>
						{hp && (
							<div className='flex items-center gap-1 text-[10px] font-bold text-muted-foreground mr-1'>
								<Heart size={10} className='text-red-500/70 fill-red-500/10' /> {hp}
							</div>
						)}
						{armorClass && (
							<div className='flex items-center gap-1 text-[10px] font-bold text-muted-foreground mr-1'>
								<Shield size={10} className='text-emerald-500/70 fill-emerald-500/10' /> {armorClass}
							</div>
						)}
						{movement && (
							<div className='flex items-center gap-1 text-[10px] font-bold text-muted-foreground mr-1'>
								<Wind size={10} className='text-blue-500/70 fill-blue-500/10' /> {movement}
							</div>
						)}
						{profile.tags?.includes('status') && <StatusDot status={getAttributeValue(attributes, 'status')} />}
						{profile.tags?.includes('affinity') && (
							<TagText value={getAttributeValue(attributes, 'affinity')} type='affinity' />
						)}
						{profile.tags?.includes('priority') && (
							<TagText value={getAttributeValue(attributes, 'priority')} type='priority' />
						)}
					</div>
				)}

				{/* PERSONALITY */}
				{parsedPersonality && (
					<div className='mb-2 text-xs italic text-muted-foreground/80 leading-relaxed border-l-2 border-border/60 pl-2'>
						<SmartMarkdown inline={true} disableTooltips={true}>
							{`"${parsedPersonality}"`}
						</SmartMarkdown>
					</div>
				)}

				{/* DESCRIPTION */}
				{data.description && (
					<div className='text-xs text-muted-foreground/90'>
						<div className='max-h-[140px] overflow-y-auto pr-2 custom-scrollbar leading-relaxed'>
							<SmartMarkdown inline={true} disallowedElements={['h1', 'h2', 'h3', 'img']} disableTooltips={true}>
								{data.description}
							</SmartMarkdown>
						</div>
					</div>
				)}
			</div>

			{/* FOOTER */}
			<div className='bg-muted/30 py-1.5 px-3 border-t border-border flex justify-between items-center mt-auto shrink-0'>
				<span className='text-[9px] text-muted-foreground/50 font-medium'>
					{ruler && (
						<span className='flex items-center gap-1'>
							<Crown size={8} /> {ruler}
						</span>
					)}
				</span>

				<span className='text-[9px] font-semibold text-muted-foreground/60 flex items-center gap-1 group-hover:text-amber-600 transition-colors'>
					Open Wiki <ArrowRight size={8} />
				</span>
			</div>
		</div>
	);
};

--- END OF features\smart-tooltip\components\TooltipCard.jsx ---

--- FILE: features\smart-tooltip\config\tooltipProfiles.js ---
// Defines WHICH data fields to show for each entity type.
// Visuals (Icons, Colors) are handled by the centralized EntityConfig.

export const TOOLTIP_PROFILES = {
	// --- CHARACTERS ---
	character: {
		subtitle: ['level_prefix', 'race', 'class'],
		tags: ['status'],
		features: { showHP: true, showArmorClass: true, showMovement: true },
	},

	// --- NPCs ---
	npc: {
		subtitle: ['gender', 'race', 'role'],
		tags: ['status', 'affinity'],
		features: { showPersonality: true },
	},

	// --- LOCATIONS ---
	location: {
		subtitle: ['type', 'parent_location'],
		tags: [],
		features: { showRuler: true },
	},

	// --- QUESTS ---
	quest: {
		subtitle: ['quest type'],
		tags: ['status', 'priority'],
		features: {},
	},

	// --- ENCOUNTERS ---
	encounter: {
		subtitle: ['status'],
		tags: [],
		features: {},
	},

	// --- FACTIONS ---
	faction: {
		subtitle: ['affinity'],
		tags: [],
		features: {},
	},

	// --- SESSIONS ---
	session: {
		subtitle: ['session_number_prefixed', 'session_date'],
		tags: [],
		features: {},
	},
};

export const DEFAULT_PROFILE = {
	subtitle: ['type'],
	tags: [],
	features: {},
};

--- END OF features\smart-tooltip\config\tooltipProfiles.js ---

