================================================================
PARTIAL BUNDLE: FEATURES TIMELINE
================================================================

### PROJECT MAP (FILE STRUCTURE)
./
  main.jsx
  app/
    App.jsx
    AppRoutes.jsx
    components/
      RouteLoading.jsx
    styles/
      global.css
  dev_helpers/
    check_imports.js
    refactor.js
  domain/
    entity/
      api/
        entityService.js
      components/
        EntityBadge.jsx
        EntityIcon.jsx
        EntityLink.jsx
        EntityStatusIcon.jsx
      config/
        entityColors.js
        entityConfig.js
        entityIcons.js
        entityStyles.js
        entityTypes.js
      utils/
        attributeParser.js
        entityUtils.js
        statusUtils.js
  features/
    admin/
      api/
        adminService.js
      components/
        AdminForm.jsx
        AdminFormStyles.js
        EncounterManager.jsx
        EntitySearch.jsx
        EventTagger.jsx
        ImageLibraryModal.jsx
        MarkdownEditor.jsx
        QuestObjectiveManager.jsx
        RelationshipManager.jsx
        SessionEventManager.jsx
        SmartImageInput.jsx
      config/
        adminStrategies.js
        imageLibrary.js
        imageManifest.json
      layouts/
        AdminLayout.jsx
      pages/
        EntityEditorPage.jsx
        EntityListPage.jsx
        SplitPaneManager.jsx
    atlas/
      MapPage.jsx
      useMapData.js
      components/
        MapCanvas.jsx
        MapLayerControl.jsx
        MapTools.jsx
        useMapCanvasViewModel.js
        layers/
          MapAreas.jsx
          MapMarkers.jsx
          MapOverlays.jsx
          MapRecaps.jsx
      config/
        mapConfig.js
      data/
      utils/
        mapNavigation.js
        markerUtils.js
    campaign/
      CampaignContext.jsx
      useCampaignPersistence.js
      useCampaignSelection.js
      api/
        campaignService.js
      components/
        CampaignCard.jsx
        CampaignSelect.jsx
    dashboard/
      DashboardPage.jsx
      api/
        dashboardService.js
      components/
        ActiveQuestsWidget.jsx
        CampaignHero.jsx
        LatestSessionCard.jsx
        QuickInsights.jsx
        RecentEncountersWidget.jsx
        RecentSessionsList.jsx
        SessionRecapCard.jsx
    graph/
      GraphPage.jsx
      useGraphView.js
      api/
        graphService.js
      components/
        CytoscapeCanvas.jsx
        GraphLegend.jsx
      config/
        graphStyles.js
      utils/
        graphMapper.js
    navigation/
      MainLayout.jsx
      useNavigation.js
      components/
        Sidebar.jsx
        SidebarFooter.jsx
        SidebarHeader.jsx
        SidebarNav.jsx
      config/
        navConfig.js
    search/
      GlobalSearch.jsx
      SearchContext.jsx
      useGlobalSearch.js
      api/
        searchService.js
      components/
        SearchFooter.jsx
        SearchModal.jsx
        SearchResultItem.jsx
        SearchResults.jsx
        SearchTrigger.jsx
      utils/
        searchMapper.js
    smart-text/
      SmartMarkdown.jsx
      useEntityIndex.js
      useSmartText.js
      components/
        EntityEmbed.jsx
        SmartEntityLink.jsx
    smart-tooltip/
      TooltipContainer.jsx
      TooltipContext.jsx
      useSmartPosition.js
      useTooltipState.js
      components/
        TooltipCard.jsx
    table-of-contents/
      TableOfContents.jsx
      components/
        TocItem.jsx
        TocMobileDrawer.jsx
      hooks/
        useTocObserver.js
        useTocScroll.js
    timeline/
      TimelinePage.jsx
      useTimelineView.js
      api/
        timelineService.js
      components/
        TimelineEvent.jsx
        TimelineSession.jsx
      utils/
        eventStyles.js
    wiki/
      useEntityView.js
      useWikiNavigation.js
      WikiLayout.jsx
      api/
        wikiService.js
      components/
        EncounterTimeline.jsx
        EntityBody.jsx
        EntityHeader.jsx
        EntityHistory.jsx
        EntitySidebar.jsx
        QuestObjectives.jsx
        SessionMentions.jsx
        WikiEntryView.jsx
        landing/
          EntityGridCard.jsx
          EntityTableGroup.jsx
          Swimlane.jsx
        navigation/
          SidebarEmptyState.jsx
          WikiSidebar.jsx
          WikiSidebarHeader.jsx
          WikiSidebarList.jsx
          sidebar/
            CollapsibleGroup.jsx
            EntityListItem.jsx
            PriorityIcon.jsx
            SidebarTreeItem.jsx
            StatusIcon.jsx
      config/
        groupingConfig.js
        viewStrategies.js
      hooks/
        useEntityContent.js
        useEntityFetching.js
        useEntityGrouping.js
        useEntityHeader.js
        useEntitySidebar.js
      layouts/
        SessionLayout.jsx
        StandardLayout.jsx
      pages/
        WikiDetailPage.jsx
        WikiLandingPage.jsx
      utils/
        attributeMapper.js
        eventMapper.js
        relationshipMapper.js
        wikiEntryMapper.js
        wikiUtils.js
  shared/
    api/
      supabaseClient.js
    components/
      ErrorBoundary.jsx
      layout/
        CollapsibleSection.jsx
        SplitView.jsx
        TabContainer.jsx
      markdown/
        MarkdownRenderer.jsx
        MarkdownWithToC.jsx
      ui/
        Breadcrumbs.jsx
        Button.jsx
        Card.jsx
        DevAdminButton.jsx
        Drawer.jsx
        EmptyState.jsx
        LoadingSpinner.jsx
        SectionDivider.jsx
    hooks/
      useBreadcrumbs.js
      useTheme.js
    utils/
      imageUtils.js
      markdownUtils.js
      textUtils.js
      theme/
        colorUtils.js
        cssUtils.js

================================================================
### SOURCE CODE
================================================================

--- FILE: features\timeline\TimelinePage.jsx ---
import { useTimelineViewModel } from './useTimelineView';
import { TimelineSession } from './components/TimelineSession';
import { TableOfContents } from '@/features/table-of-contents/TableOfContents';

export default function TimelineView() {
	const { sessions, isLoading } = useTimelineViewModel();

	if (isLoading) return <div className='p-8 text-center text-gray-400'>Loading timeline...</div>;

	// Construct ToC items manually for the timeline sessions
	const tocItems = sessions.map((s) => ({
		id: `session-marker-${s.number}`,
		text: `${s.title}`,
		depth: 1,
	}));

	return (
		<div className='h-full overflow-hidden flex flex-col'>
			<div className='flex-1 overflow-y-auto bg-background custom-scrollbar'>
				{/* ARCHITECTURE FIX: Grid Layout for Timeline + ToC */}
				<div className='max-w-7xl mx-auto p-6 md:p-12'>
					<h1 className='text-3xl font-serif font-bold text-foreground mb-10'>Campaign History</h1>

					<div className='grid grid-cols-1 xl:grid-cols-[1fr_240px] gap-12 relative'>
						{/* Column 1: Timeline Content */}
						<div className='relative border-l-2 border-slate-100 ml-4 space-y-16 pb-20'>
							{sessions.map((session) => (
								/* Added scroll-mt to account for sticky headers if any */
								<div key={session.id} id={`session-marker-${session.number}`} className='scroll-mt-24'>
									<TimelineSession session={session} />
								</div>
							))}
						</div>

						{/* Column 2: ToC */}
						{/* Sync visibility with the grid breakpoint (xl) */}
						<TableOfContents items={tocItems} visibilityClass='hidden xl:block' mobileToggleClass='xl:hidden' />
					</div>
				</div>
			</div>
		</div>
	);
}

--- END OF features\timeline\TimelinePage.jsx ---

--- FILE: features\timeline\useTimelineView.js ---
import { useMemo } from 'react';
import { useQuery } from '@tanstack/react-query';
import { getTimeline } from '@/features/timeline/api/timelineService';
import { useCampaign } from '@/features/campaign/CampaignContext';
import { getEventStyle } from './utils/eventStyles';
// import './types';

/**
 * @returns {{ sessions: import('./types').TimelineSessionModel[], isLoading: boolean }}
 */
export function useTimelineViewModel() {
	const { campaignId } = useCampaign();

	const { data, isLoading } = useQuery({
		queryKey: ['timeline', campaignId],
		queryFn: () => getTimeline(campaignId),
		enabled: !!campaignId,
	});

	const sessions = useMemo(() => {
		return (data || []).map((session) => {
			// Sort events safely: Use spread to avoid mutating read-only cache, handle nulls
			const sortedEvents = [...(session.events || [])].sort((a, b) => (a.event_order || 0) - (b.event_order || 0));

			// Map events to View Model
			const events = sortedEvents.map((event) => {
				// TRANSFORMATION: Convert relationships to tags
				const tags = (event.relationships || [])
					.map((rel) => {
						if (!rel.target) return null;
						return {
							name: rel.target.name,
							type: rel.target.type?.toLowerCase() || 'default',
						};
					})
					.filter(Boolean); // Remove nulls

				return {
					id: event.id,
					title: event.title,
					typeLabel: event.event_type?.replace(/_/g, ' ') || 'Event',
					description: event.description,
					tags, // New property containing all connected entities
					style: getEventStyle(event.event_type),
				};
			});

			return {
				id: session.id,
				number: session.session_number,
				dateLabel: session.session_date || 'Unknown Date',
				title: session.title,
				events,
			};
		});
	}, [data]);

	return { sessions, isLoading };
}

--- END OF features\timeline\useTimelineView.js ---

--- FILE: features\timeline\api\timelineService.js ---
import { supabase } from '@/shared/api/supabaseClient';
import { getAttributeValue } from '@/domain/entity/utils/attributeParser';

export const getTimeline = async (campaignId) => {
	// 1. Fetch Sessions (No summary)
	const { data: sessions, error: sessionError } = await supabase
		.from('sessions')
		.select(
			`
            id, 
            title, 
            narrative,
            events:session_events (
                id, 
                title, 
                description, 
                event_type, 
                event_order
            )
        `
		)
		.eq('campaign_id', campaignId);

	if (sessionError) throw sessionError;
	if (!sessions || sessions.length === 0) return [];

	// 2. Fetch Attributes
	const sessionIds = sessions.map((s) => s.id);
	const { data: attributes } = await supabase
		.from('attributes')
		.select('entity_id, name, value')
		.in('entity_id', sessionIds);

	const attrMap = new Map();
	(attributes || []).forEach((attr) => {
		if (!attrMap.has(attr.entity_id)) attrMap.set(attr.entity_id, []);
		attrMap.get(attr.entity_id).push(attr);
	});

	// 3. Process
	const processedSessions = sessions
		.map((s) => {
			const rawAttrs = attrMap.get(s.id) || [];
			const attrs = rawAttrs.reduce((acc, c) => {
				acc[c.name] = c.value;
				return acc;
			}, {});

			const num = getAttributeValue(attrs, ['session_number', 'Session']) || 999;
			const date = getAttributeValue(attrs, ['session_date', 'Date']) || 'Unknown Date';

			return {
				...s,
				session_number: Number(num),
				session_date: date,
				attributes: attrs,
				events: s.events || [],
			};
		})
		.sort((a, b) => a.session_number - b.session_number);

	// ... Steps 4, 5, 6 (Tags logic) remain exactly the same ...
	// (Included for completeness)
	const allEvents = processedSessions.flatMap((s) => s.events);
	const eventIds = allEvents.map((e) => e.id);

	if (eventIds.length === 0) return processedSessions;

	const { data: relationships, error: relError } = await supabase
		.from('entity_relationships')
		.select(`from_entity_id, target:entities!to_entity_id ( name, type )`)
		.in('from_entity_id', eventIds);

	if (relError) return processedSessions;

	const relMap = new Map();
	relationships.forEach((rel) => {
		if (!relMap.has(rel.from_entity_id)) relMap.set(rel.from_entity_id, []);
		relMap.get(rel.from_entity_id).push(rel);
	});

	processedSessions.forEach((session) => {
		if (session.events.length > 0) {
			session.events.sort((a, b) => (a.event_order || 0) - (b.event_order || 0));
			session.events.forEach((event) => {
				event.relationships = relMap.get(event.id) || [];
			});
		}
	});

	return processedSessions;
};

--- END OF features\timeline\api\timelineService.js ---

--- FILE: features\timeline\components\TimelineEvent.jsx ---
import { useMemo } from 'react';
import { clsx } from 'clsx';
import { getEntityConfig } from '@/domain/entity/config/entityConfig';
import SmartMarkdown from '@/features/smart-text/SmartMarkdown';
import { Diamond } from 'lucide-react';

export const TimelineEvent = ({ event }) => {
	const { Icon, container } = event.style;

	// Group tags by entity type
	const groupedTags = useMemo(() => {
		if (!event.tags || event.tags.length === 0) return [];

		const groups = {};
		event.tags.forEach((tag) => {
			const type = tag.type || 'default';
			if (!groups[type]) {
				groups[type] = [];
			}
			groups[type].push(tag);
		});

		// Convert to array of groups
		return Object.values(groups);
	}, [event.tags]);

	return (
		<div className='relative flex gap-4 group'>
			{/* Icon Bubble */}
			<div
				className={clsx(
					'shrink-0 w-8 h-8 rounded-full flex items-center justify-center shadow-sm border-2 z-10 transition-transform group-hover:scale-110',
					container
				)}>
				<Icon size={14} strokeWidth={2.5} />
			</div>

			{/* Content */}
			<div className='flex-1 -mt-1 pb-2'>
				<h4 className='text-sm font-bold text-gray-800 mb-1 flex items-center gap-2'>
					{event.title}
					<span className='text-[9px] font-normal uppercase tracking-wider text-gray-800 border border-border px-1.5 rounded-sm bg-muted ml-auto'>
						{event.typeLabel}
					</span>
				</h4>

				{event.description && (
					<div className='text-sm text-gray-600 leading-relaxed text-pretty text-justify'>
						<SmartMarkdown>{event.description}</SmartMarkdown>
					</div>
				)}

				{/* Grouped Tags with Separators */}
				{groupedTags.length > 0 && (
					<div className='flex flex-wrap items-center gap-2 mt-2'>
						{groupedTags.map((group, groupIndex) => (
							<div key={groupIndex} className='flex items-center gap-2'>
								{/* Tags in this group */}
								<div className='flex flex-wrap gap-1.5'>
									{group.map((tag, idx) => {
										const config = getEntityConfig(tag.type);
										const TagIcon = config.icon;
										const styles = config.tailwind;

										return (
											<span
												key={`${tag.name}-${idx}`}
												className={clsx(
													'inline-flex items-center gap-1 text-[10px] uppercase font-bold px-1.5 py-0.5 rounded border cursor-default',
													styles.bg,
													styles.text,
													styles.border
												)}>
												<TagIcon size={10} /> {tag.name}
											</span>
										);
									})}
								</div>

								{/* Separator (except after last group) */}
								{groupIndex < groupedTags.length - 1 && (
									<Diamond size={6} className='text-gray-300 fill-gray-300 shrink-0' />
								)}
							</div>
						))}
					</div>
				)}
			</div>
		</div>
	);
};

--- END OF features\timeline\components\TimelineEvent.jsx ---

--- FILE: features\timeline\components\TimelineSession.jsx ---
import { Calendar } from 'lucide-react';
import { TimelineEvent } from './TimelineEvent';

export const TimelineSession = ({ session }) => {
	return (
		<div className='relative pl-8 md:pl-12'>
			{/* Session Marker (Circle on the main line) */}
			<div className='absolute -left-[9px] top-0 flex items-center justify-center w-5 h-5 rounded-full bg-background border-2 border-gray-300 shadow-sm z-10'>
				<div className='w-2 h-2 rounded-full bg-gray-400' />
			</div>

			{/* Session Header */}
			<div className='mb-8'>
				<div className='flex flex-col sm:flex-row sm:items-center gap-2 sm:gap-4 mb-2'>
					<span className='text-[10px] font-bold uppercase tracking-wider text-gray-500 bg-gray-100 px-2 py-0.5 rounded self-start border border-border'>
						Session {session.number - 1}
					</span>
					<time className='text-xs text-gray-400 flex items-center gap-1 font-medium'>
						<Calendar size={12} /> {session.dateLabel}
					</time>
				</div>
				<h2 className='text-2xl font-serif font-bold text-foreground mb-3'>{session.title}</h2>
			</div>

			{/* Events List */}
			<div className='space-y-6 relative'>
				{/* Connector Line for events */}
				<div className='absolute left-[15px] top-4 bottom-4 w-0.5 bg-gray-100 -z-10' />

				{session.events.map((event) => (
					<TimelineEvent key={event.id} event={event} />
				))}
			</div>
		</div>
	);
};

--- END OF features\timeline\components\TimelineSession.jsx ---

--- FILE: features\timeline\utils\eventStyles.js ---
import { getEntityStyles } from '@/domain/entity/config/entityStyles';
import {
	Sword,
	Skull,
	MessageSquare,
	Scroll,
	CheckCircle2,
	Footprints,
	Map,
	MapPin,
	User,
	Flag,
	Search,
	BookOpen,
	Sparkles,
	Eye,
	ShoppingBag,
	Star,
	Tent,
} from 'lucide-react';

export const getEventStyle = (eventType) => {
	const type = eventType?.toLowerCase() || '';

	let entityType = 'default';
	let Icon = Star;

	switch (type) {
		case 'combat':
			entityType = 'encounter'; // Orange
			Icon = Skull;
			break;
		case 'social':
			entityType = 'npc'; // Amber
			Icon = MessageSquare;
			break;
		case 'quest_started':
			entityType = 'quest'; // Blue
			Icon = Scroll;
			break;
		case 'quest_progressed':
			entityType = 'quest'; // Blue
			Icon = CheckCircle2;
			break;
		case 'travel':
			entityType = 'location'; // Emerald
			Icon = Footprints; // Journeys
			break;
		case 'location_discovered':
			entityType = 'location'; // Emerald
			Icon = Map; // Finding new places
			break;
		case 'location_visited':
			entityType = 'location'; // Emerald
			Icon = MapPin; // Arriving at known places
			break;
		case 'npc_encountered':
			entityType = 'npc'; // Amber
			Icon = User;
			break;
		case 'faction_discovered':
			entityType = 'faction'; // Purple
			Icon = Flag;
			break;
		case 'investigation':
			entityType = 'default'; // Gray (Neutral/Mechanics)
			Icon = Search;
			break;
		case 'backstory':
			entityType = 'character'; // Red (Personal)
			Icon = BookOpen;
			break;
		case 'discovery':
			entityType = 'encounter'; // Orange (Loot/Items/Secrets)
			Icon = Sparkles;
			break;
		case 'vision':
			entityType = 'faction'; // Purple (Magic/Mystical)
			Icon = Eye;
			break;
		case 'shopping':
			entityType = 'npc'; // Amber (Trade/Commerce)
			Icon = ShoppingBag;
			break;
		case 'special_event':
			entityType = 'session'; // Slate (Meta/Unique)
			Icon = Star;
			break;
		// Fallbacks for legacy types or fuzzy matches
		default:
			if (type.match(/combat|fight|kill/)) {
				entityType = 'encounter';
				Icon = Sword;
			} else if (type.match(/npc|social|meet/)) {
				entityType = 'npc';
				Icon = MessageSquare;
			} else if (type.match(/location|visit|arrive/)) {
				entityType = 'location';
				Icon = MapPin;
			} else if (type.match(/quest|mission/)) {
				entityType = 'quest';
				Icon = Scroll;
			} else if (type.match(/camp|rest/)) {
				entityType = 'location';
				Icon = Tent;
			} else {
				entityType = 'default';
				Icon = Star;
			}
	}

	// Use centralized styles
	const styles = getEntityStyles(entityType);

	return {
		Icon,
		// Map standard styles to timeline specific class structure
		container: `${styles.border} ${styles.bg} ${styles.text}`,
		// Heuristic for line color (usually 200 or 300 shade) based on bg class
		line: styles.bg.replace('-50', '-200'),
	};
};

--- END OF features\timeline\utils\eventStyles.js ---

